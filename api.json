{
  "swagger": "2.0",
  "info": {
    "title": "Terra REST apis",
    "version": "1.0.0",
    "description": "Terra LCD and FCD docs"
  },
  "paths": {
    "/node_info": {
      "get": {
        "description": "Information about the connected node",
        "summary": "The properties of the connected node",
        "tags": [
          "Terra REST"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Node status",
            "schema": {
              "type": "object",
              "properties": {
                "application_version": {
                  "properties": {
                    "build_tags": {
                      "type": "string"
                    },
                    "client_name": {
                      "type": "string"
                    },
                    "commit": {
                      "type": "string"
                    },
                    "go": {
                      "type": "string"
                    },
                    "name": {
                      "type": "string"
                    },
                    "server_name": {
                      "type": "string"
                    },
                    "version": {
                      "type": "string"
                    }
                  }
                },
                "node_info": {
                  "properties": {
                    "id": {
                      "type": "string"
                    },
                    "moniker": {
                      "type": "string",
                      "example": "validator-name"
                    },
                    "protocol_version": {
                      "properties": {
                        "p2p": {
                          "type": "string",
                          "example": 7
                        },
                        "block": {
                          "type": "string",
                          "example": 10
                        },
                        "app": {
                          "type": "string",
                          "example": 0
                        }
                      }
                    },
                    "network": {
                      "type": "string",
                      "example": "gaia-2"
                    },
                    "channels": {
                      "type": "string"
                    },
                    "listen_addr": {
                      "type": "string",
                      "example": "192.168.56.1:26656"
                    },
                    "version": {
                      "description": "Tendermint version",
                      "type": "string",
                      "example": "0.15.0"
                    },
                    "other": {
                      "description": "more information on versions",
                      "type": "object",
                      "properties": {
                        "tx_index": {
                          "type": "string",
                          "example": "on"
                        },
                        "rpc_address": {
                          "type": "string",
                          "example": "tcp://0.0.0.0:26657"
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Failed to query node status"
          }
        }
      }
    },
    "/syncing": {
      "get": {
        "summary": "Syncing state of node",
        "tags": [
          "Tendermint RPC"
        ],
        "description": "Get if the node is currently syning with other nodes",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Node syncing status",
            "schema": {
              "type": "object",
              "properties": {
                "syncing": {
                  "type": "boolean"
                }
              }
            }
          },
          "500": {
            "description": "Server internal error"
          }
        }
      }
    },
    "/blocks/latest": {
      "get": {
        "summary": "Get the latest block",
        "tags": [
          "Tendermint RPC"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The latest block",
            "schema": {
              "type": "object",
              "properties": {
                "block_meta": {
                  "type": "object",
                  "properties": {
                    "header": {
                      "type": "object",
                      "properties": {
                        "chain_id": {
                          "type": "string",
                          "example": "columbus-5"
                        },
                        "height": {
                          "type": "number",
                          "example": 1
                        },
                        "time": {
                          "type": "string",
                          "example": "2017-12-30T05:53:09.287+01:00"
                        },
                        "num_txs": {
                          "type": "number",
                          "example": 0
                        },
                        "last_block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                            },
                            "parts": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "number",
                                  "example": 0
                                },
                                "hash": {
                                  "type": "string",
                                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                }
                              }
                            }
                          }
                        },
                        "total_txs": {
                          "type": "number",
                          "example": 35
                        },
                        "last_commit_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "data_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "validators_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "next_validators_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "consensus_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "app_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "last_results_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "evidence_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "proposer_address": {
                          "type": "string",
                          "description": "bech32 encoded address",
                          "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                        },
                        "version": {
                          "type": "object",
                          "properties": {
                            "block": {
                              "type": "string",
                              "example": 10
                            },
                            "app": {
                              "type": "string",
                              "example": 0
                            }
                          }
                        }
                      }
                    },
                    "block_id": {
                      "type": "object",
                      "properties": {
                        "hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "parts": {
                          "type": "object",
                          "properties": {
                            "total": {
                              "type": "number",
                              "example": 0
                            },
                            "hash": {
                              "type": "string",
                              "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "block": {
                  "type": "object",
                  "properties": {
                    "header": {
                      "type": "object",
                      "properties": {
                        "chain_id": {
                          "type": "string",
                          "example": "columbus-5"
                        },
                        "height": {
                          "type": "number",
                          "example": 1
                        },
                        "time": {
                          "type": "string",
                          "example": "2017-12-30T05:53:09.287+01:00"
                        },
                        "num_txs": {
                          "type": "number",
                          "example": 0
                        },
                        "last_block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                            },
                            "parts": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "number",
                                  "example": 0
                                },
                                "hash": {
                                  "type": "string",
                                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                }
                              }
                            }
                          }
                        },
                        "total_txs": {
                          "type": "number",
                          "example": 35
                        },
                        "last_commit_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "data_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "validators_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "next_validators_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "consensus_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "app_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "last_results_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "evidence_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "proposer_address": {
                          "type": "string",
                          "description": "bech32 encoded address",
                          "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                        },
                        "version": {
                          "type": "object",
                          "properties": {
                            "block": {
                              "type": "string",
                              "example": 10
                            },
                            "app": {
                              "type": "string",
                              "example": 0
                            }
                          }
                        }
                      }
                    },
                    "txs": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "evidence": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "last_commit": {
                      "type": "object",
                      "properties": {
                        "block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                            },
                            "parts": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "number",
                                  "example": 0
                                },
                                "hash": {
                                  "type": "string",
                                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                }
                              }
                            }
                          }
                        },
                        "precommits": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "validator_address": {
                                "type": "string"
                              },
                              "validator_index": {
                                "type": "string",
                                "example": "0"
                              },
                              "height": {
                                "type": "string",
                                "example": "0"
                              },
                              "round": {
                                "type": "string",
                                "example": "0"
                              },
                              "timestamp": {
                                "type": "string",
                                "example": "2017-12-30T05:53:09.287+01:00"
                              },
                              "type": {
                                "type": "number",
                                "example": 2
                              },
                              "block_id": {
                                "type": "object",
                                "properties": {
                                  "hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                  },
                                  "parts": {
                                    "type": "object",
                                    "properties": {
                                      "total": {
                                        "type": "number",
                                        "example": 0
                                      },
                                      "hash": {
                                        "type": "string",
                                        "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                      }
                                    }
                                  }
                                }
                              },
                              "signature": {
                                "type": "string",
                                "example": "7uTC74QlknqYWEwg7Vn6M8Om7FuZ0EO4bjvuj6rwH1mTUJrRuMMZvAAqT9VjNgP0RA/TDp6u/92AqrZfXJSpBQ=="
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Server internal error"
          }
        }
      }
    },
    "/blocks/{height}": {
      "get": {
        "summary": "Get a block at a certain height",
        "tags": [
          "Tendermint RPC"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "height",
            "description": "Block height",
            "required": true,
            "type": "number",
            "x-example": 1
          }
        ],
        "responses": {
          "200": {
            "description": "The block at a specific height",
            "schema": {
              "type": "object",
              "properties": {
                "block_meta": {
                  "type": "object",
                  "properties": {
                    "header": {
                      "type": "object",
                      "properties": {
                        "chain_id": {
                          "type": "string",
                          "example": "columbus-5"
                        },
                        "height": {
                          "type": "number",
                          "example": 1
                        },
                        "time": {
                          "type": "string",
                          "example": "2017-12-30T05:53:09.287+01:00"
                        },
                        "num_txs": {
                          "type": "number",
                          "example": 0
                        },
                        "last_block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                            },
                            "parts": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "number",
                                  "example": 0
                                },
                                "hash": {
                                  "type": "string",
                                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                }
                              }
                            }
                          }
                        },
                        "total_txs": {
                          "type": "number",
                          "example": 35
                        },
                        "last_commit_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "data_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "validators_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "next_validators_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "consensus_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "app_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "last_results_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "evidence_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "proposer_address": {
                          "type": "string",
                          "description": "bech32 encoded address",
                          "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                        },
                        "version": {
                          "type": "object",
                          "properties": {
                            "block": {
                              "type": "string",
                              "example": 10
                            },
                            "app": {
                              "type": "string",
                              "example": 0
                            }
                          }
                        }
                      }
                    },
                    "block_id": {
                      "type": "object",
                      "properties": {
                        "hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "parts": {
                          "type": "object",
                          "properties": {
                            "total": {
                              "type": "number",
                              "example": 0
                            },
                            "hash": {
                              "type": "string",
                              "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "block": {
                  "type": "object",
                  "properties": {
                    "header": {
                      "type": "object",
                      "properties": {
                        "chain_id": {
                          "type": "string",
                          "example": "columbus-5"
                        },
                        "height": {
                          "type": "number",
                          "example": 1
                        },
                        "time": {
                          "type": "string",
                          "example": "2017-12-30T05:53:09.287+01:00"
                        },
                        "num_txs": {
                          "type": "number",
                          "example": 0
                        },
                        "last_block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                            },
                            "parts": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "number",
                                  "example": 0
                                },
                                "hash": {
                                  "type": "string",
                                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                }
                              }
                            }
                          }
                        },
                        "total_txs": {
                          "type": "number",
                          "example": 35
                        },
                        "last_commit_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "data_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "validators_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "next_validators_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "consensus_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "app_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "last_results_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "evidence_hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "proposer_address": {
                          "type": "string",
                          "description": "bech32 encoded address",
                          "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                        },
                        "version": {
                          "type": "object",
                          "properties": {
                            "block": {
                              "type": "string",
                              "example": 10
                            },
                            "app": {
                              "type": "string",
                              "example": 0
                            }
                          }
                        }
                      }
                    },
                    "txs": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "evidence": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "last_commit": {
                      "type": "object",
                      "properties": {
                        "block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                            },
                            "parts": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "number",
                                  "example": 0
                                },
                                "hash": {
                                  "type": "string",
                                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                }
                              }
                            }
                          }
                        },
                        "precommits": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "validator_address": {
                                "type": "string"
                              },
                              "validator_index": {
                                "type": "string",
                                "example": "0"
                              },
                              "height": {
                                "type": "string",
                                "example": "0"
                              },
                              "round": {
                                "type": "string",
                                "example": "0"
                              },
                              "timestamp": {
                                "type": "string",
                                "example": "2017-12-30T05:53:09.287+01:00"
                              },
                              "type": {
                                "type": "number",
                                "example": 2
                              },
                              "block_id": {
                                "type": "object",
                                "properties": {
                                  "hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                  },
                                  "parts": {
                                    "type": "object",
                                    "properties": {
                                      "total": {
                                        "type": "number",
                                        "example": 0
                                      },
                                      "hash": {
                                        "type": "string",
                                        "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                      }
                                    }
                                  }
                                }
                              },
                              "signature": {
                                "type": "string",
                                "example": "7uTC74QlknqYWEwg7Vn6M8Om7FuZ0EO4bjvuj6rwH1mTUJrRuMMZvAAqT9VjNgP0RA/TDp6u/92AqrZfXJSpBQ=="
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid height"
          },
          "404": {
            "description": "Request block height doesn't"
          },
          "500": {
            "description": "Server internal error"
          }
        }
      }
    },
    "/validatorsets/latest": {
      "get": {
        "summary": "Get the latest validator set",
        "tags": [
          "Tendermint RPC"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The validator set at the latest block height",
            "schema": {
              "type": "object",
              "properties": {
                "block_height": {
                  "type": "string"
                },
                "validators": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "address": {
                        "type": "string",
                        "description": "bech32 encoded address",
                        "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
                      },
                      "pub_key": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string"
                          },
                          "value": {
                            "type": "string"
                          }
                        }
                      },
                      "voting_power": {
                        "type": "string",
                        "example": "1000"
                      },
                      "proposer_priority": {
                        "type": "string",
                        "example": "1000"
                      }
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Server internal error"
          }
        }
      }
    },
    "/validatorsets/{height}": {
      "get": {
        "summary": "Get a validator set a certain height",
        "tags": [
          "Tendermint RPC"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "height",
            "description": "Block height",
            "required": true,
            "type": "number",
            "x-example": 1
          }
        ],
        "responses": {
          "200": {
            "description": "The validator set at a specific block height",
            "schema": {
              "type": "object",
              "properties": {
                "block_height": {
                  "type": "string"
                },
                "validators": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "address": {
                        "type": "string",
                        "description": "bech32 encoded address",
                        "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
                      },
                      "pub_key": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string"
                          },
                          "value": {
                            "type": "string"
                          }
                        }
                      },
                      "voting_power": {
                        "type": "string",
                        "example": "1000"
                      },
                      "proposer_priority": {
                        "type": "string",
                        "example": "1000"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid height"
          },
          "404": {
            "description": "Block at height not available"
          },
          "500": {
            "description": "Server internal error"
          }
        }
      }
    },
    "/txs/{hash}": {
      "get": {
        "deprecated": true,
        "summary": "Get a Tx by hash",
        "tags": [
          "Transactions"
        ],
        "description": "Retrieve a transaction using its hash.",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "hash",
            "description": "Tx hash",
            "required": true,
            "type": "string",
            "x-example": "BCBE20E8D46758B96AE5883B792858296AC06E51435490FBDCAE25A72B3CC76B"
          }
        ],
        "responses": {
          "200": {
            "description": "Tx with the provided hash",
            "schema": {
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "example": "D085138D913993919295FF4B0A9107F1F2CDE0D37A87CE0644E217CBF3B49656"
                },
                "height": {
                  "type": "number",
                  "example": 368
                },
                "tx": {
                  "type": "object",
                  "properties": {
                    "msg": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "fee": {
                      "type": "object",
                      "properties": {
                        "gas": {
                          "type": "string"
                        },
                        "amount": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "denom": {
                                "type": "string",
                                "example": "uluna"
                              },
                              "amount": {
                                "type": "string",
                                "example": "50"
                              }
                            }
                          }
                        }
                      }
                    },
                    "memo": {
                      "type": "string"
                    },
                    "signature": {
                      "type": "object",
                      "properties": {
                        "signature": {
                          "type": "string",
                          "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                        },
                        "pub_key": {
                          "type": "object",
                          "properties": {
                            "type": {
                              "type": "string",
                              "example": "tendermint/PubKeySecp256k1"
                            },
                            "value": {
                              "type": "string",
                              "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                            }
                          }
                        },
                        "account_number": {
                          "type": "string",
                          "example": "0"
                        },
                        "sequence": {
                          "type": "string",
                          "example": "0"
                        }
                      }
                    }
                  }
                },
                "result": {
                  "type": "object",
                  "properties": {
                    "log": {
                      "type": "string"
                    },
                    "gas_wanted": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_used": {
                      "type": "string",
                      "example": "26354"
                    },
                    "tags": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "key": {
                            "type": "string"
                          },
                          "value": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/txs": {
      "get": {
        "deprecated": true,
        "tags": [
          "Transactions"
        ],
        "summary": "Search transactions",
        "description": "Search transactions by events.",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "message.action",
            "type": "string",
            "description": "transaction events such as 'message.action=send' which results in the following endpoint: 'GET /txs?message.action=send'. note that each module documents its own events. look for xx_events.md in the corresponding cosmos-sdk/docs/spec directory",
            "x-example": "send"
          },
          {
            "in": "query",
            "name": "message.sender",
            "type": "string",
            "description": "transaction events with sender: 'GET /txs?message.action=send&message.sender=terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv'",
            "x-example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
          },
          {
            "in": "query",
            "name": "page",
            "description": "Page number",
            "type": "integer",
            "x-example": 1
          },
          {
            "in": "query",
            "name": "limit",
            "description": "Maximum number of items per page",
            "type": "integer",
            "x-example": 1
          },
          {
            "in": "query",
            "name": "tx.minheight",
            "type": "integer",
            "description": "transactions on blocks with height greater or equal this value",
            "x-example": 25
          },
          {
            "in": "query",
            "name": "tx.maxheight",
            "type": "integer",
            "description": "transactions on blocks with height less than or equal this value",
            "x-example": 800000
          }
        ],
        "responses": {
          "200": {
            "description": "All txs matching the provided events",
            "schema": {
              "type": "object",
              "properties": {
                "total_count": {
                  "type": "number",
                  "example": 1
                },
                "count": {
                  "type": "number",
                  "example": 1
                },
                "page_number": {
                  "type": "number",
                  "example": 1
                },
                "page_total": {
                  "type": "number",
                  "example": 1
                },
                "limit": {
                  "type": "number",
                  "example": 30
                },
                "txs": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "hash": {
                        "type": "string",
                        "example": "D085138D913993919295FF4B0A9107F1F2CDE0D37A87CE0644E217CBF3B49656"
                      },
                      "height": {
                        "type": "number",
                        "example": 368
                      },
                      "tx": {
                        "type": "object",
                        "properties": {
                          "msg": {
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "fee": {
                            "type": "object",
                            "properties": {
                              "gas": {
                                "type": "string"
                              },
                              "amount": {
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "denom": {
                                      "type": "string",
                                      "example": "uluna"
                                    },
                                    "amount": {
                                      "type": "string",
                                      "example": "50"
                                    }
                                  }
                                }
                              }
                            }
                          },
                          "memo": {
                            "type": "string"
                          },
                          "signature": {
                            "type": "object",
                            "properties": {
                              "signature": {
                                "type": "string",
                                "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                              },
                              "pub_key": {
                                "type": "object",
                                "properties": {
                                  "type": {
                                    "type": "string",
                                    "example": "tendermint/PubKeySecp256k1"
                                  },
                                  "value": {
                                    "type": "string",
                                    "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                  }
                                }
                              },
                              "account_number": {
                                "type": "string",
                                "example": "0"
                              },
                              "sequence": {
                                "type": "string",
                                "example": "0"
                              }
                            }
                          }
                        }
                      },
                      "result": {
                        "type": "object",
                        "properties": {
                          "log": {
                            "type": "string"
                          },
                          "gas_wanted": {
                            "type": "string",
                            "example": "200000"
                          },
                          "gas_used": {
                            "type": "string",
                            "example": "26354"
                          },
                          "tags": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "key": {
                                  "type": "string"
                                },
                                "value": {
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid search events"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/txs/encode": {
      "post": {
        "deprecated": true,
        "tags": [
          "Transactions"
        ],
        "summary": "Encode a legacy transaction to the Proto wire format",
        "description": "Encode a legacy transaction (signed or not) from JSON to base64-encoded Proto serialized bytes",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "tx",
            "description": "The tx to encode",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "tx": {
                  "type": "object",
                  "properties": {
                    "msg": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "fee": {
                      "type": "object",
                      "properties": {
                        "gas": {
                          "type": "string"
                        },
                        "amount": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "denom": {
                                "type": "string",
                                "example": "uluna"
                              },
                              "amount": {
                                "type": "string",
                                "example": "50"
                              }
                            }
                          }
                        }
                      }
                    },
                    "memo": {
                      "type": "string"
                    },
                    "signature": {
                      "type": "object",
                      "properties": {
                        "signature": {
                          "type": "string",
                          "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                        },
                        "pub_key": {
                          "type": "object",
                          "properties": {
                            "type": {
                              "type": "string",
                              "example": "tendermint/PubKeySecp256k1"
                            },
                            "value": {
                              "type": "string",
                              "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                            }
                          }
                        },
                        "account_number": {
                          "type": "string",
                          "example": "0"
                        },
                        "sequence": {
                          "type": "string",
                          "example": "0"
                        }
                      }
                    }
                  }
                },
                "sequences": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "example": "1"
                  }
                },
                "fee_granter": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The tx was successfully decoded and re-encoded",
            "schema": {
              "type": "object",
              "properties": {
                "tx": {
                  "type": "string",
                  "example": "The base64-encoded Proto-serialized bytes for the tx"
                }
              }
            }
          },
          "400": {
            "description": "The tx was malformed"
          },
          "500": {
            "description": "Server internal error"
          }
        }
      }
    },
    "/txs/decode": {
      "post": {
        "deprecated": true,
        "tags": [
          "Transactions"
        ],
        "summary": "Decode a transaction from the Amino wire format",
        "description": "Decode a transaction (signed or not) from base64-encoded Amino serialized bytes to JSON",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "tx",
            "description": "The tx to decode",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "tx": {
                  "type": "string",
                  "example": "SvBiXe4KPqijYZoKFFHEzJ8c2HPAfv2EFUcIhx0yPagwEhTy0vPA+GGhCEslKXa4Af0uB+mfShoMCgVzdGFrZRIDMTAwEgQQwJoM"
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The tx was successfully decoded",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "The tx was malformed"
          },
          "500": {
            "description": "Server internal error"
          }
        }
      }
    },
    "/txs/estimate_fee": {
      "post": {
        "deprecated": true,
        "tags": [
          "Transactions"
        ],
        "summary": "Estimate fee and gas of a transaction",
        "description": "Estimate fee and gas of a transaction according to given parameters",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "transaction",
            "description": "The sender and tx information",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                },
                "msgs": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The fee was successfully estimated",
            "schema": {
              "type": "object",
              "properties": {
                "gas": {
                  "type": "string"
                },
                "amount": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "The tx was malformed"
          },
          "500": {
            "description": "Server internal error"
          }
        }
      }
    },
    "/bank/balances/{address}": {
      "get": {
        "deprecated": true,
        "summary": "Get the account balances",
        "tags": [
          "Bank"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "address",
            "description": "Account address in bech32 format",
            "required": true,
            "type": "string",
            "x-example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
          }
        ],
        "responses": {
          "200": {
            "description": "Account balances",
            "schema": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            }
          },
          "500": {
            "description": "Server internal error"
          }
        }
      }
    },
    "/bank/accounts/{address}/transfers": {
      "post": {
        "deprecated": true,
        "summary": "Send coins from one account to another",
        "tags": [
          "Bank"
        ],
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "address",
            "description": "Account address in bech32 format",
            "required": true,
            "type": "string",
            "x-example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
          },
          {
            "in": "body",
            "name": "account",
            "description": "The sender and tx information",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                },
                "coins": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                }
              }
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Tx was successfully generated",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server internal error"
          }
        }
      }
    },
    "/bank/total": {
      "get": {
        "deprecated": true,
        "summary": "Total supply of coins in the chain",
        "tags": [
          "Bank"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "total": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/bank/total/{denomination}": {
      "get": {
        "deprecated": true,
        "summary": "Total supply of a single coin denomination",
        "tags": [
          "Bank"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "string"
            }
          },
          "400": {
            "description": "Invalid coin denomination"
          },
          "500": {
            "description": "Internal Server Error"
          }
        },
        "parameters": [
          {
            "in": "path",
            "name": "denomination",
            "description": "Coin denomination",
            "required": true,
            "type": "string",
            "x-example": "uluna"
          }
        ]
      }
    },
    "/auth/accounts/{address}": {
      "get": {
        "deprecated": true,
        "summary": "Get the account information on blockchain",
        "tags": [
          "Auth"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "address",
            "description": "Account address",
            "required": true,
            "type": "string",
            "x-example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
          }
        ],
        "responses": {
          "200": {
            "description": "Account information on the blockchain",
            "schema": {
              "type": "object",
              "properties": {
                "Account": {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "example": "core/Account"
                    },
                    "value": {
                      "type": "object",
                      "properties": {
                        "account_number": {
                          "type": "string"
                        },
                        "address": {
                          "type": "string"
                        },
                        "public_key": {
                          "type": "string"
                        },
                        "sequence": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "LazyGradedVestingAccount": {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "example": "core/LazyGradedVestingAccount"
                    },
                    "value": {
                      "type": "object",
                      "properties": {
                        "BaseVestingAccount": {
                          "type": "object",
                          "properties": {
                            "BaseAccount": {
                              "type": "object",
                              "properties": {
                                "account_number": {
                                  "type": "string"
                                },
                                "address": {
                                  "type": "string"
                                },
                                "public_key": {
                                  "type": "string"
                                },
                                "sequence": {
                                  "type": "string"
                                }
                              }
                            },
                            "original_vesting": {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "denom": {
                                    "type": "string",
                                    "example": "uluna"
                                  },
                                  "amount": {
                                    "type": "string",
                                    "example": "50"
                                  }
                                }
                              }
                            },
                            "delegated_free": {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "denom": {
                                    "type": "string",
                                    "example": "uluna"
                                  },
                                  "amount": {
                                    "type": "string",
                                    "example": "50"
                                  }
                                }
                              }
                            },
                            "delegated_vesting": {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "denom": {
                                    "type": "string",
                                    "example": "uluna"
                                  },
                                  "amount": {
                                    "type": "string",
                                    "example": "50"
                                  }
                                }
                              }
                            },
                            "end_time": {
                              "type": "string",
                              "example": "0"
                            }
                          }
                        },
                        "vesting_schedules": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "denom": {
                                "type": "string",
                                "example": "usdr"
                              },
                              "lazy_schedules": {
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "start_time": {
                                      "type": "string",
                                      "example": "1556085600"
                                    },
                                    "end_time": {
                                      "type": "string",
                                      "example": "1556085600"
                                    },
                                    "ratio": {
                                      "type": "string",
                                      "example": "0.100000000000000000"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Server internal error"
          }
        }
      }
    },
    "/staking/delegators/{delegatorAddr}/delegations": {
      "get": {
        "deprecated": true,
        "summary": "Get all delegations from a delegator",
        "tags": [
          "Staking"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "delegation": {
                    "type": "object",
                    "properties": {
                      "delegator_address": {
                        "type": "string"
                      },
                      "validator_address": {
                        "type": "string"
                      },
                      "shares": {
                        "type": "string"
                      }
                    }
                  },
                  "balance": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid delegator address"
          },
          "500": {
            "description": "Internal Server Error"
          }
        },
        "parameters": [
          {
            "in": "path",
            "name": "delegatorAddr",
            "description": "Bech32 AccAddress of Delegator",
            "required": true,
            "type": "string",
            "x-example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
          }
        ]
      },
      "post": {
        "deprecated": true,
        "summary": "Submit delegation",
        "parameters": [
          {
            "in": "path",
            "name": "delegatorAddr",
            "description": "Bech32 AccAddress of Delegator",
            "required": true,
            "type": "string",
            "x-example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
          },
          {
            "in": "body",
            "name": "delegation",
            "description": "Delegate an amount of liquid coins to a validator",
            "schema": {
              "type": "object",
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                },
                "delegator_address": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                },
                "validator_address": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
                },
                "amount": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string",
                      "example": "uluna"
                    },
                    "amount": {
                      "type": "string",
                      "example": "50"
                    }
                  }
                }
              }
            }
          }
        ],
        "tags": [
          "Staking"
        ],
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid delegator address or delegation request body"
          },
          "401": {
            "description": "Key password is wrong"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/staking/delegators/{delegatorAddr}/delegations/{validatorAddr}": {
      "get": {
        "deprecated": true,
        "summary": "Query the current delegation between a delegator and a validator",
        "tags": [
          "Staking"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "delegation": {
                  "type": "object",
                  "properties": {
                    "delegator_address": {
                      "type": "string"
                    },
                    "validator_address": {
                      "type": "string"
                    },
                    "shares": {
                      "type": "string"
                    }
                  }
                },
                "balance": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string",
                      "example": "uluna"
                    },
                    "amount": {
                      "type": "string",
                      "example": "50"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid delegator address or validator address"
          },
          "500": {
            "description": "Internal Server Error"
          }
        },
        "parameters": [
          {
            "in": "path",
            "name": "delegatorAddr",
            "description": "Bech32 AccAddress of Delegator",
            "required": true,
            "type": "string",
            "x-example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
          },
          {
            "in": "path",
            "name": "validatorAddr",
            "description": "Bech32 OperatorAddress of validator",
            "required": true,
            "type": "string",
            "x-example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
          }
        ]
      }
    },
    "/staking/delegators/{delegatorAddr}/unbonding_delegations": {
      "get": {
        "deprecated": true,
        "summary": "Get all unbonding delegations from a delegator",
        "tags": [
          "Staking"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "delegator_address": {
                    "type": "string"
                  },
                  "validator_address": {
                    "type": "string"
                  },
                  "entries": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "initial_balance": {
                          "type": "string"
                        },
                        "balance": {
                          "type": "string"
                        },
                        "creation_height": {
                          "type": "string"
                        },
                        "completion_time": {
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid delegator address"
          },
          "500": {
            "description": "Internal Server Error"
          }
        },
        "parameters": [
          {
            "in": "path",
            "name": "delegatorAddr",
            "description": "Bech32 AccAddress of Delegator",
            "required": true,
            "type": "string",
            "x-example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
          }
        ]
      },
      "post": {
        "deprecated": true,
        "summary": "Submit an unbonding delegation",
        "parameters": [
          {
            "in": "path",
            "name": "delegatorAddr",
            "description": "Bech32 AccAddress of Delegator",
            "required": true,
            "type": "string",
            "x-example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
          },
          {
            "in": "body",
            "name": "delegation",
            "description": "Unbond an amount of bonded shares from a validator",
            "schema": {
              "type": "object",
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                },
                "delegator_address": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                },
                "validator_address": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
                },
                "amount": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string",
                      "example": "uluna"
                    },
                    "amount": {
                      "type": "string",
                      "example": "50"
                    }
                  }
                }
              }
            }
          }
        ],
        "tags": [
          "Staking"
        ],
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid delegator address or unbonding delegation request body"
          },
          "401": {
            "description": "Key password is wrong"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/staking/delegators/{delegatorAddr}/unbonding_delegations/{validatorAddr}": {
      "get": {
        "deprecated": true,
        "summary": "Query all unbonding delegations between a delegator and a validator",
        "tags": [
          "Staking"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "delegator_address": {
                  "type": "string"
                },
                "validator_address": {
                  "type": "string"
                },
                "entries": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "initial_balance": {
                        "type": "string"
                      },
                      "balance": {
                        "type": "string"
                      },
                      "creation_height": {
                        "type": "string"
                      },
                      "completion_time": {
                        "type": "string"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid delegator address or validator address"
          },
          "500": {
            "description": "Internal Server Error"
          }
        },
        "parameters": [
          {
            "in": "path",
            "name": "delegatorAddr",
            "description": "Bech32 AccAddress of Delegator",
            "required": true,
            "type": "string",
            "x-example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
          },
          {
            "in": "path",
            "name": "validatorAddr",
            "description": "Bech32 OperatorAddress of validator",
            "required": true,
            "type": "string",
            "x-example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
          }
        ]
      }
    },
    "/staking/redelegations": {
      "get": {
        "deprecated": true,
        "summary": "Get all redelegations (filter by query params)",
        "tags": [
          "Staking"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "delegator_address": {
                    "type": "string"
                  },
                  "validator_src_address": {
                    "type": "string"
                  },
                  "validator_dst_address": {
                    "type": "string"
                  },
                  "entries": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "creation_height": {
                          "type": "integer"
                        },
                        "completion_time": {
                          "type": "integer"
                        },
                        "initial_balance": {
                          "type": "string"
                        },
                        "balance": {
                          "type": "string"
                        },
                        "shares_dst": {
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error"
          }
        },
        "parameters": [
          {
            "in": "query",
            "name": "delegator",
            "description": "Bech32 AccAddress of Delegator",
            "required": false,
            "type": "string"
          },
          {
            "in": "query",
            "name": "validator_from",
            "description": "Bech32 ValAddress of SrcValidator",
            "required": false,
            "type": "string"
          },
          {
            "in": "query",
            "name": "validator_to",
            "description": "Bech32 ValAddress of DstValidator",
            "required": false,
            "type": "string"
          }
        ]
      }
    },
    "/staking/delegators/{delegatorAddr}/redelegations": {
      "post": {
        "deprecated": true,
        "summary": "Submit a redelegation",
        "parameters": [
          {
            "in": "path",
            "name": "delegatorAddr",
            "description": "Bech32 AccAddress of Delegator",
            "required": true,
            "type": "string",
            "x-example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
          },
          {
            "in": "body",
            "name": "delegation",
            "description": "The sender and tx information",
            "schema": {
              "type": "object",
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                },
                "delegator_address": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                },
                "validator_src_address": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
                },
                "validator_dst_address": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
                },
                "amount": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                }
              }
            }
          }
        ],
        "tags": [
          "Staking"
        ],
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Tx was successfully generated",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid delegator address or redelegation request body"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/staking/delegators/{delegatorAddr}/validators": {
      "get": {
        "deprecated": true,
        "summary": "Query all validators that a delegator is bonded to",
        "tags": [
          "Staking"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "operator_address": {
                    "type": "string",
                    "description": "bech32 encoded address",
                    "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
                  },
                  "consensus_pubkey": {
                    "type": "object",
                    "properties": {
                      "type": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string"
                      }
                    }
                  },
                  "jailed": {
                    "type": "boolean"
                  },
                  "status": {
                    "type": "integer"
                  },
                  "tokens": {
                    "type": "string"
                  },
                  "delegator_shares": {
                    "type": "string"
                  },
                  "description": {
                    "type": "object",
                    "properties": {
                      "moniker": {
                        "type": "string"
                      },
                      "identity": {
                        "type": "string"
                      },
                      "website": {
                        "type": "string"
                      },
                      "security_contact": {
                        "type": "string"
                      },
                      "details": {
                        "type": "string"
                      }
                    }
                  },
                  "bond_height": {
                    "type": "string",
                    "example": "0"
                  },
                  "bond_intra_tx_counter": {
                    "type": "integer",
                    "example": 0
                  },
                  "unbonding_height": {
                    "type": "string",
                    "example": "0"
                  },
                  "unbonding_time": {
                    "type": "string",
                    "example": "1970-01-01T00:00:00Z"
                  },
                  "commission": {
                    "type": "object",
                    "properties": {
                      "rate": {
                        "type": "string",
                        "example": "0"
                      },
                      "max_rate": {
                        "type": "string",
                        "example": "0"
                      },
                      "max_change_rate": {
                        "type": "string",
                        "example": "0"
                      },
                      "update_time": {
                        "type": "string",
                        "example": "1970-01-01T00:00:00Z"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid delegator address"
          },
          "500": {
            "description": "Internal Server Error"
          }
        },
        "parameters": [
          {
            "in": "path",
            "name": "delegatorAddr",
            "description": "Bech32 AccAddress of Delegator",
            "required": true,
            "type": "string",
            "x-example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
          }
        ]
      }
    },
    "/staking/delegators/{delegatorAddr}/validators/{validatorAddr}": {
      "get": {
        "deprecated": true,
        "summary": "Query a validator that a delegator is bonded to",
        "tags": [
          "Staking"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "operator_address": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
                },
                "consensus_pubkey": {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string"
                    },
                    "value": {
                      "type": "string"
                    }
                  }
                },
                "jailed": {
                  "type": "boolean"
                },
                "status": {
                  "type": "integer"
                },
                "tokens": {
                  "type": "string"
                },
                "delegator_shares": {
                  "type": "string"
                },
                "description": {
                  "type": "object",
                  "properties": {
                    "moniker": {
                      "type": "string"
                    },
                    "identity": {
                      "type": "string"
                    },
                    "website": {
                      "type": "string"
                    },
                    "security_contact": {
                      "type": "string"
                    },
                    "details": {
                      "type": "string"
                    }
                  }
                },
                "bond_height": {
                  "type": "string",
                  "example": "0"
                },
                "bond_intra_tx_counter": {
                  "type": "integer",
                  "example": 0
                },
                "unbonding_height": {
                  "type": "string",
                  "example": "0"
                },
                "unbonding_time": {
                  "type": "string",
                  "example": "1970-01-01T00:00:00Z"
                },
                "commission": {
                  "type": "object",
                  "properties": {
                    "rate": {
                      "type": "string",
                      "example": "0"
                    },
                    "max_rate": {
                      "type": "string",
                      "example": "0"
                    },
                    "max_change_rate": {
                      "type": "string",
                      "example": "0"
                    },
                    "update_time": {
                      "type": "string",
                      "example": "1970-01-01T00:00:00Z"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid delegator address or validator address"
          },
          "500": {
            "description": "Internal Server Error"
          }
        },
        "parameters": [
          {
            "in": "path",
            "name": "delegatorAddr",
            "description": "Bech32 AccAddress of Delegator",
            "required": true,
            "type": "string",
            "x-example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
          },
          {
            "in": "path",
            "name": "validatorAddr",
            "description": "Bech32 ValAddress of Delegator",
            "required": true,
            "type": "string",
            "x-example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
          }
        ]
      }
    },
    "/staking/validators": {
      "get": {
        "deprecated": true,
        "summary": "Get all validator candidates. By default it returns only the bonded validators.",
        "parameters": [
          {
            "in": "query",
            "name": "status",
            "type": "string",
            "description": "The validator bond status. Must be either 'bonded', 'unbonded', or 'unbonding'.",
            "x-example": "bonded"
          },
          {
            "in": "query",
            "name": "page",
            "description": "The page number.",
            "type": "integer",
            "x-example": 1
          },
          {
            "in": "query",
            "name": "limit",
            "description": "The maximum number of items per page.",
            "type": "integer",
            "x-example": 1
          }
        ],
        "tags": [
          "Staking"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "operator_address": {
                    "type": "string",
                    "description": "bech32 encoded address",
                    "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
                  },
                  "consensus_pubkey": {
                    "type": "object",
                    "properties": {
                      "type": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string"
                      }
                    }
                  },
                  "jailed": {
                    "type": "boolean"
                  },
                  "status": {
                    "type": "integer"
                  },
                  "tokens": {
                    "type": "string"
                  },
                  "delegator_shares": {
                    "type": "string"
                  },
                  "description": {
                    "type": "object",
                    "properties": {
                      "moniker": {
                        "type": "string"
                      },
                      "identity": {
                        "type": "string"
                      },
                      "website": {
                        "type": "string"
                      },
                      "security_contact": {
                        "type": "string"
                      },
                      "details": {
                        "type": "string"
                      }
                    }
                  },
                  "bond_height": {
                    "type": "string",
                    "example": "0"
                  },
                  "bond_intra_tx_counter": {
                    "type": "integer",
                    "example": 0
                  },
                  "unbonding_height": {
                    "type": "string",
                    "example": "0"
                  },
                  "unbonding_time": {
                    "type": "string",
                    "example": "1970-01-01T00:00:00Z"
                  },
                  "commission": {
                    "type": "object",
                    "properties": {
                      "rate": {
                        "type": "string",
                        "example": "0"
                      },
                      "max_rate": {
                        "type": "string",
                        "example": "0"
                      },
                      "max_change_rate": {
                        "type": "string",
                        "example": "0"
                      },
                      "update_time": {
                        "type": "string",
                        "example": "1970-01-01T00:00:00Z"
                      }
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/staking/validators/{validatorAddr}": {
      "get": {
        "deprecated": true,
        "summary": "Query the information from a single validator",
        "tags": [
          "Staking"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "operator_address": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
                },
                "consensus_pubkey": {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string"
                    },
                    "value": {
                      "type": "string"
                    }
                  }
                },
                "jailed": {
                  "type": "boolean"
                },
                "status": {
                  "type": "integer"
                },
                "tokens": {
                  "type": "string"
                },
                "delegator_shares": {
                  "type": "string"
                },
                "description": {
                  "type": "object",
                  "properties": {
                    "moniker": {
                      "type": "string"
                    },
                    "identity": {
                      "type": "string"
                    },
                    "website": {
                      "type": "string"
                    },
                    "security_contact": {
                      "type": "string"
                    },
                    "details": {
                      "type": "string"
                    }
                  }
                },
                "bond_height": {
                  "type": "string",
                  "example": "0"
                },
                "bond_intra_tx_counter": {
                  "type": "integer",
                  "example": 0
                },
                "unbonding_height": {
                  "type": "string",
                  "example": "0"
                },
                "unbonding_time": {
                  "type": "string",
                  "example": "1970-01-01T00:00:00Z"
                },
                "commission": {
                  "type": "object",
                  "properties": {
                    "rate": {
                      "type": "string",
                      "example": "0"
                    },
                    "max_rate": {
                      "type": "string",
                      "example": "0"
                    },
                    "max_change_rate": {
                      "type": "string",
                      "example": "0"
                    },
                    "update_time": {
                      "type": "string",
                      "example": "1970-01-01T00:00:00Z"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid validator address"
          },
          "500": {
            "description": "Internal Server Error"
          }
        },
        "parameters": [
          {
            "in": "path",
            "name": "validatorAddr",
            "description": "Bech32 OperatorAddress of validator",
            "required": true,
            "type": "string",
            "x-example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
          }
        ]
      }
    },
    "/staking/validators/{validatorAddr}/delegations": {
      "get": {
        "deprecated": true,
        "summary": "Get all delegations from a validator",
        "tags": [
          "Staking"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "delegation": {
                    "type": "object",
                    "properties": {
                      "delegator_address": {
                        "type": "string"
                      },
                      "validator_address": {
                        "type": "string"
                      },
                      "shares": {
                        "type": "string"
                      }
                    }
                  },
                  "balance": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid validator address"
          },
          "500": {
            "description": "Internal Server Error"
          }
        },
        "parameters": [
          {
            "in": "path",
            "name": "validatorAddr",
            "description": "Bech32 OperatorAddress of validator",
            "required": true,
            "type": "string",
            "x-example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
          }
        ]
      }
    },
    "/staking/validators/{validatorAddr}/unbonding_delegations": {
      "get": {
        "deprecated": true,
        "summary": "Get all unbonding delegations from a validator",
        "tags": [
          "Staking"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "delegator_address": {
                    "type": "string"
                  },
                  "validator_address": {
                    "type": "string"
                  },
                  "entries": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "initial_balance": {
                          "type": "string"
                        },
                        "balance": {
                          "type": "string"
                        },
                        "creation_height": {
                          "type": "string"
                        },
                        "completion_time": {
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid validator address"
          },
          "500": {
            "description": "Internal Server Error"
          }
        },
        "parameters": [
          {
            "in": "path",
            "name": "validatorAddr",
            "description": "Bech32 OperatorAddress of validator",
            "required": true,
            "type": "string",
            "x-example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
          }
        ]
      }
    },
    "/staking/pool": {
      "get": {
        "deprecated": true,
        "summary": "Get the current state of the staking pool",
        "tags": [
          "Staking"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "bonded_tokens": {
                  "type": "string"
                },
                "not_bonded_tokens": {
                  "type": "string"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/staking/parameters": {
      "get": {
        "deprecated": true,
        "summary": "Get the current staking parameter values",
        "tags": [
          "Staking"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "unbonding_time": {
                  "type": "string"
                },
                "max_validators": {
                  "type": "integer"
                },
                "max_entries": {
                  "type": "integer"
                },
                "historical_entries": {
                  "type": "integer"
                },
                "bond_denom": {
                  "type": "string"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/slashing/signing_infos": {
      "get": {
        "deprecated": true,
        "summary": "Get sign info of given all validators",
        "description": "Get sign info of all validators",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Slashing"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "page",
            "description": "Page number",
            "type": "integer",
            "required": true,
            "x-example": 1
          },
          {
            "in": "query",
            "name": "limit",
            "description": "Maximum number of items per page",
            "type": "integer",
            "required": true,
            "x-example": 5
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "address": {
                    "type": "string",
                    "example": "terravalcons1qsdpq864szmfk8nh82qcg7lyle6k95w07acdqn"
                  },
                  "start_height": {
                    "type": "string"
                  },
                  "index_offset": {
                    "type": "string"
                  },
                  "jailed_until": {
                    "type": "string"
                  },
                  "missed_blocks_counter": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid validator public key for one of the validators"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/slashing/validators/{validatorAddr}/unjail": {
      "post": {
        "deprecated": true,
        "summary": "Unjail a jailed validator",
        "description": "Send transaction to unjail a jailed validator",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Slashing"
        ],
        "parameters": [
          {
            "type": "string",
            "description": "Bech32 validator address",
            "name": "validatorAddr",
            "required": true,
            "in": "path",
            "x-example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
          },
          {
            "description": "",
            "name": "UnjailBody",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "msg": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "fee": {
                      "type": "object",
                      "properties": {
                        "gas": {
                          "type": "string"
                        },
                        "amount": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "denom": {
                                "type": "string",
                                "example": "uluna"
                              },
                              "amount": {
                                "type": "string",
                                "example": "50"
                              }
                            }
                          }
                        }
                      }
                    },
                    "memo": {
                      "type": "string"
                    },
                    "signature": {
                      "type": "object",
                      "properties": {
                        "signature": {
                          "type": "string",
                          "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                        },
                        "pub_key": {
                          "type": "object",
                          "properties": {
                            "type": {
                              "type": "string",
                              "example": "tendermint/PubKeySecp256k1"
                            },
                            "value": {
                              "type": "string",
                              "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                            }
                          }
                        },
                        "account_number": {
                          "type": "string",
                          "example": "0"
                        },
                        "sequence": {
                          "type": "string",
                          "example": "0"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Tx was successfully generated",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid validator address or base_req"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/slashing/parameters": {
      "get": {
        "deprecated": true,
        "summary": "Get the current slashing parameters",
        "tags": [
          "Slashing"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "signed_blocks_window": {
                  "type": "string"
                },
                "min_signed_per_window": {
                  "type": "string"
                },
                "downtime_jail_duration": {
                  "type": "string"
                },
                "slash_fraction_double_sign": {
                  "type": "string"
                },
                "slash_fraction_downtime": {
                  "type": "string"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/gov/proposals": {
      "post": {
        "deprecated": true,
        "summary": "Submit a proposal",
        "description": "Send transaction to submit a proposal",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "description": "valid value of `\"proposal_type\"` can be `\"text\"`, `\"parameter_change\"`, `\"software_upgrade\"`",
            "name": "post_proposal_body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                },
                "title": {
                  "type": "string"
                },
                "description": {
                  "type": "string"
                },
                "proposal_type": {
                  "type": "string",
                  "example": "text"
                },
                "proposer": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                },
                "initial_deposit": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Tx was successfully generated",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid proposal body"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      },
      "get": {
        "deprecated": true,
        "summary": "Query proposals",
        "description": "Query proposals information with parameters",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "voter",
            "description": "voter address",
            "required": false,
            "type": "string"
          },
          {
            "in": "query",
            "name": "depositor",
            "description": "depositor address",
            "required": false,
            "type": "string"
          },
          {
            "in": "query",
            "name": "status",
            "description": "proposal status, valid values can be `\"deposit_period\"`, `\"voting_period\"`, `\"passed\"`, `\"rejected\"`",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "id": {
                    "type": "string",
                    "example": "1"
                  },
                  "content": {
                    "type": "object",
                    "properties": {
                      "type": {
                        "type": "string",
                        "example": "gov/TextProposal"
                      },
                      "value": {
                        "type": "object",
                        "properties": {
                          "title": {
                            "type": "string"
                          },
                          "description": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "status": {
                    "type": "number"
                  },
                  "final_tally_result": {
                    "type": "object",
                    "properties": {
                      "yes": {
                        "type": "string",
                        "example": "0.0000000000"
                      },
                      "abstain": {
                        "type": "string",
                        "example": "0.0000000000"
                      },
                      "no": {
                        "type": "string",
                        "example": "0.0000000000"
                      },
                      "no_with_veto": {
                        "type": "string",
                        "example": "0.0000000000"
                      }
                    }
                  },
                  "total_deposit": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "denom": {
                          "type": "string",
                          "example": "uluna"
                        },
                        "amount": {
                          "type": "string",
                          "example": "50"
                        }
                      }
                    }
                  },
                  "submit_time": {
                    "type": "string"
                  },
                  "deposit_end_time": {
                    "type": "string"
                  },
                  "voting_start_time": {
                    "type": "string"
                  },
                  "voting_end_time": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid query parameters"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/gov/proposals/param_change": {
      "post": {
        "deprecated": true,
        "summary": "Generate a parameter change proposal transaction",
        "description": "Generate a parameter change proposal transaction",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "description": "The parameter change proposal body that contains all parameter changes",
            "name": "post_proposal_body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                },
                "title": {
                  "type": "string",
                  "x-example": "Param Change"
                },
                "description": {
                  "type": "string",
                  "x-example": "Update max validators"
                },
                "proposer": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                },
                "deposit": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                },
                "changes": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "subspace": {
                        "type": "string",
                        "example": "staking"
                      },
                      "key": {
                        "type": "string",
                        "example": "MaxValidators"
                      },
                      "subkey": {
                        "type": "string",
                        "example": ""
                      },
                      "value": {
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The transaction was successfully generated",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid proposal body"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/gov/proposals/{proposalId}": {
      "get": {
        "deprecated": true,
        "summary": "Query a proposal",
        "description": "Query a proposal by id",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "type": "string",
            "name": "proposalId",
            "required": true,
            "in": "path",
            "x-example": "2"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "example": "1"
                },
                "content": {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "example": "gov/TextProposal"
                    },
                    "value": {
                      "type": "object",
                      "properties": {
                        "title": {
                          "type": "string"
                        },
                        "description": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "status": {
                  "type": "number"
                },
                "final_tally_result": {
                  "type": "object",
                  "properties": {
                    "yes": {
                      "type": "string",
                      "example": "0.0000000000"
                    },
                    "abstain": {
                      "type": "string",
                      "example": "0.0000000000"
                    },
                    "no": {
                      "type": "string",
                      "example": "0.0000000000"
                    },
                    "no_with_veto": {
                      "type": "string",
                      "example": "0.0000000000"
                    }
                  }
                },
                "total_deposit": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                },
                "submit_time": {
                  "type": "string"
                },
                "deposit_end_time": {
                  "type": "string"
                },
                "voting_start_time": {
                  "type": "string"
                },
                "voting_end_time": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Invalid proposal id"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/gov/proposals/{proposalId}/proposer": {
      "get": {
        "deprecated": true,
        "summary": "Query proposer",
        "description": "Query for the proposer for a proposal",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "type": "string",
            "name": "proposalId",
            "required": true,
            "in": "path",
            "x-example": "2"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "proposal_id": {
                  "type": "string"
                },
                "proposer": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Invalid proposal ID"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/gov/proposals/{proposalId}/deposits": {
      "get": {
        "deprecated": true,
        "summary": "Query deposits",
        "description": "Query deposits by proposalId",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "type": "string",
            "name": "proposalId",
            "required": true,
            "in": "path",
            "x-example": "2"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "amount": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "denom": {
                          "type": "string",
                          "example": "uluna"
                        },
                        "amount": {
                          "type": "string",
                          "example": "50"
                        }
                      }
                    }
                  },
                  "proposal_id": {
                    "type": "string"
                  },
                  "depositor": {
                    "type": "string",
                    "description": "bech32 encoded address",
                    "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid proposal id"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      },
      "post": {
        "deprecated": true,
        "summary": "Deposit tokens to a proposal",
        "description": "Send transaction to deposit tokens to a proposal",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "type": "string",
            "description": "proposal id",
            "name": "proposalId",
            "required": true,
            "in": "path",
            "x-example": "2"
          },
          {
            "description": "",
            "name": "post_deposit_body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                },
                "depositor": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                },
                "amount": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid proposal id or deposit body"
          },
          "401": {
            "description": "Key password is wrong"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/gov/proposals/{proposalId}/deposits/{depositor}": {
      "get": {
        "deprecated": true,
        "summary": "Query deposit",
        "description": "Query deposit by proposalId and depositor address",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "type": "string",
            "description": "proposal id",
            "name": "proposalId",
            "required": true,
            "in": "path",
            "x-example": "2"
          },
          {
            "type": "string",
            "description": "Bech32 depositor address",
            "name": "depositor",
            "required": true,
            "in": "path",
            "x-example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "amount": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                },
                "proposal_id": {
                  "type": "string"
                },
                "depositor": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                }
              }
            }
          },
          "400": {
            "description": "Invalid proposal id or depositor address"
          },
          "404": {
            "description": "Found no deposit"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/gov/proposals/{proposalId}/votes": {
      "get": {
        "deprecated": true,
        "summary": "Query voters",
        "description": "Query voters information by proposalId",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "type": "string",
            "description": "proposal id",
            "name": "proposalId",
            "required": true,
            "in": "path",
            "x-example": "2"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "voter": {
                    "type": "string"
                  },
                  "proposal_id": {
                    "type": "string"
                  },
                  "options": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "option": {
                          "type": "string",
                          "enum": [
                            "VOTE_OPTION_UNSPECIFIED",
                            "VOTE_OPTION_YES",
                            "VOTE_OPTION_ABSTAIN",
                            "VOTE_OPTION_NO",
                            "VOTE_OPTION_NO_WITH_VETO"
                          ],
                          "default": "VOTE_OPTION_UNSPECIFIED",
                          "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n- VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option. - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option. - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option. - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option. - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."
                        },
                        "weight": {
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid proposal id"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      },
      "post": {
        "deprecated": true,
        "summary": "Vote a proposal",
        "description": "Send transaction to vote a proposal",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "type": "string",
            "description": "proposal id",
            "name": "proposalId",
            "required": true,
            "in": "path",
            "x-example": "2"
          },
          {
            "description": "valid value of `\"option\"` field can be `\"yes\"`, `\"no\"`, `\"no_with_veto\"` and `\"abstain\"`",
            "name": "post_vote_body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                },
                "voter": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                },
                "option": {
                  "type": "string",
                  "example": "yes"
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid proposal id or vote body"
          },
          "401": {
            "description": "Key password is wrong"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/gov/proposals/{proposalId}/votes/{voter}": {
      "get": {
        "deprecated": true,
        "summary": "Query vote",
        "description": "Query vote information by proposal Id and voter address",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "type": "string",
            "description": "proposal id",
            "name": "proposalId",
            "required": true,
            "in": "path",
            "x-example": "2"
          },
          {
            "type": "string",
            "description": "Bech32 voter address",
            "name": "voter",
            "required": true,
            "in": "path",
            "x-example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "voter": {
                  "type": "string"
                },
                "proposal_id": {
                  "type": "string"
                },
                "options": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "option": {
                        "type": "string",
                        "enum": [
                          "VOTE_OPTION_UNSPECIFIED",
                          "VOTE_OPTION_YES",
                          "VOTE_OPTION_ABSTAIN",
                          "VOTE_OPTION_NO",
                          "VOTE_OPTION_NO_WITH_VETO"
                        ],
                        "default": "VOTE_OPTION_UNSPECIFIED",
                        "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n- VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option. - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option. - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option. - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option. - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."
                      },
                      "weight": {
                        "type": "string"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid proposal id or voter address"
          },
          "404": {
            "description": "Found no vote"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/gov/proposals/{proposalId}/tally": {
      "get": {
        "deprecated": true,
        "summary": "Get a proposal's tally result at the current time",
        "description": "Gets a proposal's tally result at the current time. If the proposal is pending deposits (i.e status 'DepositPeriod') it returns an empty tally result.",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "type": "string",
            "description": "proposal id",
            "name": "proposalId",
            "required": true,
            "in": "path",
            "x-example": "2"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "yes": {
                  "type": "string",
                  "example": "0.0000000000"
                },
                "abstain": {
                  "type": "string",
                  "example": "0.0000000000"
                },
                "no": {
                  "type": "string",
                  "example": "0.0000000000"
                },
                "no_with_veto": {
                  "type": "string",
                  "example": "0.0000000000"
                }
              }
            }
          },
          "400": {
            "description": "Invalid proposal id"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/gov/parameters/deposit": {
      "get": {
        "deprecated": true,
        "summary": "Query governance deposit parameters",
        "description": "Query governance deposit parameters. The max_deposit_period units are in nanoseconds.",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Governance"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "min_deposit": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                },
                "max_deposit_period": {
                  "type": "string",
                  "example": "86400000000000"
                }
              }
            }
          },
          "400": {
            "description": "<other_path> is not a valid query request path"
          },
          "404": {
            "description": "Found no deposit parameters"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/gov/parameters/tallying": {
      "get": {
        "deprecated": true,
        "summary": "Query governance tally parameters",
        "description": "Query governance tally parameters",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Governance"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "properties": {
                "threshold": {
                  "type": "string",
                  "example": "0.5000000000"
                },
                "quorum": {
                  "type": "string",
                  "example": "0.3340000000"
                },
                "veto_threshold": {
                  "type": "string",
                  "example": "0.3340000000"
                }
              }
            }
          },
          "400": {
            "description": "<other_path> is not a valid query request path"
          },
          "404": {
            "description": "Found no tally parameters"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/gov/parameters/voting": {
      "get": {
        "deprecated": true,
        "summary": "Query governance voting parameters",
        "description": "Query governance voting parameters. The voting_period units are in nanoseconds.",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Governance"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "properties": {
                "voting_period": {
                  "type": "string",
                  "example": "86400000000000"
                }
              }
            }
          },
          "400": {
            "description": "<other_path> is not a valid query request path"
          },
          "404": {
            "description": "Found no voting parameters"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/distribution/delegators/{delegatorAddr}/rewards": {
      "get": {
        "deprecated": true,
        "summary": "Get the total rewards balance from all delegations",
        "description": "Get the sum of all the rewards earned by delegations by a single delegator",
        "produces": [
          "application/json"
        ],
        "tags": [
          "Distribution"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "rewards": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "validator_address": {
                        "type": "string",
                        "description": "bech32 encoded address",
                        "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
                      },
                      "reward": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "denom": {
                              "type": "string",
                              "example": "uluna"
                            },
                            "amount": {
                              "type": "string",
                              "example": "50"
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "total": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid delegator address"
          },
          "500": {
            "description": "Internal Server Error"
          }
        },
        "parameters": [
          {
            "in": "path",
            "name": "delegatorAddr",
            "description": "Bech32 AccAddress of Delegator",
            "required": true,
            "type": "string",
            "x-example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
          }
        ]
      },
      "post": {
        "deprecated": true,
        "summary": "Withdraw all the delegator's delegation rewards",
        "description": "Withdraw all the delegator's delegation rewards",
        "tags": [
          "Distribution"
        ],
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "delegatorAddr",
            "description": "Bech32 AccAddress of Delegator",
            "required": true,
            "type": "string",
            "x-example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
          },
          {
            "in": "body",
            "name": "Withdraw request body",
            "schema": {
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid delegator address"
          },
          "401": {
            "description": "Key password is wrong"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/distribution/delegators/{delegatorAddr}/rewards/{validatorAddr}": {
      "get": {
        "deprecated": true,
        "summary": "Query a delegation reward",
        "description": "Query a single delegation reward by a delegator",
        "tags": [
          "Distribution"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid delegator address"
          },
          "500": {
            "description": "Internal Server Error"
          }
        },
        "parameters": [
          {
            "in": "path",
            "name": "delegatorAddr",
            "description": "Bech32 AccAddress of Delegator",
            "required": true,
            "type": "string",
            "x-example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
          },
          {
            "in": "path",
            "name": "validatorAddr",
            "description": "Bech32 OperatorAddress of validator",
            "required": true,
            "type": "string",
            "x-example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
          }
        ]
      },
      "post": {
        "deprecated": true,
        "summary": "Withdraw a delegation reward",
        "description": "Withdraw a delegator's delegation reward from a single validator",
        "tags": [
          "Distribution"
        ],
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "delegatorAddr",
            "description": "Bech32 AccAddress of Delegator",
            "required": true,
            "type": "string",
            "x-example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
          },
          {
            "in": "path",
            "name": "validatorAddr",
            "description": "Bech32 OperatorAddress of validator",
            "required": true,
            "type": "string",
            "x-example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
          },
          {
            "in": "body",
            "name": "Withdraw request body",
            "schema": {
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid delegator address or delegation body"
          },
          "401": {
            "description": "Key password is wrong"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/distribution/delegators/{delegatorAddr}/withdraw_address": {
      "get": {
        "deprecated": true,
        "summary": "Get the rewards withdrawal address",
        "description": "Get the delegations' rewards withdrawal address. This is the address in which the user will receive the reward funds",
        "tags": [
          "Distribution"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "string",
              "description": "bech32 encoded address",
              "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
            }
          },
          "400": {
            "description": "Invalid delegator address"
          },
          "500": {
            "description": "Internal Server Error"
          }
        },
        "parameters": [
          {
            "in": "path",
            "name": "delegatorAddr",
            "description": "Bech32 AccAddress of Delegator",
            "required": true,
            "type": "string",
            "x-example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
          }
        ]
      },
      "post": {
        "deprecated": true,
        "summary": "Replace the rewards withdrawal address",
        "description": "Replace the delegations' rewards withdrawal address for a new one.",
        "tags": [
          "Distribution"
        ],
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "delegatorAddr",
            "description": "Bech32 AccAddress of Delegator",
            "required": true,
            "type": "string",
            "x-example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
          },
          {
            "in": "body",
            "name": "Withdraw request body",
            "schema": {
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                },
                "withdraw_address": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid delegator or withdraw address"
          },
          "401": {
            "description": "Key password is wrong"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/distribution/validators/{validatorAddr}": {
      "get": {
        "deprecated": true,
        "summary": "Validator distribution information",
        "description": "Query the distribution information of a single validator",
        "tags": [
          "Distribution"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "operator_address": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
                },
                "self_bond_rewards": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                },
                "val_commission": {
                  "type": "object",
                  "properties": {
                    "commission": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid validator address"
          },
          "500": {
            "description": "Internal Server Error"
          }
        },
        "parameters": [
          {
            "in": "path",
            "name": "validatorAddr",
            "description": "Bech32 OperatorAddress of validator",
            "required": true,
            "type": "string",
            "x-example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
          }
        ]
      }
    },
    "/distribution/validators/{validatorAddr}/outstanding_rewards": {
      "get": {
        "deprecated": true,
        "summary": "Fee distribution outstanding rewards of a single validator",
        "tags": [
          "Distribution"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "rewards": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error"
          }
        },
        "parameters": [
          {
            "in": "path",
            "name": "validatorAddr",
            "description": "Bech32 OperatorAddress of validator",
            "required": true,
            "type": "string",
            "x-example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
          }
        ]
      }
    },
    "/distribution/validators/{validatorAddr}/rewards": {
      "get": {
        "deprecated": true,
        "summary": "Commission and self-delegation rewards of a single validator",
        "description": "Query the commission and self-delegation rewards of validator.",
        "tags": [
          "Distribution"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid validator address"
          },
          "500": {
            "description": "Internal Server Error"
          }
        },
        "parameters": [
          {
            "in": "path",
            "name": "validatorAddr",
            "description": "Bech32 OperatorAddress of validator",
            "required": true,
            "type": "string",
            "x-example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
          }
        ]
      },
      "post": {
        "deprecated": true,
        "summary": "Withdraw the validator's rewards",
        "description": "Withdraw the validator's self-delegation and commissions rewards",
        "tags": [
          "Distribution"
        ],
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "validatorAddr",
            "description": "Bech32 OperatorAddress of validator",
            "required": true,
            "type": "string",
            "x-example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
          },
          {
            "in": "body",
            "name": "Withdraw request body",
            "schema": {
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid validator address"
          },
          "401": {
            "description": "Key password is wrong"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/distribution/community_pool": {
      "get": {
        "deprecated": true,
        "summary": "Community pool parameters",
        "tags": [
          "Distribution"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/distribution/parameters": {
      "get": {
        "deprecated": true,
        "summary": "Fee distribution parameters",
        "tags": [
          "Distribution"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "properties": {
                "base_proposer_reward": {
                  "type": "string"
                },
                "bonus_proposer_reward": {
                  "type": "string"
                },
                "community_tax": {
                  "type": "string"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/minting/parameters": {
      "get": {
        "deprecated": true,
        "summary": "Minting module parameters",
        "tags": [
          "Mint"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "properties": {
                "mint_denom": {
                  "type": "string"
                },
                "inflation_rate_change": {
                  "type": "string"
                },
                "inflation_max": {
                  "type": "string"
                },
                "inflation_min": {
                  "type": "string"
                },
                "goal_bonded": {
                  "type": "string"
                },
                "blocks_per_year": {
                  "type": "string"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/minting/inflation": {
      "get": {
        "deprecated": true,
        "summary": "Current minting inflation value",
        "tags": [
          "Mint"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "string"
            }
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/minting/annual-provisions": {
      "get": {
        "deprecated": true,
        "summary": "Current minting annual provisions value",
        "tags": [
          "Mint"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "string"
            }
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/market/swap": {
      "post": {
        "deprecated": true,
        "summary": "Swap coin with another coin",
        "tags": [
          "Market"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "Swap coin request body",
            "schema": {
              "type": "object",
              "required": [
                "base_req",
                "offer_coin",
                "ask_denom"
              ],
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                },
                "offer_coin": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string",
                      "example": "uluna"
                    },
                    "amount": {
                      "type": "string",
                      "example": "50"
                    }
                  }
                },
                "ask_denom": {
                  "type": "string",
                  "example": "uluna"
                },
                "receiver": {
                  "type": "string",
                  "description": "the `receiver` field can be skipped when the receiver is trader",
                  "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      },
      "get": {
        "deprecated": true,
        "summary": "Query swap result amount",
        "tags": [
          "Market"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "offer_coin",
            "description": "coin expression want to swap",
            "type": "string",
            "required": true,
            "x-example": "1000000uluna"
          },
          {
            "in": "query",
            "name": "ask_denom",
            "description": "Then coin denom want to ask",
            "type": "string",
            "required": true,
            "x-example": "usdr"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string",
                  "example": "uluna"
                },
                "amount": {
                  "type": "string",
                  "example": "50"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/market/terra_pool_delta": {
      "get": {
        "deprecated": true,
        "summary": "Get terra pool delta, is usdr amount used for swap operation from the TerraPool.",
        "tags": [
          "Market"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "number",
              "format": "float",
              "example": "10000000.00"
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/market/parameters": {
      "get": {
        "deprecated": true,
        "summary": "Get market params",
        "tags": [
          "Market"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "base_pool": {
                  "type": "number",
                  "example": "1000000.0"
                },
                "pool_recovery_period": {
                  "type": "number",
                  "example": "16000"
                },
                "min_stability_spread": {
                  "type": "number",
                  "example": "0.02"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/oracle/denoms/{denom}/exchange_rate": {
      "get": {
        "deprecated": true,
        "summary": "Get the current effective exchange rate in Luna for the asset",
        "tags": [
          "Oracle"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "denom",
            "description": "The coin denom to get",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "current exchange rate of denom i.e. \"1000.0\"",
            "schema": {
              "type": "number",
              "example": "1872.000000000000000000"
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/oracle/denoms/exchange_rates": {
      "get": {
        "deprecated": true,
        "summary": "Get all activated exchange rates",
        "tags": [
          "Oracle"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "ukrw"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50.000"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/oracle/denoms/actives": {
      "get": {
        "deprecated": true,
        "summary": "Get all activated denoms",
        "tags": [
          "Oracle"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "example": [
                "ukrw",
                "usdr"
              ]
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/oracle/voters/{validator}/feeder": {
      "post": {
        "deprecated": true,
        "summary": "Generate oracle feeder right delegation message",
        "tags": [
          "Oracle"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "validator",
            "description": "Feeder right delegator",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "feeder right delegation request body",
            "schema": {
              "type": "object",
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                },
                "feeder": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      },
      "get": {
        "deprecated": true,
        "summary": "Get delegated oracle feeder of a validator",
        "tags": [
          "Oracle"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "validator",
            "description": "Feeder right delegator",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "string",
              "description": "bech32 encoded address",
              "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/oracle/voters/{validator}/miss": {
      "get": {
        "deprecated": true,
        "summary": "Get the number of vote periods missed in this oracle slash window.",
        "tags": [
          "Oracle"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "validator",
            "description": "oracle operator",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "number",
              "format": "integer",
              "example": "100"
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/oracle/voters/{validator}/aggregate_prevote": {
      "post": {
        "deprecated": true,
        "summary": "Generate oracle aggregate exchange rate prevote message containing a hash",
        "tags": [
          "Oracle"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "validator",
            "description": "oracle operator",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "Aggregate Prevote request body",
            "schema": {
              "type": "object",
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                },
                "exchange_rates": {
                  "type": "string",
                  "example": "1000.0ukrw,1.2uusd,0.99usdr",
                  "description": "exchange rates of Luna in denom currencies are to make aggregate prevote hash; this field is required to submit prevote in case absence of hash"
                },
                "salt": {
                  "type": "string",
                  "example": "abcd",
                  "description": "salt is to make prevote hash; this field is required to submit prevote in case  absence of hash"
                },
                "hash": {
                  "type": "string",
                  "example": "061bf1e27dfff121f40c826e593c8a28ec299a02",
                  "description": "hex string; hash of next vote; empty == skip prevote"
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      },
      "get": {
        "deprecated": true,
        "summary": "Get the currently outstanding aggregate exchange rate oracle prevote of a validator",
        "tags": [
          "Oracle"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "validator",
            "description": "oracle operator",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "example": "061bf1e27dfff121f40c826e593c8a28ec299a02"
                },
                "voter": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
                },
                "submit_block": {
                  "type": "number",
                  "example": "1"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/oracle/voters/{validator}/aggregate_vote": {
      "post": {
        "deprecated": true,
        "summary": "Generate oracle aggregate exchange rate vote message containing exchange rates and salt to prove the aggregate prevote",
        "tags": [
          "Oracle"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "validator",
            "description": "oracle operator",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "Aggregate Vote request body",
            "schema": {
              "type": "object",
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                },
                "exchange_rates": {
                  "type": "string",
                  "example": "1000.0ukrw,1.2uusd,0.99usdr",
                  "description": "proof exchange rates of Luna in denom currency were used to make aggregate prevote hash"
                },
                "salt": {
                  "type": "string",
                  "example": "abcd",
                  "description": "proof salt was used to make prevote hash; initial prevote does not require this field"
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      },
      "get": {
        "deprecated": true,
        "summary": "Get the currently outstanding aggregate exchange rate oracle vote of a validator",
        "tags": [
          "Oracle"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "validator",
            "description": "oracle operator",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "exchange_rates": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "ukrw"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50.000"
                      }
                    }
                  }
                },
                "voter": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/oracle/parameters": {
      "get": {
        "deprecated": true,
        "summary": "Get oracle params",
        "tags": [
          "Oracle"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "vote_period": {
                  "type": "number",
                  "example": "900"
                },
                "vote_threshold": {
                  "type": "number",
                  "example": "0.67"
                },
                "drop_threshold": {
                  "type": "number",
                  "example": "10"
                },
                "oracle_reward_band": {
                  "type": "number",
                  "example": "0.02"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/treasury/tax_rate": {
      "get": {
        "deprecated": true,
        "summary": "Get current tax rate",
        "tags": [
          "Treasury"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "number",
              "format": "float",
              "example": "0.05"
            }
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/treasury/tax_cap/{denom}": {
      "get": {
        "deprecated": true,
        "summary": "Get tax cap of the denom",
        "tags": [
          "Treasury"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "denom",
            "description": "Denom",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "integer",
              "example": "100000"
            }
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/treasury/tax_caps": {
      "get": {
        "deprecated": true,
        "summary": "Get tax caps for the all whitelisted denoms",
        "tags": [
          "Treasury"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "tax_cap": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            }
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/treasury/reward_weight": {
      "get": {
        "deprecated": true,
        "summary": "Get current reward weight",
        "tags": [
          "Treasury"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "number",
              "format": "float",
              "example": "0.05",
              "description": "5%"
            }
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/treasury/tax_proceeds": {
      "get": {
        "deprecated": true,
        "summary": "Get current tax proceeds",
        "tags": [
          "Treasury"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/treasury/seigniorage_proceeds": {
      "get": {
        "deprecated": true,
        "summary": "retrieves the size of the seigniorage pool",
        "tags": [
          "Treasury"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "integer",
              "example": "0"
            }
          },
          "500": {
            "description": "Internal Server"
          }
        }
      }
    },
    "/treasury/parameters": {
      "get": {
        "deprecated": true,
        "summary": "Get treasury module params",
        "tags": [
          "Treasury"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "tax_policy": {
                  "type": "object",
                  "properties": {
                    "rate_min": {
                      "type": "number",
                      "format": "float",
                      "example": "0.0005",
                      "description": "0.05%"
                    },
                    "rate_max": {
                      "type": "number",
                      "format": "float",
                      "example": "0.01",
                      "description": "1%"
                    },
                    "cap": {
                      "type": "object",
                      "properties": {
                        "denom": {
                          "type": "string",
                          "example": "uluna"
                        },
                        "amount": {
                          "type": "string",
                          "example": "50"
                        }
                      }
                    },
                    "change_max": {
                      "type": "number",
                      "format": "float",
                      "example": "0.00025",
                      "description": "0.025%"
                    }
                  }
                },
                "reward_policy": {
                  "type": "object",
                  "properties": {
                    "rate_min": {
                      "type": "number",
                      "format": "float",
                      "example": "0.0005",
                      "description": "0.05%"
                    },
                    "rate_max": {
                      "type": "number",
                      "format": "float",
                      "example": "0.01",
                      "description": "1%"
                    },
                    "cap": {
                      "type": "object",
                      "properties": {
                        "denom": {
                          "type": "string",
                          "example": "uluna"
                        },
                        "amount": {
                          "type": "string",
                          "example": "50"
                        }
                      }
                    },
                    "change_max": {
                      "type": "number",
                      "format": "float",
                      "example": "0.00025",
                      "description": "0.025%"
                    }
                  }
                },
                "seigniorage_burden_target": {
                  "type": "number",
                  "format": "float",
                  "example": "0.67",
                  "description": "67%"
                },
                "mining_increment": {
                  "type": "number",
                  "format": "float",
                  "example": "1.07"
                },
                "window_short": {
                  "type": "integer",
                  "example": "4"
                },
                "window_long": {
                  "type": "integer",
                  "example": "52"
                },
                "window_probation": {
                  "type": "integer",
                  "example": "12"
                }
              }
            }
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/treasury/indicators": {
      "get": {
        "deprecated": true,
        "summary": "Get the current treasury indicators",
        "tags": [
          "Treasury"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Ok",
            "schema": {
              "properties": {
                "trl_year": {
                  "type": "string",
                  "description": "Tax Rewards per staked Luna over a year of rolling average",
                  "example": "0.000407428004800011"
                },
                "trl_month": {
                  "type": "string",
                  "description": "Tax Rewards per staked Luna over a month of rolling average",
                  "example": "0.000366833881714302"
                }
              }
            }
          }
        }
      }
    },
    "/wasm/codes": {
      "post": {
        "deprecated": true,
        "summary": "Generate wasm store code message",
        "tags": [
          "Wasm"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "store code request body",
            "schema": {
              "type": "object",
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                },
                "wasm_bytes": {
                  "type": "string",
                  "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/wasm/codes/{codeID}": {
      "post": {
        "deprecated": true,
        "summary": "Instantiate wasm contract",
        "tags": [
          "Wasm"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "codeID",
            "description": "code ID you want to instantiate",
            "required": true,
            "type": "number"
          },
          {
            "in": "body",
            "name": "instantiate contract request body",
            "schema": {
              "type": "object",
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                },
                "init_coins": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                },
                "init_msg": {
                  "type": "string",
                  "description": "json formatted string",
                  "example": "{}"
                },
                "admin": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      },
      "get": {
        "deprecated": true,
        "summary": "Get code info of the code ID",
        "tags": [
          "Wasm"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "codeID",
            "description": "code ID you want to instantiate",
            "required": true,
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "code_hash": {
                  "type": "string"
                },
                "creator": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/wasm/codes/{codeID}/migrate": {
      "post": {
        "deprecated": true,
        "summary": "Migrate old wasm code to new wasm code",
        "tags": [
          "Wasm"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "codeID",
            "description": "code ID you want to migrate",
            "required": true,
            "type": "number"
          },
          {
            "in": "body",
            "name": "migrate contract request body",
            "schema": {
              "type": "object",
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                },
                "wasm_bytes": {
                  "type": "string",
                  "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/wasm/contracts/{contractAddress}": {
      "post": {
        "deprecated": true,
        "summary": "Execute wasm contract message",
        "tags": [
          "Wasm"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "contractAddress",
            "description": "contract address you want to execute",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "execute contract request body",
            "schema": {
              "type": "object",
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                },
                "coins": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                },
                "exec_msg": {
                  "type": "string",
                  "example": "{}"
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      },
      "get": {
        "deprecated": true,
        "summary": "Get contract info of the contract Address",
        "tags": [
          "Wasm"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "contractAddress",
            "description": "contract address you want to execute",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "code_id": {
                  "type": "string"
                },
                "address": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                },
                "creator": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                },
                "admin": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                },
                "init_msg": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/wasm/contracts/{contractAddress}/migrate": {
      "post": {
        "deprecated": true,
        "summary": "Migrate wasm contract to new code base",
        "tags": [
          "Wasm"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "contractAddress",
            "description": "contract address you want to migrate",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "migrate contract request body",
            "schema": {
              "type": "object",
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                },
                "new_code_id": {
                  "type": "number",
                  "format": "integer",
                  "example": 10
                },
                "migrate_msg": {
                  "type": "string",
                  "example": "{}"
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/wasm/contracts/{contractAddress}/admin/update": {
      "post": {
        "deprecated": true,
        "summary": "Update wasm contract admin to new address",
        "tags": [
          "Wasm"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "contractAddress",
            "description": "contract address you want to update admin",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "update contract admin request body",
            "schema": {
              "type": "object",
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                },
                "new_admin": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/wasm/contracts/{contractAddress}/admin/clear": {
      "post": {
        "deprecated": true,
        "summary": "Clear wasm contract admin to make the contract un-migratable",
        "tags": [
          "Wasm"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "contractAddress",
            "description": "contract address you want to clear admin",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "clear contract admin request body",
            "schema": {
              "type": "object",
              "properties": {
                "base_req": {
                  "type": "object",
                  "properties": {
                    "from": {
                      "type": "string",
                      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
                      "description": "Sender address or Keybase name to generate a transaction"
                    },
                    "memo": {
                      "type": "string",
                      "example": "Sent via Terra Station 🚀"
                    },
                    "chain_id": {
                      "type": "string",
                      "example": "Columbus-5"
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "1"
                    },
                    "gas": {
                      "type": "string",
                      "example": "200000"
                    },
                    "gas_adjustment": {
                      "type": "string",
                      "example": "1.2"
                    },
                    "fees": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    },
                    "simulate": {
                      "type": "boolean",
                      "example": false,
                      "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
                    }
                  }
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "msg": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fee": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "example": "uluna"
                          },
                          "amount": {
                            "type": "string",
                            "example": "50"
                          }
                        }
                      }
                    }
                  }
                },
                "memo": {
                  "type": "string"
                },
                "signature": {
                  "type": "object",
                  "properties": {
                    "signature": {
                      "type": "string",
                      "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "example": "tendermint/PubKeySecp256k1"
                        },
                        "value": {
                          "type": "string",
                          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                        }
                      }
                    },
                    "account_number": {
                      "type": "string",
                      "example": "0"
                    },
                    "sequence": {
                      "type": "string",
                      "example": "0"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/wasm/contracts/{contractAddress}/store": {
      "get": {
        "deprecated": true,
        "summary": "Get stored information with query msg",
        "tags": [
          "Wasm"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "contractAddress",
            "description": "contract address you want to lookup",
            "required": true,
            "type": "string"
          },
          {
            "in": "query",
            "name": "query_msg",
            "description": "json formatted query msg",
            "required": true,
            "type": "string",
            "x-example": "{}"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "string"
            }
          }
        }
      }
    },
    "/wasm/contracts/{contractAddress}/store/raw": {
      "get": {
        "deprecated": true,
        "summary": "Get stored information with store key",
        "tags": [
          "Wasm"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "contractAddress",
            "description": "contract address you want to lookup",
            "required": true,
            "type": "string"
          },
          {
            "in": "query",
            "name": "key",
            "description": "base64 encoded raw key to access",
            "required": true,
            "type": "string"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "string"
            }
          }
        }
      }
    },
    "/wasm/parameters": {
      "get": {
        "deprecated": true,
        "summary": "Get wasm module params",
        "tags": [
          "Wasm"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "max_contract_size": {
                  "type": "number",
                  "format": "integer",
                  "example": "1000000",
                  "description": "allowed max contract bytes size"
                },
                "max_contract_gas": {
                  "type": "number",
                  "format": "integer",
                  "example": "1000000",
                  "description": "allowed max gas usages per each contract execution"
                },
                "max_contract_msg_size": {
                  "type": "number",
                  "format": "integer",
                  "example": "1000000",
                  "description": "allowed max contract exe msg bytes size"
                },
                "max_contract_data_size": {
                  "type": "number",
                  "format": "integer",
                  "example": "100",
                  "description": "allowed max contract return data size"
                },
                "event_params": {
                  "type": "object",
                  "properties": {
                    "max_attribute_num": {
                      "type": "string",
                      "example": "128",
                      "description": "allowed max # of contract attribute num"
                    },
                    "max_attribute_key_length": {
                      "type": "string",
                      "example": "128",
                      "description": "allowed max length of a contract event attribute key"
                    },
                    "max_attribute_value_length": {
                      "type": "string",
                      "example": "128",
                      "description": "allowed max length of a contract event attribute value"
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/cosmos/auth/v1beta1/accounts": {
      "get": {
        "summary": "Accounts returns all the existing accounts",
        "description": "Since: cosmos-sdk 0.43",
        "operationId": "Accounts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "accounts": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  },
                  "title": "accounts are the existing accounts"
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryAccountsResponse is the response type for the Query/Accounts RPC method.\n\nSince: cosmos-sdk 0.43"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/accounts/{address}": {
      "get": {
        "summary": "Account returns account details based on address.",
        "operationId": "Account",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "account": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                }
              },
              "description": "QueryAccountResponse is the response type for the Query/Account RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address defines the address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/params": {
      "get": {
        "summary": "Params queries all parameters.",
        "operationId": "AuthParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params defines the parameters of the module.",
                  "type": "object",
                  "properties": {
                    "max_memo_characters": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "tx_sig_limit": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "tx_size_cost_per_byte": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "sig_verify_cost_ed25519": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "sig_verify_cost_secp256k1": {
                      "type": "string",
                      "format": "uint64"
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/authz/v1beta1/grants": {
      "get": {
        "summary": "Returns list of `Authorization`, granted to the grantee by the granter.",
        "operationId": "Grants",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "grants": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "authorization": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      },
                      "expiration": {
                        "type": "string",
                        "format": "date-time"
                      }
                    },
                    "description": "Grant gives permissions to execute\nthe provide method with expiration time."
                  },
                  "description": "authorizations is a list of grants granted for grantee by granter."
                },
                "pagination": {
                  "description": "pagination defines an pagination for the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryGrantsResponse is the response type for the Query/Authorizations RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "granter",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "grantee",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "msg_type_url",
            "description": "Optional, msg_type_url, when set, will query only grants matching given msg type.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/balances/{address}": {
      "get": {
        "summary": "AllBalances queries the balance of all coins for a single account.",
        "operationId": "AllBalances",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "balances": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                  },
                  "description": "balances is the balances of all the coins."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryAllBalancesResponse is the response type for the Query/AllBalances RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the address to query balances for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/balances/{address}/by_denom": {
      "get": {
        "summary": "Balance queries the balance of a single coin for a single account.",
        "operationId": "Balance",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "balance": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              },
              "description": "QueryBalanceResponse is the response type for the Query/Balance RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the address to query balances for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "denom",
            "description": "denom is the coin denom to query balances for.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/denoms_metadata": {
      "get": {
        "summary": "DenomsMetadata queries the client metadata for all registered coin denominations.",
        "operationId": "DenomsMetadata",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "metadatas": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "description": {
                        "type": "string"
                      },
                      "denom_units": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "denom": {
                              "type": "string",
                              "description": "denom represents the string name of the given denom unit (e.g uatom)."
                            },
                            "exponent": {
                              "type": "integer",
                              "format": "int64",
                              "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 1^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom)."
                            },
                            "aliases": {
                              "type": "array",
                              "items": {
                                "type": "string"
                              },
                              "title": "aliases is a list of string aliases for the given denom"
                            }
                          },
                          "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token."
                        },
                        "title": "denom_units represents the list of DenomUnit's for a given coin"
                      },
                      "base": {
                        "type": "string",
                        "description": "base represents the base denom (should be the DenomUnit with exponent = 0)."
                      },
                      "display": {
                        "type": "string",
                        "description": "display indicates the suggested denom that should be\ndisplayed in clients."
                      },
                      "name": {
                        "type": "string",
                        "description": "Since: cosmos-sdk 0.43",
                        "title": "name defines the name of the token (eg: Cosmos Atom)"
                      },
                      "symbol": {
                        "type": "string",
                        "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.\n\nSince: cosmos-sdk 0.43"
                      }
                    },
                    "description": "Metadata represents a struct that describes\na basic token."
                  },
                  "description": "metadata provides the client information for all the registered tokens."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/denoms_metadata/{denom}": {
      "get": {
        "summary": "DenomsMetadata queries the client metadata of a given coin denomination.",
        "operationId": "DenomMetadata",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "metadata": {
                  "type": "object",
                  "properties": {
                    "description": {
                      "type": "string"
                    },
                    "denom_units": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "description": "denom represents the string name of the given denom unit (e.g uatom)."
                          },
                          "exponent": {
                            "type": "integer",
                            "format": "int64",
                            "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 1^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom)."
                          },
                          "aliases": {
                            "type": "array",
                            "items": {
                              "type": "string"
                            },
                            "title": "aliases is a list of string aliases for the given denom"
                          }
                        },
                        "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token."
                      },
                      "title": "denom_units represents the list of DenomUnit's for a given coin"
                    },
                    "base": {
                      "type": "string",
                      "description": "base represents the base denom (should be the DenomUnit with exponent = 0)."
                    },
                    "display": {
                      "type": "string",
                      "description": "display indicates the suggested denom that should be\ndisplayed in clients."
                    },
                    "name": {
                      "type": "string",
                      "description": "Since: cosmos-sdk 0.43",
                      "title": "name defines the name of the token (eg: Cosmos Atom)"
                    },
                    "symbol": {
                      "type": "string",
                      "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.\n\nSince: cosmos-sdk 0.43"
                    }
                  },
                  "description": "Metadata represents a struct that describes\na basic token."
                }
              },
              "description": "QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "denom",
            "description": "denom is the coin denom to query the metadata for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/params": {
      "get": {
        "summary": "Params queries the parameters of x/bank module.",
        "operationId": "BankParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "type": "object",
                  "properties": {
                    "send_enabled": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "enabled": {
                            "type": "boolean",
                            "format": "boolean"
                          }
                        },
                        "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is\nsendable)."
                      }
                    },
                    "default_send_enabled": {
                      "type": "boolean",
                      "format": "boolean"
                    }
                  },
                  "description": "Params defines the parameters for the bank module."
                }
              },
              "description": "QueryParamsResponse defines the response type for querying x/bank parameters."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/supply": {
      "get": {
        "summary": "TotalSupply queries the total supply of all coins.",
        "operationId": "TotalSupply",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "supply": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                  },
                  "title": "supply is the supply of the coins"
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.\n\nSince: cosmos-sdk 0.43",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "title": "QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC\nmethod"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/supply/{denom}": {
      "get": {
        "summary": "SupplyOf queries the supply of a single coin.",
        "operationId": "SupplyOf",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "amount": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              },
              "description": "QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "denom",
            "description": "denom is the coin denom to query balances for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/base/tendermint/v1beta1/blocks/latest": {
      "get": {
        "summary": "GetLatestBlock returns the latest block.",
        "operationId": "GetLatestBlock",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "block": {
                  "type": "object",
                  "properties": {
                    "header": {
                      "type": "object",
                      "properties": {
                        "version": {
                          "title": "basic block info",
                          "type": "object",
                          "properties": {
                            "block": {
                              "type": "string",
                              "format": "uint64"
                            },
                            "app": {
                              "type": "string",
                              "format": "uint64"
                            }
                          },
                          "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                        },
                        "chain_id": {
                          "type": "string"
                        },
                        "height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "time": {
                          "type": "string",
                          "format": "date-time"
                        },
                        "last_block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            },
                            "part_set_header": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "hash": {
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "title": "PartsetHeader"
                            }
                          },
                          "title": "BlockID"
                        },
                        "last_commit_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "hashes of block data"
                        },
                        "data_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "validators_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "hashes from the app output from the prev block"
                        },
                        "next_validators_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "consensus_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "app_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "last_results_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "evidence_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "consensus info"
                        },
                        "proposer_address": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "description": "Header defines the structure of a Tendermint block header."
                    },
                    "data": {
                      "type": "object",
                      "properties": {
                        "txs": {
                          "type": "array",
                          "items": {
                            "type": "string",
                            "format": "byte"
                          },
                          "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs."
                        }
                      },
                      "title": "Data contains the set of transactions included in the block"
                    },
                    "evidence": {
                      "type": "object",
                      "properties": {
                        "evidence": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "duplicate_vote_evidence": {
                                "type": "object",
                                "properties": {
                                  "vote_a": {
                                    "type": "object",
                                    "properties": {
                                      "type": {
                                        "type": "string",
                                        "enum": [
                                          "SIGNED_MSG_TYPE_UNKNOWN",
                                          "SIGNED_MSG_TYPE_PREVOTE",
                                          "SIGNED_MSG_TYPE_PRECOMMIT",
                                          "SIGNED_MSG_TYPE_PROPOSAL"
                                        ],
                                        "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                        "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                                      },
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "round": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "format": "date-time"
                                      },
                                      "validator_address": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "validator_index": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "signature": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                                  },
                                  "vote_b": {
                                    "type": "object",
                                    "properties": {
                                      "type": {
                                        "type": "string",
                                        "enum": [
                                          "SIGNED_MSG_TYPE_UNKNOWN",
                                          "SIGNED_MSG_TYPE_PREVOTE",
                                          "SIGNED_MSG_TYPE_PRECOMMIT",
                                          "SIGNED_MSG_TYPE_PROPOSAL"
                                        ],
                                        "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                        "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                                      },
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "round": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "format": "date-time"
                                      },
                                      "validator_address": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "validator_index": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "signature": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                                  },
                                  "total_voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "validator_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "timestamp": {
                                    "type": "string",
                                    "format": "date-time"
                                  }
                                },
                                "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                              },
                              "light_client_attack_evidence": {
                                "type": "object",
                                "properties": {
                                  "conflicting_block": {
                                    "type": "object",
                                    "properties": {
                                      "signed_header": {
                                        "type": "object",
                                        "properties": {
                                          "header": {
                                            "type": "object",
                                            "properties": {
                                              "version": {
                                                "title": "basic block info",
                                                "type": "object",
                                                "properties": {
                                                  "block": {
                                                    "type": "string",
                                                    "format": "uint64"
                                                  },
                                                  "app": {
                                                    "type": "string",
                                                    "format": "uint64"
                                                  }
                                                },
                                                "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                              },
                                              "chain_id": {
                                                "type": "string"
                                              },
                                              "height": {
                                                "type": "string",
                                                "format": "int64"
                                              },
                                              "time": {
                                                "type": "string",
                                                "format": "date-time"
                                              },
                                              "last_block_id": {
                                                "type": "object",
                                                "properties": {
                                                  "hash": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "part_set_header": {
                                                    "type": "object",
                                                    "properties": {
                                                      "total": {
                                                        "type": "integer",
                                                        "format": "int64"
                                                      },
                                                      "hash": {
                                                        "type": "string",
                                                        "format": "byte"
                                                      }
                                                    },
                                                    "title": "PartsetHeader"
                                                  }
                                                },
                                                "title": "BlockID"
                                              },
                                              "last_commit_hash": {
                                                "type": "string",
                                                "format": "byte",
                                                "title": "hashes of block data"
                                              },
                                              "data_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "validators_hash": {
                                                "type": "string",
                                                "format": "byte",
                                                "title": "hashes from the app output from the prev block"
                                              },
                                              "next_validators_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "consensus_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "app_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "last_results_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "evidence_hash": {
                                                "type": "string",
                                                "format": "byte",
                                                "title": "consensus info"
                                              },
                                              "proposer_address": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "description": "Header defines the structure of a Tendermint block header."
                                          },
                                          "commit": {
                                            "type": "object",
                                            "properties": {
                                              "height": {
                                                "type": "string",
                                                "format": "int64"
                                              },
                                              "round": {
                                                "type": "integer",
                                                "format": "int32"
                                              },
                                              "block_id": {
                                                "type": "object",
                                                "properties": {
                                                  "hash": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "part_set_header": {
                                                    "type": "object",
                                                    "properties": {
                                                      "total": {
                                                        "type": "integer",
                                                        "format": "int64"
                                                      },
                                                      "hash": {
                                                        "type": "string",
                                                        "format": "byte"
                                                      }
                                                    },
                                                    "title": "PartsetHeader"
                                                  }
                                                },
                                                "title": "BlockID"
                                              },
                                              "signatures": {
                                                "type": "array",
                                                "items": {
                                                  "type": "object",
                                                  "properties": {
                                                    "block_id_flag": {
                                                      "type": "string",
                                                      "enum": [
                                                        "BLOCK_ID_FLAG_UNKNOWN",
                                                        "BLOCK_ID_FLAG_ABSENT",
                                                        "BLOCK_ID_FLAG_COMMIT",
                                                        "BLOCK_ID_FLAG_NIL"
                                                      ],
                                                      "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                      "title": "BlockIdFlag indicates which BlcokID the signature is for"
                                                    },
                                                    "validator_address": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    },
                                                    "timestamp": {
                                                      "type": "string",
                                                      "format": "date-time"
                                                    },
                                                    "signature": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    }
                                                  },
                                                  "description": "CommitSig is a part of the Vote included in a Commit."
                                                }
                                              }
                                            },
                                            "description": "Commit contains the evidence that a block was committed by a set of validators."
                                          }
                                        }
                                      },
                                      "validator_set": {
                                        "type": "object",
                                        "properties": {
                                          "validators": {
                                            "type": "array",
                                            "items": {
                                              "type": "object",
                                              "properties": {
                                                "address": {
                                                  "type": "string",
                                                  "format": "byte"
                                                },
                                                "pub_key": {
                                                  "type": "object",
                                                  "properties": {
                                                    "ed25519": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    },
                                                    "secp256k1": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    }
                                                  },
                                                  "title": "PublicKey defines the keys available for use with Tendermint Validators"
                                                },
                                                "voting_power": {
                                                  "type": "string",
                                                  "format": "int64"
                                                },
                                                "proposer_priority": {
                                                  "type": "string",
                                                  "format": "int64"
                                                }
                                              }
                                            }
                                          },
                                          "proposer": {
                                            "type": "object",
                                            "properties": {
                                              "address": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "pub_key": {
                                                "type": "object",
                                                "properties": {
                                                  "ed25519": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "secp256k1": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  }
                                                },
                                                "title": "PublicKey defines the keys available for use with Tendermint Validators"
                                              },
                                              "voting_power": {
                                                "type": "string",
                                                "format": "int64"
                                              },
                                              "proposer_priority": {
                                                "type": "string",
                                                "format": "int64"
                                              }
                                            }
                                          },
                                          "total_voting_power": {
                                            "type": "string",
                                            "format": "int64"
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "common_height": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "byzantine_validators": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "address": {
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "pub_key": {
                                          "type": "object",
                                          "properties": {
                                            "ed25519": {
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "secp256k1": {
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          },
                                          "title": "PublicKey defines the keys available for use with Tendermint Validators"
                                        },
                                        "voting_power": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "proposer_priority": {
                                          "type": "string",
                                          "format": "int64"
                                        }
                                      }
                                    }
                                  },
                                  "total_voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "timestamp": {
                                    "type": "string",
                                    "format": "date-time"
                                  }
                                },
                                "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                              }
                            }
                          }
                        }
                      }
                    },
                    "last_commit": {
                      "type": "object",
                      "properties": {
                        "height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "round": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            },
                            "part_set_header": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "hash": {
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "title": "PartsetHeader"
                            }
                          },
                          "title": "BlockID"
                        },
                        "signatures": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "block_id_flag": {
                                "type": "string",
                                "enum": [
                                  "BLOCK_ID_FLAG_UNKNOWN",
                                  "BLOCK_ID_FLAG_ABSENT",
                                  "BLOCK_ID_FLAG_COMMIT",
                                  "BLOCK_ID_FLAG_NIL"
                                ],
                                "default": "BLOCK_ID_FLAG_UNKNOWN",
                                "title": "BlockIdFlag indicates which BlcokID the signature is for"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "CommitSig is a part of the Vote included in a Commit."
                          }
                        }
                      },
                      "description": "Commit contains the evidence that a block was committed by a set of validators."
                    }
                  }
                }
              },
              "description": "GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/base/tendermint/v1beta1/blocks/{height}": {
      "get": {
        "summary": "GetBlockByHeight queries block for given height.",
        "operationId": "GetBlockByHeight",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "block": {
                  "type": "object",
                  "properties": {
                    "header": {
                      "type": "object",
                      "properties": {
                        "version": {
                          "title": "basic block info",
                          "type": "object",
                          "properties": {
                            "block": {
                              "type": "string",
                              "format": "uint64"
                            },
                            "app": {
                              "type": "string",
                              "format": "uint64"
                            }
                          },
                          "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                        },
                        "chain_id": {
                          "type": "string"
                        },
                        "height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "time": {
                          "type": "string",
                          "format": "date-time"
                        },
                        "last_block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            },
                            "part_set_header": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "hash": {
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "title": "PartsetHeader"
                            }
                          },
                          "title": "BlockID"
                        },
                        "last_commit_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "hashes of block data"
                        },
                        "data_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "validators_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "hashes from the app output from the prev block"
                        },
                        "next_validators_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "consensus_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "app_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "last_results_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "evidence_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "consensus info"
                        },
                        "proposer_address": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "description": "Header defines the structure of a Tendermint block header."
                    },
                    "data": {
                      "type": "object",
                      "properties": {
                        "txs": {
                          "type": "array",
                          "items": {
                            "type": "string",
                            "format": "byte"
                          },
                          "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs."
                        }
                      },
                      "title": "Data contains the set of transactions included in the block"
                    },
                    "evidence": {
                      "type": "object",
                      "properties": {
                        "evidence": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "duplicate_vote_evidence": {
                                "type": "object",
                                "properties": {
                                  "vote_a": {
                                    "type": "object",
                                    "properties": {
                                      "type": {
                                        "type": "string",
                                        "enum": [
                                          "SIGNED_MSG_TYPE_UNKNOWN",
                                          "SIGNED_MSG_TYPE_PREVOTE",
                                          "SIGNED_MSG_TYPE_PRECOMMIT",
                                          "SIGNED_MSG_TYPE_PROPOSAL"
                                        ],
                                        "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                        "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                                      },
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "round": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "format": "date-time"
                                      },
                                      "validator_address": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "validator_index": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "signature": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                                  },
                                  "vote_b": {
                                    "type": "object",
                                    "properties": {
                                      "type": {
                                        "type": "string",
                                        "enum": [
                                          "SIGNED_MSG_TYPE_UNKNOWN",
                                          "SIGNED_MSG_TYPE_PREVOTE",
                                          "SIGNED_MSG_TYPE_PRECOMMIT",
                                          "SIGNED_MSG_TYPE_PROPOSAL"
                                        ],
                                        "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                        "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                                      },
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "round": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "format": "date-time"
                                      },
                                      "validator_address": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "validator_index": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "signature": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                                  },
                                  "total_voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "validator_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "timestamp": {
                                    "type": "string",
                                    "format": "date-time"
                                  }
                                },
                                "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                              },
                              "light_client_attack_evidence": {
                                "type": "object",
                                "properties": {
                                  "conflicting_block": {
                                    "type": "object",
                                    "properties": {
                                      "signed_header": {
                                        "type": "object",
                                        "properties": {
                                          "header": {
                                            "type": "object",
                                            "properties": {
                                              "version": {
                                                "title": "basic block info",
                                                "type": "object",
                                                "properties": {
                                                  "block": {
                                                    "type": "string",
                                                    "format": "uint64"
                                                  },
                                                  "app": {
                                                    "type": "string",
                                                    "format": "uint64"
                                                  }
                                                },
                                                "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                              },
                                              "chain_id": {
                                                "type": "string"
                                              },
                                              "height": {
                                                "type": "string",
                                                "format": "int64"
                                              },
                                              "time": {
                                                "type": "string",
                                                "format": "date-time"
                                              },
                                              "last_block_id": {
                                                "type": "object",
                                                "properties": {
                                                  "hash": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "part_set_header": {
                                                    "type": "object",
                                                    "properties": {
                                                      "total": {
                                                        "type": "integer",
                                                        "format": "int64"
                                                      },
                                                      "hash": {
                                                        "type": "string",
                                                        "format": "byte"
                                                      }
                                                    },
                                                    "title": "PartsetHeader"
                                                  }
                                                },
                                                "title": "BlockID"
                                              },
                                              "last_commit_hash": {
                                                "type": "string",
                                                "format": "byte",
                                                "title": "hashes of block data"
                                              },
                                              "data_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "validators_hash": {
                                                "type": "string",
                                                "format": "byte",
                                                "title": "hashes from the app output from the prev block"
                                              },
                                              "next_validators_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "consensus_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "app_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "last_results_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "evidence_hash": {
                                                "type": "string",
                                                "format": "byte",
                                                "title": "consensus info"
                                              },
                                              "proposer_address": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "description": "Header defines the structure of a Tendermint block header."
                                          },
                                          "commit": {
                                            "type": "object",
                                            "properties": {
                                              "height": {
                                                "type": "string",
                                                "format": "int64"
                                              },
                                              "round": {
                                                "type": "integer",
                                                "format": "int32"
                                              },
                                              "block_id": {
                                                "type": "object",
                                                "properties": {
                                                  "hash": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "part_set_header": {
                                                    "type": "object",
                                                    "properties": {
                                                      "total": {
                                                        "type": "integer",
                                                        "format": "int64"
                                                      },
                                                      "hash": {
                                                        "type": "string",
                                                        "format": "byte"
                                                      }
                                                    },
                                                    "title": "PartsetHeader"
                                                  }
                                                },
                                                "title": "BlockID"
                                              },
                                              "signatures": {
                                                "type": "array",
                                                "items": {
                                                  "type": "object",
                                                  "properties": {
                                                    "block_id_flag": {
                                                      "type": "string",
                                                      "enum": [
                                                        "BLOCK_ID_FLAG_UNKNOWN",
                                                        "BLOCK_ID_FLAG_ABSENT",
                                                        "BLOCK_ID_FLAG_COMMIT",
                                                        "BLOCK_ID_FLAG_NIL"
                                                      ],
                                                      "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                      "title": "BlockIdFlag indicates which BlcokID the signature is for"
                                                    },
                                                    "validator_address": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    },
                                                    "timestamp": {
                                                      "type": "string",
                                                      "format": "date-time"
                                                    },
                                                    "signature": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    }
                                                  },
                                                  "description": "CommitSig is a part of the Vote included in a Commit."
                                                }
                                              }
                                            },
                                            "description": "Commit contains the evidence that a block was committed by a set of validators."
                                          }
                                        }
                                      },
                                      "validator_set": {
                                        "type": "object",
                                        "properties": {
                                          "validators": {
                                            "type": "array",
                                            "items": {
                                              "type": "object",
                                              "properties": {
                                                "address": {
                                                  "type": "string",
                                                  "format": "byte"
                                                },
                                                "pub_key": {
                                                  "type": "object",
                                                  "properties": {
                                                    "ed25519": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    },
                                                    "secp256k1": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    }
                                                  },
                                                  "title": "PublicKey defines the keys available for use with Tendermint Validators"
                                                },
                                                "voting_power": {
                                                  "type": "string",
                                                  "format": "int64"
                                                },
                                                "proposer_priority": {
                                                  "type": "string",
                                                  "format": "int64"
                                                }
                                              }
                                            }
                                          },
                                          "proposer": {
                                            "type": "object",
                                            "properties": {
                                              "address": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "pub_key": {
                                                "type": "object",
                                                "properties": {
                                                  "ed25519": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "secp256k1": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  }
                                                },
                                                "title": "PublicKey defines the keys available for use with Tendermint Validators"
                                              },
                                              "voting_power": {
                                                "type": "string",
                                                "format": "int64"
                                              },
                                              "proposer_priority": {
                                                "type": "string",
                                                "format": "int64"
                                              }
                                            }
                                          },
                                          "total_voting_power": {
                                            "type": "string",
                                            "format": "int64"
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "common_height": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "byzantine_validators": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "address": {
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "pub_key": {
                                          "type": "object",
                                          "properties": {
                                            "ed25519": {
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "secp256k1": {
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          },
                                          "title": "PublicKey defines the keys available for use with Tendermint Validators"
                                        },
                                        "voting_power": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "proposer_priority": {
                                          "type": "string",
                                          "format": "int64"
                                        }
                                      }
                                    }
                                  },
                                  "total_voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "timestamp": {
                                    "type": "string",
                                    "format": "date-time"
                                  }
                                },
                                "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                              }
                            }
                          }
                        }
                      }
                    },
                    "last_commit": {
                      "type": "object",
                      "properties": {
                        "height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "round": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            },
                            "part_set_header": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "hash": {
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "title": "PartsetHeader"
                            }
                          },
                          "title": "BlockID"
                        },
                        "signatures": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "block_id_flag": {
                                "type": "string",
                                "enum": [
                                  "BLOCK_ID_FLAG_UNKNOWN",
                                  "BLOCK_ID_FLAG_ABSENT",
                                  "BLOCK_ID_FLAG_COMMIT",
                                  "BLOCK_ID_FLAG_NIL"
                                ],
                                "default": "BLOCK_ID_FLAG_UNKNOWN",
                                "title": "BlockIdFlag indicates which BlcokID the signature is for"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "CommitSig is a part of the Vote included in a Commit."
                          }
                        }
                      },
                      "description": "Commit contains the evidence that a block was committed by a set of validators."
                    }
                  }
                }
              },
              "description": "GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "height",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/base/tendermint/v1beta1/node_info": {
      "get": {
        "summary": "GetNodeInfo queries the current node info.",
        "operationId": "GetNodeInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "default_node_info": {
                  "type": "object",
                  "properties": {
                    "protocol_version": {
                      "type": "object",
                      "properties": {
                        "p2p": {
                          "type": "string",
                          "format": "uint64"
                        },
                        "block": {
                          "type": "string",
                          "format": "uint64"
                        },
                        "app": {
                          "type": "string",
                          "format": "uint64"
                        }
                      }
                    },
                    "default_node_id": {
                      "type": "string"
                    },
                    "listen_addr": {
                      "type": "string"
                    },
                    "network": {
                      "type": "string"
                    },
                    "version": {
                      "type": "string"
                    },
                    "channels": {
                      "type": "string",
                      "format": "byte"
                    },
                    "moniker": {
                      "type": "string"
                    },
                    "other": {
                      "type": "object",
                      "properties": {
                        "tx_index": {
                          "type": "string"
                        },
                        "rpc_address": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "application_version": {
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string"
                    },
                    "app_name": {
                      "type": "string"
                    },
                    "version": {
                      "type": "string"
                    },
                    "git_commit": {
                      "type": "string"
                    },
                    "build_tags": {
                      "type": "string"
                    },
                    "go_version": {
                      "type": "string"
                    },
                    "build_deps": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "path": {
                            "type": "string",
                            "title": "module path"
                          },
                          "version": {
                            "type": "string",
                            "title": "module version"
                          },
                          "sum": {
                            "type": "string",
                            "title": "checksum"
                          }
                        },
                        "title": "Module is the type for VersionInfo"
                      }
                    },
                    "cosmos_sdk_version": {
                      "type": "string",
                      "title": "Since: cosmos-sdk 0.43"
                    }
                  },
                  "description": "VersionInfo is the type for the GetNodeInfoResponse message."
                }
              },
              "description": "GetNodeInfoResponse is the request type for the Query/GetNodeInfo RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/base/tendermint/v1beta1/syncing": {
      "get": {
        "summary": "GetSyncing queries node syncing.",
        "operationId": "GetSyncing",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "syncing": {
                  "type": "boolean",
                  "format": "boolean"
                }
              },
              "description": "GetSyncingResponse is the response type for the Query/GetSyncing RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/base/tendermint/v1beta1/validatorsets/latest": {
      "get": {
        "summary": "GetLatestValidatorSet queries latest validator-set.",
        "operationId": "GetLatestValidatorSet",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "block_height": {
                  "type": "string",
                  "format": "int64"
                },
                "validators": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "address": {
                        "type": "string"
                      },
                      "pub_key": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      },
                      "voting_power": {
                        "type": "string",
                        "format": "int64"
                      },
                      "proposer_priority": {
                        "type": "string",
                        "format": "int64"
                      }
                    },
                    "description": "Validator is the type for the validator-set."
                  }
                },
                "pagination": {
                  "description": "pagination defines an pagination for the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/base/tendermint/v1beta1/validatorsets/{height}": {
      "get": {
        "summary": "GetValidatorSetByHeight queries validator-set at a given height.",
        "operationId": "GetValidatorSetByHeight",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "block_height": {
                  "type": "string",
                  "format": "int64"
                },
                "validators": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "address": {
                        "type": "string"
                      },
                      "pub_key": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      },
                      "voting_power": {
                        "type": "string",
                        "format": "int64"
                      },
                      "proposer_priority": {
                        "type": "string",
                        "format": "int64"
                      }
                    },
                    "description": "Validator is the type for the validator-set."
                  }
                },
                "pagination": {
                  "description": "pagination defines an pagination for the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "height",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/community_pool": {
      "get": {
        "summary": "CommunityPool queries the community pool coins.",
        "operationId": "CommunityPool",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "pool": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                  },
                  "description": "pool defines community pool's coins."
                }
              },
              "description": "QueryCommunityPoolResponse is the response type for the Query/CommunityPool\nRPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards": {
      "get": {
        "summary": "DelegationTotalRewards queries the total rewards accrued by a each\nvalidator.",
        "operationId": "DelegationTotalRewards",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "rewards": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "validator_address": {
                        "type": "string"
                      },
                      "reward": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "denom": {
                              "type": "string"
                            },
                            "amount": {
                              "type": "string"
                            }
                          },
                          "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                        }
                      }
                    },
                    "description": "DelegationDelegatorReward represents the properties\nof a delegator's delegation reward."
                  },
                  "description": "rewards defines all the rewards accrued by a delegator."
                },
                "total": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                  },
                  "description": "total defines the sum of all the rewards."
                }
              },
              "description": "QueryDelegationTotalRewardsResponse is the response type for the\nQuery/DelegationTotalRewards RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "delegator_address",
            "description": "delegator_address defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}": {
      "get": {
        "summary": "DelegationRewards queries the total rewards accrued by a delegation.",
        "operationId": "DelegationRewards",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "rewards": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                  },
                  "description": "rewards defines the rewards accrued by a delegation."
                }
              },
              "description": "QueryDelegationRewardsResponse is the response type for the\nQuery/DelegationRewards RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "delegator_address",
            "description": "delegator_address defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "validator_address",
            "description": "validator_address defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/delegators/{delegator_address}/validators": {
      "get": {
        "summary": "DelegatorValidators queries the validators of a delegator.",
        "operationId": "DelegatorValidators",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "validators": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "validators defines the validators a delegator is delegating for."
                }
              },
              "description": "QueryDelegatorValidatorsResponse is the response type for the\nQuery/DelegatorValidators RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "delegator_address",
            "description": "delegator_address defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/delegators/{delegator_address}/withdraw_address": {
      "get": {
        "summary": "DelegatorWithdrawAddress queries withdraw address of a delegator.",
        "operationId": "DelegatorWithdrawAddress",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "withdraw_address": {
                  "type": "string",
                  "description": "withdraw_address defines the delegator address to query for."
                }
              },
              "description": "QueryDelegatorWithdrawAddressResponse is the response type for the\nQuery/DelegatorWithdrawAddress RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "delegator_address",
            "description": "delegator_address defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/params": {
      "get": {
        "summary": "Params queries params of the distribution module.",
        "operationId": "DistributionParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params defines the parameters of the module.",
                  "type": "object",
                  "properties": {
                    "community_tax": {
                      "type": "string"
                    },
                    "base_proposer_reward": {
                      "type": "string"
                    },
                    "bonus_proposer_reward": {
                      "type": "string"
                    },
                    "withdraw_addr_enabled": {
                      "type": "boolean",
                      "format": "boolean"
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/validators/{validator_address}/commission": {
      "get": {
        "summary": "ValidatorCommission queries accumulated commission for a validator.",
        "operationId": "ValidatorCommission",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "commission": {
                  "description": "commission defines the commision the validator received.",
                  "type": "object",
                  "properties": {
                    "commission": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                      }
                    }
                  }
                }
              },
              "title": "QueryValidatorCommissionResponse is the response type for the\nQuery/ValidatorCommission RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "validator_address",
            "description": "validator_address defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/validators/{validator_address}/outstanding_rewards": {
      "get": {
        "summary": "ValidatorOutstandingRewards queries rewards of a validator address.",
        "operationId": "ValidatorOutstandingRewards",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "rewards": {
                  "type": "object",
                  "properties": {
                    "rewards": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                      }
                    }
                  },
                  "description": "ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards\nfor a validator inexpensive to track, allows simple sanity checks."
                }
              },
              "description": "QueryValidatorOutstandingRewardsResponse is the response type for the\nQuery/ValidatorOutstandingRewards RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "validator_address",
            "description": "validator_address defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/validators/{validator_address}/slashes": {
      "get": {
        "summary": "ValidatorSlashes queries slash events of a validator.",
        "operationId": "ValidatorSlashes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "slashes": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "validator_period": {
                        "type": "string",
                        "format": "uint64"
                      },
                      "fraction": {
                        "type": "string"
                      }
                    },
                    "description": "ValidatorSlashEvent represents a validator slash event.\nHeight is implicit within the store key.\nThis is needed to calculate appropriate amount of staking tokens\nfor delegations which are withdrawn after a slash has occurred."
                  },
                  "description": "slashes defines the slashes the validator received."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryValidatorSlashesResponse is the response type for the\nQuery/ValidatorSlashes RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "validator_address",
            "description": "validator_address defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "starting_height",
            "description": "starting_height defines the optional starting height to query the slashes.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "ending_height",
            "description": "starting_height defines the optional ending height to query the slashes.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/evidence/v1beta1/evidence": {
      "get": {
        "summary": "AllEvidence queries all evidence.",
        "operationId": "AllEvidence",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "evidence": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  },
                  "description": "evidence returns all evidences."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/evidence/v1beta1/evidence/{evidence_hash}": {
      "get": {
        "summary": "Evidence queries evidence based on evidence hash.",
        "operationId": "Evidence",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "evidence": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                }
              },
              "description": "QueryEvidenceResponse is the response type for the Query/Evidence RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "evidence_hash",
            "description": "evidence_hash defines the hash of the requested evidence.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}": {
      "get": {
        "summary": "Allowance returns fee granted to the grantee by the granter.",
        "operationId": "Allowance",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "allowance": {
                  "description": "allowance is a allowance granted for grantee by granter.",
                  "type": "object",
                  "properties": {
                    "granter": {
                      "type": "string",
                      "description": "granter is the address of the user granting an allowance of their funds."
                    },
                    "grantee": {
                      "type": "string",
                      "description": "grantee is the address of the user being granted an allowance of another user's funds."
                    },
                    "allowance": {
                      "description": "allowance can be any of basic and filtered fee allowance.",
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "type": "string",
                          "format": "byte",
                          "description": "Must be a valid serialized protocol buffer of the above specified type."
                        }
                      }
                    }
                  },
                  "title": "Grant is stored in the KVStore to record a grant with full context"
                }
              },
              "description": "QueryAllowanceResponse is the response type for the Query/Allowance RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "granter",
            "description": "granter is the address of the user granting an allowance of their funds.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "grantee",
            "description": "grantee is the address of the user being granted an allowance of another user's funds.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/feegrant/v1beta1/allowances/{grantee}": {
      "get": {
        "summary": "Allowances returns all the grants for address.",
        "operationId": "Allowances",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "allowances": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "granter": {
                        "type": "string",
                        "description": "granter is the address of the user granting an allowance of their funds."
                      },
                      "grantee": {
                        "type": "string",
                        "description": "grantee is the address of the user being granted an allowance of another user's funds."
                      },
                      "allowance": {
                        "description": "allowance can be any of basic and filtered fee allowance.",
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        }
                      }
                    },
                    "title": "Grant is stored in the KVStore to record a grant with full context"
                  },
                  "description": "allowances are allowance's granted for grantee by granter."
                },
                "pagination": {
                  "description": "pagination defines an pagination for the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryAllowancesResponse is the response type for the Query/Allowances RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "grantee",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/params/{params_type}": {
      "get": {
        "summary": "Params queries all parameters of the gov module.",
        "operationId": "GovParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "voting_params": {
                  "description": "voting_params defines the parameters related to voting.",
                  "type": "object",
                  "properties": {
                    "voting_period": {
                      "type": "string",
                      "description": "Length of the voting period."
                    }
                  }
                },
                "deposit_params": {
                  "description": "deposit_params defines the parameters related to deposit.",
                  "type": "object",
                  "properties": {
                    "min_deposit": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      },
                      "description": "Minimum deposit for a proposal to enter voting period."
                    },
                    "max_deposit_period": {
                      "type": "string",
                      "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\n months."
                    }
                  }
                },
                "tally_params": {
                  "description": "tally_params defines the parameters related to tally.",
                  "type": "object",
                  "properties": {
                    "quorum": {
                      "type": "string",
                      "format": "byte",
                      "description": "Minimum percentage of total stake needed to vote for a result to be\n considered valid."
                    },
                    "threshold": {
                      "type": "string",
                      "format": "byte",
                      "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
                    },
                    "veto_threshold": {
                      "type": "string",
                      "format": "byte",
                      "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\n vetoed. Default value: 1/3."
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "params_type",
            "description": "params_type defines which parameters to query for, can be one of \"voting\",\n\"tallying\" or \"deposit\".",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals": {
      "get": {
        "summary": "Proposals queries all proposals based on given status.",
        "operationId": "Proposals",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "proposals": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "proposal_id": {
                        "type": "string",
                        "format": "uint64"
                      },
                      "content": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      },
                      "status": {
                        "type": "string",
                        "enum": [
                          "PROPOSAL_STATUS_UNSPECIFIED",
                          "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                          "PROPOSAL_STATUS_VOTING_PERIOD",
                          "PROPOSAL_STATUS_PASSED",
                          "PROPOSAL_STATUS_REJECTED",
                          "PROPOSAL_STATUS_FAILED"
                        ],
                        "default": "PROPOSAL_STATUS_UNSPECIFIED",
                        "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed."
                      },
                      "final_tally_result": {
                        "type": "object",
                        "properties": {
                          "yes": {
                            "type": "string"
                          },
                          "abstain": {
                            "type": "string"
                          },
                          "no": {
                            "type": "string"
                          },
                          "no_with_veto": {
                            "type": "string"
                          }
                        },
                        "description": "TallyResult defines a standard tally for a governance proposal."
                      },
                      "submit_time": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "deposit_end_time": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "total_deposit": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "denom": {
                              "type": "string"
                            },
                            "amount": {
                              "type": "string"
                            }
                          },
                          "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                        }
                      },
                      "voting_start_time": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "voting_end_time": {
                        "type": "string",
                        "format": "date-time"
                      }
                    },
                    "description": "Proposal defines the core field members of a governance proposal."
                  }
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryProposalsResponse is the response type for the Query/Proposals RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_status",
            "description": "proposal_status defines the status of the proposals.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "PROPOSAL_STATUS_UNSPECIFIED",
              "PROPOSAL_STATUS_DEPOSIT_PERIOD",
              "PROPOSAL_STATUS_VOTING_PERIOD",
              "PROPOSAL_STATUS_PASSED",
              "PROPOSAL_STATUS_REJECTED",
              "PROPOSAL_STATUS_FAILED"
            ],
            "default": "PROPOSAL_STATUS_UNSPECIFIED"
          },
          {
            "name": "voter",
            "description": "voter defines the voter address for the proposals.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "depositor",
            "description": "depositor defines the deposit addresses from the proposals.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}": {
      "get": {
        "summary": "Proposal queries proposal details based on ProposalID.",
        "operationId": "Proposal",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "proposal": {
                  "type": "object",
                  "properties": {
                    "proposal_id": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "content": {
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "type": "string",
                          "format": "byte",
                          "description": "Must be a valid serialized protocol buffer of the above specified type."
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    },
                    "status": {
                      "type": "string",
                      "enum": [
                        "PROPOSAL_STATUS_UNSPECIFIED",
                        "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                        "PROPOSAL_STATUS_VOTING_PERIOD",
                        "PROPOSAL_STATUS_PASSED",
                        "PROPOSAL_STATUS_REJECTED",
                        "PROPOSAL_STATUS_FAILED"
                      ],
                      "default": "PROPOSAL_STATUS_UNSPECIFIED",
                      "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed."
                    },
                    "final_tally_result": {
                      "type": "object",
                      "properties": {
                        "yes": {
                          "type": "string"
                        },
                        "abstain": {
                          "type": "string"
                        },
                        "no": {
                          "type": "string"
                        },
                        "no_with_veto": {
                          "type": "string"
                        }
                      },
                      "description": "TallyResult defines a standard tally for a governance proposal."
                    },
                    "submit_time": {
                      "type": "string",
                      "format": "date-time"
                    },
                    "deposit_end_time": {
                      "type": "string",
                      "format": "date-time"
                    },
                    "total_deposit": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      }
                    },
                    "voting_start_time": {
                      "type": "string",
                      "format": "date-time"
                    },
                    "voting_end_time": {
                      "type": "string",
                      "format": "date-time"
                    }
                  },
                  "description": "Proposal defines the core field members of a governance proposal."
                }
              },
              "description": "QueryProposalResponse is the response type for the Query/Proposal RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits": {
      "get": {
        "summary": "Deposits queries all deposits of a single proposal.",
        "operationId": "Deposits",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "deposits": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "proposal_id": {
                        "type": "string",
                        "format": "uint64"
                      },
                      "depositor": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "denom": {
                              "type": "string"
                            },
                            "amount": {
                              "type": "string"
                            }
                          },
                          "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                        }
                      }
                    },
                    "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
                  }
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryDepositsResponse is the response type for the Query/Deposits RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}": {
      "get": {
        "summary": "Deposit queries single deposit information based proposalID, depositAddr.",
        "operationId": "Deposit",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "deposit": {
                  "type": "object",
                  "properties": {
                    "proposal_id": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "depositor": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      }
                    }
                  },
                  "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
                }
              },
              "description": "QueryDepositResponse is the response type for the Query/Deposit RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "depositor",
            "description": "depositor defines the deposit addresses from the proposals.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}/tally": {
      "get": {
        "summary": "TallyResult queries the tally of a proposal vote.",
        "operationId": "TallyResult",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "tally": {
                  "type": "object",
                  "properties": {
                    "yes": {
                      "type": "string"
                    },
                    "abstain": {
                      "type": "string"
                    },
                    "no": {
                      "type": "string"
                    },
                    "no_with_veto": {
                      "type": "string"
                    }
                  },
                  "description": "TallyResult defines a standard tally for a governance proposal."
                }
              },
              "description": "QueryTallyResultResponse is the response type for the Query/Tally RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}/votes": {
      "get": {
        "summary": "Votes queries votes of a given proposal.",
        "operationId": "Votes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "votes": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "proposal_id": {
                        "type": "string",
                        "format": "uint64"
                      },
                      "voter": {
                        "type": "string"
                      },
                      "option": {
                        "description": "Deprecated: Prefer to use `options` instead. This field is set in queries\nif and only if `len(options) == 1` and that option has weight 1. In all\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.",
                        "type": "string",
                        "enum": [
                          "VOTE_OPTION_UNSPECIFIED",
                          "VOTE_OPTION_YES",
                          "VOTE_OPTION_ABSTAIN",
                          "VOTE_OPTION_NO",
                          "VOTE_OPTION_NO_WITH_VETO"
                        ],
                        "default": "VOTE_OPTION_UNSPECIFIED"
                      },
                      "options": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "option": {
                              "type": "string",
                              "enum": [
                                "VOTE_OPTION_UNSPECIFIED",
                                "VOTE_OPTION_YES",
                                "VOTE_OPTION_ABSTAIN",
                                "VOTE_OPTION_NO",
                                "VOTE_OPTION_NO_WITH_VETO"
                              ],
                              "default": "VOTE_OPTION_UNSPECIFIED",
                              "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."
                            },
                            "weight": {
                              "type": "string"
                            }
                          },
                          "description": "WeightedVoteOption defines a unit of vote for vote split.\n\nSince: cosmos-sdk 0.43"
                        },
                        "title": "Since: cosmos-sdk 0.43"
                      }
                    },
                    "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
                  },
                  "description": "votes defined the queried votes."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryVotesResponse is the response type for the Query/Votes RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}": {
      "get": {
        "summary": "Vote queries voted information based on proposalID, voterAddr.",
        "operationId": "Vote",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "vote": {
                  "type": "object",
                  "properties": {
                    "proposal_id": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "voter": {
                      "type": "string"
                    },
                    "option": {
                      "description": "Deprecated: Prefer to use `options` instead. This field is set in queries\nif and only if `len(options) == 1` and that option has weight 1. In all\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.",
                      "type": "string",
                      "enum": [
                        "VOTE_OPTION_UNSPECIFIED",
                        "VOTE_OPTION_YES",
                        "VOTE_OPTION_ABSTAIN",
                        "VOTE_OPTION_NO",
                        "VOTE_OPTION_NO_WITH_VETO"
                      ],
                      "default": "VOTE_OPTION_UNSPECIFIED"
                    },
                    "options": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "option": {
                            "type": "string",
                            "enum": [
                              "VOTE_OPTION_UNSPECIFIED",
                              "VOTE_OPTION_YES",
                              "VOTE_OPTION_ABSTAIN",
                              "VOTE_OPTION_NO",
                              "VOTE_OPTION_NO_WITH_VETO"
                            ],
                            "default": "VOTE_OPTION_UNSPECIFIED",
                            "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."
                          },
                          "weight": {
                            "type": "string"
                          }
                        },
                        "description": "WeightedVoteOption defines a unit of vote for vote split.\n\nSince: cosmos-sdk 0.43"
                      },
                      "title": "Since: cosmos-sdk 0.43"
                    }
                  },
                  "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
                }
              },
              "description": "QueryVoteResponse is the response type for the Query/Vote RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "voter",
            "description": "voter defines the oter address for the proposals.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/mint/v1beta1/annual_provisions": {
      "get": {
        "summary": "AnnualProvisions current minting annual provisions value.",
        "operationId": "AnnualProvisions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "annual_provisions": {
                  "type": "string",
                  "format": "byte",
                  "description": "annual_provisions is the current minting annual provisions value."
                }
              },
              "description": "QueryAnnualProvisionsResponse is the response type for the\nQuery/AnnualProvisions RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/mint/v1beta1/inflation": {
      "get": {
        "summary": "Inflation returns the current minting inflation value.",
        "operationId": "Inflation",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "inflation": {
                  "type": "string",
                  "format": "byte",
                  "description": "inflation is the current minting inflation value."
                }
              },
              "description": "QueryInflationResponse is the response type for the Query/Inflation RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/mint/v1beta1/params": {
      "get": {
        "summary": "Params returns the total set of minting parameters.",
        "operationId": "MintParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params defines the parameters of the module.",
                  "type": "object",
                  "properties": {
                    "mint_denom": {
                      "type": "string",
                      "title": "type of coin to mint"
                    },
                    "inflation_rate_change": {
                      "type": "string",
                      "title": "maximum annual change in inflation rate"
                    },
                    "inflation_max": {
                      "type": "string",
                      "title": "maximum inflation rate"
                    },
                    "inflation_min": {
                      "type": "string",
                      "title": "minimum inflation rate"
                    },
                    "goal_bonded": {
                      "type": "string",
                      "title": "goal of percent bonded atoms"
                    },
                    "blocks_per_year": {
                      "type": "string",
                      "format": "uint64",
                      "title": "expected blocks per year"
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/params/v1beta1/params": {
      "get": {
        "summary": "Params queries a specific parameter of a module, given its subspace and\nkey.",
        "operationId": "Params",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "param": {
                  "description": "param defines the queried parameter.",
                  "type": "object",
                  "properties": {
                    "subspace": {
                      "type": "string"
                    },
                    "key": {
                      "type": "string"
                    },
                    "value": {
                      "type": "string"
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "subspace",
            "description": "subspace defines the module to query the parameter for.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "key",
            "description": "key defines the key of the parameter in the subspace.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/slashing/v1beta1/params": {
      "get": {
        "summary": "Params queries the parameters of slashing module",
        "operationId": "SlashingParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "type": "object",
                  "properties": {
                    "signed_blocks_window": {
                      "type": "string",
                      "format": "int64"
                    },
                    "min_signed_per_window": {
                      "type": "string",
                      "format": "byte"
                    },
                    "downtime_jail_duration": {
                      "type": "string"
                    },
                    "slash_fraction_double_sign": {
                      "type": "string",
                      "format": "byte"
                    },
                    "slash_fraction_downtime": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "description": "Params represents the parameters used for by the slashing module."
                }
              },
              "title": "QueryParamsResponse is the response type for the Query/Params RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/slashing/v1beta1/signing_infos": {
      "get": {
        "summary": "SigningInfos queries signing info of all validators",
        "operationId": "SigningInfos",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "info": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "address": {
                        "type": "string"
                      },
                      "start_height": {
                        "type": "string",
                        "format": "int64",
                        "title": "Height at which validator was first a candidate OR was unjailed"
                      },
                      "index_offset": {
                        "type": "string",
                        "format": "int64",
                        "description": "Index which is incremented each time the validator was a bonded\nin a block and may have signed a precommit or not. This in conjunction with the\n`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`."
                      },
                      "jailed_until": {
                        "type": "string",
                        "format": "date-time",
                        "description": "Timestamp until which the validator is jailed due to liveness downtime."
                      },
                      "tombstoned": {
                        "type": "boolean",
                        "format": "boolean",
                        "description": "Whether or not a validator has been tombstoned (killed out of validator set). It is set\nonce the validator commits an equivocation or for any other configured misbehiavor."
                      },
                      "missed_blocks_counter": {
                        "type": "string",
                        "format": "int64",
                        "description": "A counter kept to avoid unnecessary array reads.\nNote that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`."
                      }
                    },
                    "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their\nliveness activity."
                  },
                  "title": "info is the signing info of all validators"
                },
                "pagination": {
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                }
              },
              "title": "QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC\nmethod"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/slashing/v1beta1/signing_infos/{cons_address}": {
      "get": {
        "summary": "SigningInfo queries the signing info of given cons address",
        "operationId": "SigningInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "val_signing_info": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string"
                    },
                    "start_height": {
                      "type": "string",
                      "format": "int64",
                      "title": "Height at which validator was first a candidate OR was unjailed"
                    },
                    "index_offset": {
                      "type": "string",
                      "format": "int64",
                      "description": "Index which is incremented each time the validator was a bonded\nin a block and may have signed a precommit or not. This in conjunction with the\n`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`."
                    },
                    "jailed_until": {
                      "type": "string",
                      "format": "date-time",
                      "description": "Timestamp until which the validator is jailed due to liveness downtime."
                    },
                    "tombstoned": {
                      "type": "boolean",
                      "format": "boolean",
                      "description": "Whether or not a validator has been tombstoned (killed out of validator set). It is set\nonce the validator commits an equivocation or for any other configured misbehiavor."
                    },
                    "missed_blocks_counter": {
                      "type": "string",
                      "format": "int64",
                      "description": "A counter kept to avoid unnecessary array reads.\nNote that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`."
                    }
                  },
                  "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their\nliveness activity.",
                  "title": "val_signing_info is the signing info of requested val cons address"
                }
              },
              "title": "QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC\nmethod"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "cons_address",
            "description": "cons_address is the address to query signing info of",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/delegations/{delegator_addr}": {
      "get": {
        "summary": "DelegatorDelegations queries all delegations of a given delegator address.",
        "operationId": "DelegatorDelegations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "delegation_responses": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "delegation": {
                        "type": "object",
                        "properties": {
                          "delegator_address": {
                            "type": "string",
                            "description": "delegator_address is the bech32-encoded address of the delegator."
                          },
                          "validator_address": {
                            "type": "string",
                            "description": "validator_address is the bech32-encoded address of the validator."
                          },
                          "shares": {
                            "type": "string",
                            "description": "shares define the delegation shares received."
                          }
                        },
                        "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
                      },
                      "balance": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      }
                    },
                    "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses."
                  },
                  "description": "delegation_responses defines all the delegations' info of a delegator."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryDelegatorDelegationsResponse is response type for the\nQuery/DelegatorDelegations RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "delegator_addr",
            "description": "delegator_addr defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/delegators/{delegator_addr}/redelegations": {
      "get": {
        "summary": "Redelegations queries redelegations of given address.",
        "operationId": "Redelegations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "redelegation_responses": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "redelegation": {
                        "type": "object",
                        "properties": {
                          "delegator_address": {
                            "type": "string",
                            "description": "delegator_address is the bech32-encoded address of the delegator."
                          },
                          "validator_src_address": {
                            "type": "string",
                            "description": "validator_src_address is the validator redelegation source operator address."
                          },
                          "validator_dst_address": {
                            "type": "string",
                            "description": "validator_dst_address is the validator redelegation destination operator address."
                          },
                          "entries": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "creation_height": {
                                  "type": "string",
                                  "format": "int64",
                                  "description": "creation_height  defines the height which the redelegation took place."
                                },
                                "completion_time": {
                                  "type": "string",
                                  "format": "date-time",
                                  "description": "completion_time defines the unix time for redelegation completion."
                                },
                                "initial_balance": {
                                  "type": "string",
                                  "description": "initial_balance defines the initial balance when redelegation started."
                                },
                                "shares_dst": {
                                  "type": "string",
                                  "description": "shares_dst is the amount of destination-validator shares created by redelegation."
                                }
                              },
                              "description": "RedelegationEntry defines a redelegation object with relevant metadata."
                            },
                            "description": "entries are the redelegation entries."
                          }
                        },
                        "description": "Redelegation contains the list of a particular delegator's redelegating bonds\nfrom a particular source validator to a particular destination validator."
                      },
                      "entries": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "redelegation_entry": {
                              "type": "object",
                              "properties": {
                                "creation_height": {
                                  "type": "string",
                                  "format": "int64",
                                  "description": "creation_height  defines the height which the redelegation took place."
                                },
                                "completion_time": {
                                  "type": "string",
                                  "format": "date-time",
                                  "description": "completion_time defines the unix time for redelegation completion."
                                },
                                "initial_balance": {
                                  "type": "string",
                                  "description": "initial_balance defines the initial balance when redelegation started."
                                },
                                "shares_dst": {
                                  "type": "string",
                                  "description": "shares_dst is the amount of destination-validator shares created by redelegation."
                                }
                              },
                              "description": "RedelegationEntry defines a redelegation object with relevant metadata."
                            },
                            "balance": {
                              "type": "string"
                            }
                          },
                          "description": "RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\ncontains a balance in addition to shares which is more suitable for client\nresponses."
                        }
                      }
                    },
                    "description": "RedelegationResponse is equivalent to a Redelegation except that its entries\ncontain a balance in addition to shares which is more suitable for client\nresponses."
                  }
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryRedelegationsResponse is response type for the Query/Redelegations RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "delegator_addr",
            "description": "delegator_addr defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "src_validator_addr",
            "description": "src_validator_addr defines the validator address to redelegate from.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "dst_validator_addr",
            "description": "dst_validator_addr defines the validator address to redelegate to.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/delegators/{delegator_addr}/unbonding_delegations": {
      "get": {
        "summary": "DelegatorUnbondingDelegations queries all unbonding delegations of a given\ndelegator address.",
        "operationId": "DelegatorUnbondingDelegations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "unbonding_responses": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "delegator_address": {
                        "type": "string",
                        "description": "delegator_address is the bech32-encoded address of the delegator."
                      },
                      "validator_address": {
                        "type": "string",
                        "description": "validator_address is the bech32-encoded address of the validator."
                      },
                      "entries": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "creation_height": {
                              "type": "string",
                              "format": "int64",
                              "description": "creation_height is the height which the unbonding took place."
                            },
                            "completion_time": {
                              "type": "string",
                              "format": "date-time",
                              "description": "completion_time is the unix time for unbonding completion."
                            },
                            "initial_balance": {
                              "type": "string",
                              "description": "initial_balance defines the tokens initially scheduled to receive at completion."
                            },
                            "balance": {
                              "type": "string",
                              "description": "balance defines the tokens to receive at completion."
                            }
                          },
                          "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
                        },
                        "description": "entries are the unbonding delegation entries."
                      }
                    },
                    "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list."
                  }
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryUnbondingDelegatorDelegationsResponse is response type for the\nQuery/UnbondingDelegatorDelegations RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "delegator_addr",
            "description": "delegator_addr defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators": {
      "get": {
        "summary": "DelegatorValidators queries all validators info for given delegator\naddress.",
        "operationId": "StakingDelegatorValidators",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "validators": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "operator_address": {
                        "type": "string",
                        "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
                      },
                      "consensus_pubkey": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      },
                      "jailed": {
                        "type": "boolean",
                        "format": "boolean",
                        "description": "jailed defined whether the validator has been jailed from bonded status or not."
                      },
                      "status": {
                        "description": "status is the validator status (bonded/unbonding/unbonded).",
                        "type": "string",
                        "enum": [
                          "BOND_STATUS_UNSPECIFIED",
                          "BOND_STATUS_UNBONDED",
                          "BOND_STATUS_UNBONDING",
                          "BOND_STATUS_BONDED"
                        ],
                        "default": "BOND_STATUS_UNSPECIFIED"
                      },
                      "tokens": {
                        "type": "string",
                        "description": "tokens define the delegated tokens (incl. self-delegation)."
                      },
                      "delegator_shares": {
                        "type": "string",
                        "description": "delegator_shares defines total shares issued to a validator's delegators."
                      },
                      "description": {
                        "description": "description defines the description terms for the validator.",
                        "type": "object",
                        "properties": {
                          "moniker": {
                            "type": "string",
                            "description": "moniker defines a human-readable name for the validator."
                          },
                          "identity": {
                            "type": "string",
                            "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                          },
                          "website": {
                            "type": "string",
                            "description": "website defines an optional website link."
                          },
                          "security_contact": {
                            "type": "string",
                            "description": "security_contact defines an optional email for security contact."
                          },
                          "details": {
                            "type": "string",
                            "description": "details define other optional details."
                          }
                        }
                      },
                      "unbonding_height": {
                        "type": "string",
                        "format": "int64",
                        "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."
                      },
                      "unbonding_time": {
                        "type": "string",
                        "format": "date-time",
                        "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."
                      },
                      "commission": {
                        "description": "commission defines the commission parameters.",
                        "type": "object",
                        "properties": {
                          "commission_rates": {
                            "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                            "type": "object",
                            "properties": {
                              "rate": {
                                "type": "string",
                                "description": "rate is the commission rate charged to delegators, as a fraction."
                              },
                              "max_rate": {
                                "type": "string",
                                "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                              },
                              "max_change_rate": {
                                "type": "string",
                                "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                              }
                            }
                          },
                          "update_time": {
                            "type": "string",
                            "format": "date-time",
                            "description": "update_time is the last time the commission rate was changed."
                          }
                        }
                      },
                      "min_self_delegation": {
                        "type": "string",
                        "description": "min_self_delegation is the validator's self declared minimum self delegation."
                      }
                    },
                    "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
                  },
                  "description": "validators defines the the validators' info of a delegator."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryDelegatorValidatorsResponse is response type for the\nQuery/DelegatorValidators RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "delegator_addr",
            "description": "delegator_addr defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators/{validator_addr}": {
      "get": {
        "summary": "DelegatorValidator queries validator info for given delegator validator\npair.",
        "operationId": "DelegatorValidator",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "validator": {
                  "type": "object",
                  "properties": {
                    "operator_address": {
                      "type": "string",
                      "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
                    },
                    "consensus_pubkey": {
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "type": "string",
                          "format": "byte",
                          "description": "Must be a valid serialized protocol buffer of the above specified type."
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    },
                    "jailed": {
                      "type": "boolean",
                      "format": "boolean",
                      "description": "jailed defined whether the validator has been jailed from bonded status or not."
                    },
                    "status": {
                      "description": "status is the validator status (bonded/unbonding/unbonded).",
                      "type": "string",
                      "enum": [
                        "BOND_STATUS_UNSPECIFIED",
                        "BOND_STATUS_UNBONDED",
                        "BOND_STATUS_UNBONDING",
                        "BOND_STATUS_BONDED"
                      ],
                      "default": "BOND_STATUS_UNSPECIFIED"
                    },
                    "tokens": {
                      "type": "string",
                      "description": "tokens define the delegated tokens (incl. self-delegation)."
                    },
                    "delegator_shares": {
                      "type": "string",
                      "description": "delegator_shares defines total shares issued to a validator's delegators."
                    },
                    "description": {
                      "description": "description defines the description terms for the validator.",
                      "type": "object",
                      "properties": {
                        "moniker": {
                          "type": "string",
                          "description": "moniker defines a human-readable name for the validator."
                        },
                        "identity": {
                          "type": "string",
                          "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                        },
                        "website": {
                          "type": "string",
                          "description": "website defines an optional website link."
                        },
                        "security_contact": {
                          "type": "string",
                          "description": "security_contact defines an optional email for security contact."
                        },
                        "details": {
                          "type": "string",
                          "description": "details define other optional details."
                        }
                      }
                    },
                    "unbonding_height": {
                      "type": "string",
                      "format": "int64",
                      "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."
                    },
                    "unbonding_time": {
                      "type": "string",
                      "format": "date-time",
                      "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."
                    },
                    "commission": {
                      "description": "commission defines the commission parameters.",
                      "type": "object",
                      "properties": {
                        "commission_rates": {
                          "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                          "type": "object",
                          "properties": {
                            "rate": {
                              "type": "string",
                              "description": "rate is the commission rate charged to delegators, as a fraction."
                            },
                            "max_rate": {
                              "type": "string",
                              "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                            },
                            "max_change_rate": {
                              "type": "string",
                              "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                            }
                          }
                        },
                        "update_time": {
                          "type": "string",
                          "format": "date-time",
                          "description": "update_time is the last time the commission rate was changed."
                        }
                      }
                    },
                    "min_self_delegation": {
                      "type": "string",
                      "description": "min_self_delegation is the validator's self declared minimum self delegation."
                    }
                  },
                  "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
                }
              },
              "description": "QueryDelegatorValidatorResponse response type for the\nQuery/DelegatorValidator RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "delegator_addr",
            "description": "delegator_addr defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "validator_addr",
            "description": "validator_addr defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/historical_info/{height}": {
      "get": {
        "summary": "HistoricalInfo queries the historical info for given height.",
        "operationId": "HistoricalInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "hist": {
                  "description": "hist defines the historical info at the given height.",
                  "type": "object",
                  "properties": {
                    "header": {
                      "type": "object",
                      "properties": {
                        "version": {
                          "title": "basic block info",
                          "type": "object",
                          "properties": {
                            "block": {
                              "type": "string",
                              "format": "uint64"
                            },
                            "app": {
                              "type": "string",
                              "format": "uint64"
                            }
                          },
                          "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                        },
                        "chain_id": {
                          "type": "string"
                        },
                        "height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "time": {
                          "type": "string",
                          "format": "date-time"
                        },
                        "last_block_id": {
                          "title": "prev block info",
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            },
                            "part_set_header": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "hash": {
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "title": "PartsetHeader"
                            }
                          }
                        },
                        "last_commit_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "hashes of block data"
                        },
                        "data_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "validators_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "hashes from the app output from the prev block"
                        },
                        "next_validators_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "consensus_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "app_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "last_results_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "evidence_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "consensus info"
                        },
                        "proposer_address": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "description": "Header defines the structure of a Tendermint block header."
                    },
                    "valset": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "operator_address": {
                            "type": "string",
                            "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
                          },
                          "consensus_pubkey": {
                            "type": "object",
                            "properties": {
                              "type_url": {
                                "type": "string",
                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                              },
                              "value": {
                                "type": "string",
                                "format": "byte",
                                "description": "Must be a valid serialized protocol buffer of the above specified type."
                              }
                            },
                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                          },
                          "jailed": {
                            "type": "boolean",
                            "format": "boolean",
                            "description": "jailed defined whether the validator has been jailed from bonded status or not."
                          },
                          "status": {
                            "description": "status is the validator status (bonded/unbonding/unbonded).",
                            "type": "string",
                            "enum": [
                              "BOND_STATUS_UNSPECIFIED",
                              "BOND_STATUS_UNBONDED",
                              "BOND_STATUS_UNBONDING",
                              "BOND_STATUS_BONDED"
                            ],
                            "default": "BOND_STATUS_UNSPECIFIED"
                          },
                          "tokens": {
                            "type": "string",
                            "description": "tokens define the delegated tokens (incl. self-delegation)."
                          },
                          "delegator_shares": {
                            "type": "string",
                            "description": "delegator_shares defines total shares issued to a validator's delegators."
                          },
                          "description": {
                            "description": "description defines the description terms for the validator.",
                            "type": "object",
                            "properties": {
                              "moniker": {
                                "type": "string",
                                "description": "moniker defines a human-readable name for the validator."
                              },
                              "identity": {
                                "type": "string",
                                "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                              },
                              "website": {
                                "type": "string",
                                "description": "website defines an optional website link."
                              },
                              "security_contact": {
                                "type": "string",
                                "description": "security_contact defines an optional email for security contact."
                              },
                              "details": {
                                "type": "string",
                                "description": "details define other optional details."
                              }
                            }
                          },
                          "unbonding_height": {
                            "type": "string",
                            "format": "int64",
                            "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."
                          },
                          "unbonding_time": {
                            "type": "string",
                            "format": "date-time",
                            "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."
                          },
                          "commission": {
                            "description": "commission defines the commission parameters.",
                            "type": "object",
                            "properties": {
                              "commission_rates": {
                                "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                                "type": "object",
                                "properties": {
                                  "rate": {
                                    "type": "string",
                                    "description": "rate is the commission rate charged to delegators, as a fraction."
                                  },
                                  "max_rate": {
                                    "type": "string",
                                    "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                                  },
                                  "max_change_rate": {
                                    "type": "string",
                                    "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                                  }
                                }
                              },
                              "update_time": {
                                "type": "string",
                                "format": "date-time",
                                "description": "update_time is the last time the commission rate was changed."
                              }
                            }
                          },
                          "min_self_delegation": {
                            "type": "string",
                            "description": "min_self_delegation is the validator's self declared minimum self delegation."
                          }
                        },
                        "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
                      }
                    }
                  }
                }
              },
              "description": "QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "height",
            "description": "height defines at which height to query the historical info.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/params": {
      "get": {
        "summary": "Parameters queries the staking parameters.",
        "operationId": "StakingParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params holds all the parameters of this module.",
                  "type": "object",
                  "properties": {
                    "unbonding_time": {
                      "type": "string",
                      "description": "unbonding_time is the time duration of unbonding."
                    },
                    "max_validators": {
                      "type": "integer",
                      "format": "int64",
                      "description": "max_validators is the maximum number of validators."
                    },
                    "max_entries": {
                      "type": "integer",
                      "format": "int64",
                      "description": "max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio)."
                    },
                    "historical_entries": {
                      "type": "integer",
                      "format": "int64",
                      "description": "historical_entries is the number of historical entries to persist."
                    },
                    "bond_denom": {
                      "type": "string",
                      "description": "bond_denom defines the bondable coin denomination."
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/pool": {
      "get": {
        "summary": "Pool queries the pool info.",
        "operationId": "Pool",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "pool": {
                  "description": "pool defines the pool info.",
                  "type": "object",
                  "properties": {
                    "not_bonded_tokens": {
                      "type": "string"
                    },
                    "bonded_tokens": {
                      "type": "string"
                    }
                  }
                }
              },
              "description": "QueryPoolResponse is response type for the Query/Pool RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/validators": {
      "get": {
        "summary": "Validators queries all validators that match the given status.",
        "operationId": "Validators",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "validators": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "operator_address": {
                        "type": "string",
                        "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
                      },
                      "consensus_pubkey": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      },
                      "jailed": {
                        "type": "boolean",
                        "format": "boolean",
                        "description": "jailed defined whether the validator has been jailed from bonded status or not."
                      },
                      "status": {
                        "description": "status is the validator status (bonded/unbonding/unbonded).",
                        "type": "string",
                        "enum": [
                          "BOND_STATUS_UNSPECIFIED",
                          "BOND_STATUS_UNBONDED",
                          "BOND_STATUS_UNBONDING",
                          "BOND_STATUS_BONDED"
                        ],
                        "default": "BOND_STATUS_UNSPECIFIED"
                      },
                      "tokens": {
                        "type": "string",
                        "description": "tokens define the delegated tokens (incl. self-delegation)."
                      },
                      "delegator_shares": {
                        "type": "string",
                        "description": "delegator_shares defines total shares issued to a validator's delegators."
                      },
                      "description": {
                        "description": "description defines the description terms for the validator.",
                        "type": "object",
                        "properties": {
                          "moniker": {
                            "type": "string",
                            "description": "moniker defines a human-readable name for the validator."
                          },
                          "identity": {
                            "type": "string",
                            "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                          },
                          "website": {
                            "type": "string",
                            "description": "website defines an optional website link."
                          },
                          "security_contact": {
                            "type": "string",
                            "description": "security_contact defines an optional email for security contact."
                          },
                          "details": {
                            "type": "string",
                            "description": "details define other optional details."
                          }
                        }
                      },
                      "unbonding_height": {
                        "type": "string",
                        "format": "int64",
                        "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."
                      },
                      "unbonding_time": {
                        "type": "string",
                        "format": "date-time",
                        "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."
                      },
                      "commission": {
                        "description": "commission defines the commission parameters.",
                        "type": "object",
                        "properties": {
                          "commission_rates": {
                            "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                            "type": "object",
                            "properties": {
                              "rate": {
                                "type": "string",
                                "description": "rate is the commission rate charged to delegators, as a fraction."
                              },
                              "max_rate": {
                                "type": "string",
                                "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                              },
                              "max_change_rate": {
                                "type": "string",
                                "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                              }
                            }
                          },
                          "update_time": {
                            "type": "string",
                            "format": "date-time",
                            "description": "update_time is the last time the commission rate was changed."
                          }
                        }
                      },
                      "min_self_delegation": {
                        "type": "string",
                        "description": "min_self_delegation is the validator's self declared minimum self delegation."
                      }
                    },
                    "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
                  },
                  "description": "validators contains all the queried validators."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "title": "QueryValidatorsResponse is response type for the Query/Validators RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "status",
            "description": "status enables to query for validators matching a given status.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/validators/{validator_addr}": {
      "get": {
        "summary": "Validator queries validator info for given validator address.",
        "operationId": "Validator",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "validator": {
                  "type": "object",
                  "properties": {
                    "operator_address": {
                      "type": "string",
                      "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
                    },
                    "consensus_pubkey": {
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "type": "string",
                          "format": "byte",
                          "description": "Must be a valid serialized protocol buffer of the above specified type."
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    },
                    "jailed": {
                      "type": "boolean",
                      "format": "boolean",
                      "description": "jailed defined whether the validator has been jailed from bonded status or not."
                    },
                    "status": {
                      "description": "status is the validator status (bonded/unbonding/unbonded).",
                      "type": "string",
                      "enum": [
                        "BOND_STATUS_UNSPECIFIED",
                        "BOND_STATUS_UNBONDED",
                        "BOND_STATUS_UNBONDING",
                        "BOND_STATUS_BONDED"
                      ],
                      "default": "BOND_STATUS_UNSPECIFIED"
                    },
                    "tokens": {
                      "type": "string",
                      "description": "tokens define the delegated tokens (incl. self-delegation)."
                    },
                    "delegator_shares": {
                      "type": "string",
                      "description": "delegator_shares defines total shares issued to a validator's delegators."
                    },
                    "description": {
                      "description": "description defines the description terms for the validator.",
                      "type": "object",
                      "properties": {
                        "moniker": {
                          "type": "string",
                          "description": "moniker defines a human-readable name for the validator."
                        },
                        "identity": {
                          "type": "string",
                          "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                        },
                        "website": {
                          "type": "string",
                          "description": "website defines an optional website link."
                        },
                        "security_contact": {
                          "type": "string",
                          "description": "security_contact defines an optional email for security contact."
                        },
                        "details": {
                          "type": "string",
                          "description": "details define other optional details."
                        }
                      }
                    },
                    "unbonding_height": {
                      "type": "string",
                      "format": "int64",
                      "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."
                    },
                    "unbonding_time": {
                      "type": "string",
                      "format": "date-time",
                      "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."
                    },
                    "commission": {
                      "description": "commission defines the commission parameters.",
                      "type": "object",
                      "properties": {
                        "commission_rates": {
                          "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                          "type": "object",
                          "properties": {
                            "rate": {
                              "type": "string",
                              "description": "rate is the commission rate charged to delegators, as a fraction."
                            },
                            "max_rate": {
                              "type": "string",
                              "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                            },
                            "max_change_rate": {
                              "type": "string",
                              "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                            }
                          }
                        },
                        "update_time": {
                          "type": "string",
                          "format": "date-time",
                          "description": "update_time is the last time the commission rate was changed."
                        }
                      }
                    },
                    "min_self_delegation": {
                      "type": "string",
                      "description": "min_self_delegation is the validator's self declared minimum self delegation."
                    }
                  },
                  "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
                }
              },
              "title": "QueryValidatorResponse is response type for the Query/Validator RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "validator_addr",
            "description": "validator_addr defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations": {
      "get": {
        "summary": "ValidatorDelegations queries delegate info for given validator.",
        "operationId": "ValidatorDelegations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "delegation_responses": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "delegation": {
                        "type": "object",
                        "properties": {
                          "delegator_address": {
                            "type": "string",
                            "description": "delegator_address is the bech32-encoded address of the delegator."
                          },
                          "validator_address": {
                            "type": "string",
                            "description": "validator_address is the bech32-encoded address of the validator."
                          },
                          "shares": {
                            "type": "string",
                            "description": "shares define the delegation shares received."
                          }
                        },
                        "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
                      },
                      "balance": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      }
                    },
                    "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses."
                  }
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "title": "QueryValidatorDelegationsResponse is response type for the\nQuery/ValidatorDelegations RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "validator_addr",
            "description": "validator_addr defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}": {
      "get": {
        "summary": "Delegation queries delegate info for given validator delegator pair.",
        "operationId": "Delegation",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "delegation_response": {
                  "type": "object",
                  "properties": {
                    "delegation": {
                      "type": "object",
                      "properties": {
                        "delegator_address": {
                          "type": "string",
                          "description": "delegator_address is the bech32-encoded address of the delegator."
                        },
                        "validator_address": {
                          "type": "string",
                          "description": "validator_address is the bech32-encoded address of the validator."
                        },
                        "shares": {
                          "type": "string",
                          "description": "shares define the delegation shares received."
                        }
                      },
                      "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
                    },
                    "balance": {
                      "type": "object",
                      "properties": {
                        "denom": {
                          "type": "string"
                        },
                        "amount": {
                          "type": "string"
                        }
                      },
                      "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                    }
                  },
                  "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses."
                }
              },
              "description": "QueryDelegationResponse is response type for the Query/Delegation RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "validator_addr",
            "description": "validator_addr defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "delegator_addr",
            "description": "delegator_addr defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}/unbonding_delegation": {
      "get": {
        "summary": "UnbondingDelegation queries unbonding info for given validator delegator\npair.",
        "operationId": "UnbondingDelegation",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "unbond": {
                  "type": "object",
                  "properties": {
                    "delegator_address": {
                      "type": "string",
                      "description": "delegator_address is the bech32-encoded address of the delegator."
                    },
                    "validator_address": {
                      "type": "string",
                      "description": "validator_address is the bech32-encoded address of the validator."
                    },
                    "entries": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "creation_height": {
                            "type": "string",
                            "format": "int64",
                            "description": "creation_height is the height which the unbonding took place."
                          },
                          "completion_time": {
                            "type": "string",
                            "format": "date-time",
                            "description": "completion_time is the unix time for unbonding completion."
                          },
                          "initial_balance": {
                            "type": "string",
                            "description": "initial_balance defines the tokens initially scheduled to receive at completion."
                          },
                          "balance": {
                            "type": "string",
                            "description": "balance defines the tokens to receive at completion."
                          }
                        },
                        "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
                      },
                      "description": "entries are the unbonding delegation entries."
                    }
                  },
                  "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list."
                }
              },
              "description": "QueryDelegationResponse is response type for the Query/UnbondingDelegation\nRPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "validator_addr",
            "description": "validator_addr defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "delegator_addr",
            "description": "delegator_addr defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/validators/{validator_addr}/unbonding_delegations": {
      "get": {
        "summary": "ValidatorUnbondingDelegations queries unbonding delegations of a validator.",
        "operationId": "ValidatorUnbondingDelegations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "unbonding_responses": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "delegator_address": {
                        "type": "string",
                        "description": "delegator_address is the bech32-encoded address of the delegator."
                      },
                      "validator_address": {
                        "type": "string",
                        "description": "validator_address is the bech32-encoded address of the validator."
                      },
                      "entries": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "creation_height": {
                              "type": "string",
                              "format": "int64",
                              "description": "creation_height is the height which the unbonding took place."
                            },
                            "completion_time": {
                              "type": "string",
                              "format": "date-time",
                              "description": "completion_time is the unix time for unbonding completion."
                            },
                            "initial_balance": {
                              "type": "string",
                              "description": "initial_balance defines the tokens initially scheduled to receive at completion."
                            },
                            "balance": {
                              "type": "string",
                              "description": "balance defines the tokens to receive at completion."
                            }
                          },
                          "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
                        },
                        "description": "entries are the unbonding delegation entries."
                      }
                    },
                    "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list."
                  }
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryValidatorUnbondingDelegationsResponse is response type for the\nQuery/ValidatorUnbondingDelegations RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "validator_addr",
            "description": "validator_addr defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/tx/v1beta1/simulate": {
      "post": {
        "summary": "Simulate simulates executing a transaction for estimating gas usage.",
        "operationId": "Simulate",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "gas_info": {
                  "description": "gas_info is the information about gas used in the simulation.",
                  "type": "object",
                  "properties": {
                    "gas_wanted": {
                      "type": "string",
                      "format": "uint64",
                      "description": "GasWanted is the maximum units of work we allow this tx to perform."
                    },
                    "gas_used": {
                      "type": "string",
                      "format": "uint64",
                      "description": "GasUsed is the amount of gas actually consumed."
                    }
                  }
                },
                "result": {
                  "description": "result is the result of the simulation.",
                  "type": "object",
                  "properties": {
                    "data": {
                      "type": "string",
                      "format": "byte",
                      "description": "Data is any data returned from message or handler execution. It MUST be\nlength prefixed in order to separate data from multiple message executions."
                    },
                    "log": {
                      "type": "string",
                      "description": "Log contains the log information from message or handler execution."
                    },
                    "events": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string"
                          },
                          "attributes": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "key": {
                                  "type": "string",
                                  "format": "byte"
                                },
                                "value": {
                                  "type": "string",
                                  "format": "byte"
                                },
                                "index": {
                                  "type": "boolean",
                                  "format": "boolean"
                                }
                              },
                              "description": "EventAttribute is a single key-value pair, associated with an event."
                            }
                          }
                        },
                        "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events."
                      },
                      "description": "Events contains a slice of Event objects that were emitted during message\nor handler execution."
                    }
                  }
                }
              },
              "description": "SimulateResponse is the response type for the\nService.SimulateRPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.SimulateRequest"
            }
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/tx/v1beta1/txs": {
      "get": {
        "summary": "GetTxsEvent fetches txs by event.",
        "operationId": "GetTxsEvent",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.GetTxsEventResponse"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "events",
            "description": "events is the list of transaction event type.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "order_by",
            "description": " - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.\n - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order\n - ORDER_BY_DESC: ORDER_BY_DESC defines descending order",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "ORDER_BY_UNSPECIFIED",
              "ORDER_BY_ASC",
              "ORDER_BY_DESC"
            ],
            "default": "ORDER_BY_UNSPECIFIED"
          }
        ],
        "tags": [
          "Service"
        ]
      },
      "post": {
        "summary": "BroadcastTx broadcast transaction.",
        "operationId": "BroadcastTx",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "tx_response": {
                  "type": "object",
                  "properties": {
                    "height": {
                      "type": "string",
                      "format": "int64",
                      "title": "The block height"
                    },
                    "txhash": {
                      "type": "string",
                      "description": "The transaction hash."
                    },
                    "codespace": {
                      "type": "string",
                      "title": "Namespace for the Code"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int64",
                      "description": "Response code."
                    },
                    "data": {
                      "type": "string",
                      "description": "Result bytes, if any."
                    },
                    "raw_log": {
                      "type": "string",
                      "description": "The output of the application's logger (raw string). May be\nnon-deterministic."
                    },
                    "logs": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "msg_index": {
                            "type": "integer",
                            "format": "int64"
                          },
                          "log": {
                            "type": "string"
                          },
                          "events": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "type": {
                                  "type": "string"
                                },
                                "attributes": {
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "properties": {
                                      "key": {
                                        "type": "string"
                                      },
                                      "value": {
                                        "type": "string"
                                      }
                                    },
                                    "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
                                  }
                                }
                              },
                              "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
                            },
                            "description": "Events contains a slice of Event objects that were emitted during some\nexecution."
                          }
                        },
                        "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log."
                      },
                      "description": "The output of the application's logger (typed). May be non-deterministic."
                    },
                    "info": {
                      "type": "string",
                      "description": "Additional information. May be non-deterministic."
                    },
                    "gas_wanted": {
                      "type": "string",
                      "format": "int64",
                      "description": "Amount of gas requested for transaction."
                    },
                    "gas_used": {
                      "type": "string",
                      "format": "int64",
                      "description": "Amount of gas consumed by transaction."
                    },
                    "tx": {
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "type": "string",
                          "format": "byte",
                          "description": "Must be a valid serialized protocol buffer of the above specified type."
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    },
                    "timestamp": {
                      "type": "string",
                      "description": "Time of the previous block. For heights > 1, it's the weighted median of\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\nit's genesis time."
                    },
                    "events": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string"
                          },
                          "attributes": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "key": {
                                  "type": "string",
                                  "format": "byte"
                                },
                                "value": {
                                  "type": "string",
                                  "format": "byte"
                                },
                                "index": {
                                  "type": "boolean",
                                  "format": "boolean"
                                }
                              },
                              "description": "EventAttribute is a single key-value pair, associated with an event."
                            }
                          }
                        },
                        "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events."
                      },
                      "description": "Events defines all the events emitted by processing a transaction. Note,\nthese events include those emitted by processing all the messages and those\nemitted from the ante handler. Whereas Logs contains the events, with\nadditional metadata, emitted only by processing the messages.\n\nSince: cosmos-sdk 0.42.11, 0.44.5, 0.45"
                    }
                  },
                  "description": "TxResponse defines a structure containing relevant tx data and metadata. The\ntags are stringified and the log is JSON decoded."
                }
              },
              "description": "BroadcastTxResponse is the response type for the\nService.BroadcastTx method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "tx_bytes": {
                  "type": "string",
                  "format": "byte",
                  "description": "tx_bytes is the raw transaction."
                },
                "mode": {
                  "type": "string",
                  "enum": [
                    "BROADCAST_MODE_UNSPECIFIED",
                    "BROADCAST_MODE_BLOCK",
                    "BROADCAST_MODE_SYNC",
                    "BROADCAST_MODE_ASYNC"
                  ],
                  "default": "BROADCAST_MODE_UNSPECIFIED",
                  "description": "BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.\n\n - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering\n - BROADCAST_MODE_BLOCK: BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for\nthe tx to be committed in a block.\n - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for\na CheckTx execution response only.\n - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns\nimmediately."
                }
              },
              "description": "BroadcastTxRequest is the request type for the Service.BroadcastTxRequest\nRPC method."
            }
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/tx/v1beta1/txs/{hash}": {
      "get": {
        "summary": "GetTx fetches a tx by hash.",
        "operationId": "GetTx",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.GetTxResponse"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "hash",
            "description": "hash is the tx hash to query, encoded as a hex string.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/upgrade/v1beta1/applied_plan/{name}": {
      "get": {
        "summary": "AppliedPlan queries a previously applied upgrade plan by its name.",
        "operationId": "AppliedPlan",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "height": {
                  "type": "string",
                  "format": "int64",
                  "description": "height is the block height at which the plan was applied."
                }
              },
              "description": "QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "name",
            "description": "name is the name of the applied plan to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/upgrade/v1beta1/current_plan": {
      "get": {
        "summary": "CurrentPlan queries the current upgrade plan.",
        "operationId": "CurrentPlan",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "plan": {
                  "description": "plan is the current upgrade plan.",
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "Sets the name for the upgrade. This name will be used by the upgraded\nversion of the software to apply any special \"on-upgrade\" commands during\nthe first BeginBlock method after the upgrade is applied. It is also used\nto detect whether a software version can handle a given upgrade. If no\nupgrade handler with this name has been set in the software, it will be\nassumed that the software is out-of-date when the upgrade Time or Height is\nreached and the software will exit."
                    },
                    "time": {
                      "type": "string",
                      "format": "date-time",
                      "description": "Deprecated: Time based upgrades have been deprecated. Time based upgrade logic\nhas been removed from the SDK.\nIf this field is not empty, an error will be thrown."
                    },
                    "height": {
                      "type": "string",
                      "format": "int64",
                      "description": "The height at which the upgrade must be performed.\nOnly used if Time is not set."
                    },
                    "info": {
                      "type": "string",
                      "title": "Any application specific upgrade info to be included on-chain\nsuch as a git commit that validators could automatically upgrade to"
                    },
                    "upgraded_client_state": {
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "type": "string",
                          "format": "byte",
                          "description": "Must be a valid serialized protocol buffer of the above specified type."
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    }
                  }
                }
              },
              "description": "QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/upgrade/v1beta1/module_versions": {
      "get": {
        "summary": "ModuleVersions queries the list of module versions from state.",
        "description": "Since: cosmos-sdk 0.43",
        "operationId": "ModuleVersions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "module_versions": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "name": {
                        "type": "string",
                        "title": "name of the app module"
                      },
                      "version": {
                        "type": "string",
                        "format": "uint64",
                        "title": "consensus version of the app module"
                      }
                    },
                    "description": "ModuleVersion specifies a module and its consensus version.\n\nSince: cosmos-sdk 0.43"
                  },
                  "description": "module_versions is a list of module names with their consensus versions."
                }
              },
              "description": "QueryModuleVersionsResponse is the response type for the Query/ModuleVersions\nRPC method.\n\nSince: cosmos-sdk 0.43"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "module_name",
            "description": "module_name is a field to query a specific module\nconsensus version from state. Leaving this empty will\nfetch the full list of module versions from state.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/upgrade/v1beta1/upgraded_consensus_state/{last_height}": {
      "get": {
        "summary": "UpgradedConsensusState queries the consensus state that will serve\nas a trusted kernel for the next version of this chain. It will only be\nstored at the last height of this chain.\nUpgradedConsensusState RPC not supported with legacy querier\nThis rpc is deprecated now that IBC has its own replacement\n(https://github.com/cosmos/ibc-go/blob/2c880a22e9f9cc75f62b527ca94aa75ce1106001/proto/ibc/core/client/v1/query.proto#L54)",
        "operationId": "UpgradedConsensusState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "upgraded_consensus_state": {
                  "type": "string",
                  "format": "byte",
                  "title": "Since: cosmos-sdk 0.43"
                }
              },
              "description": "QueryUpgradedConsensusStateResponse is the response type for the Query/UpgradedConsensusState\nRPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "last_height",
            "description": "last height of the current chain must be sent in request\nas this is the height under which next consensus state is stored",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/tx/v1beta1/compute_tax": {
      "post": {
        "summary": "EstimateFee simulates executing a transaction for estimating gas usage.",
        "operationId": "ComputeTax",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "tax_amount": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                  },
                  "title": "amount is the amount of coins to be paid as a fee"
                }
              },
              "description": "ComputeTaxResponse is the response type for the Service.ComputeTax\nRPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/terra.tx.v1beta1.ComputeTaxRequest"
            }
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/terra/market/v1beta1/params": {
      "get": {
        "summary": "Params queries all parameters.",
        "operationId": "MarketParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params defines the parameters of the module.",
                  "type": "object",
                  "properties": {
                    "base_pool": {
                      "type": "string",
                      "format": "byte"
                    },
                    "pool_recovery_period": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "min_stability_spread": {
                      "type": "string",
                      "format": "byte"
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/market/v1beta1/swap": {
      "get": {
        "summary": "Swap returns simulated swap amount.",
        "operationId": "Swap",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "return_coin": {
                  "description": "return_coin defines the coin returned as a result of the swap simulation.",
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  }
                }
              },
              "description": "QuerySwapResponse is the response type for the Query/Swap RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "offer_coin",
            "description": "offer_coin defines the coin being offered (i.e. 1000000uluna).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "ask_denom",
            "description": "ask_denom defines the denom of the coin to swap to.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/market/v1beta1/terra_pool_delta": {
      "get": {
        "summary": "TerraPoolDelta returns terra_pool_delta amount.",
        "operationId": "TerraPoolDelta",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "terra_pool_delta": {
                  "type": "string",
                  "format": "byte",
                  "title": "terra_pool_delta defines the gap between the TerraPool and the TerraBasePool"
                }
              },
              "description": "QueryTerraPoolDeltaResponse is the response type for the Query/TerraPoolDelta RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/oracle/v1beta1/denoms/actives": {
      "get": {
        "summary": "Actives returns all active denoms",
        "operationId": "Actives",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "actives": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "actives defines a list of the denomination which oracle prices aggreed upon."
                }
              },
              "description": "QueryActivesResponse is response type for the\nQuery/Actives RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/oracle/v1beta1/denoms/exchange_rates": {
      "get": {
        "summary": "ExchangeRates returns exchange rates of all denoms",
        "operationId": "ExchangeRates",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "exchange_rates": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                  },
                  "description": "exchange_rates defines a list of the exchange rate for all whitelisted denoms."
                }
              },
              "description": "QueryExchangeRatesResponse is response type for the\nQuery/ExchangeRates RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/oracle/v1beta1/denoms/tobin_taxes": {
      "get": {
        "summary": "TobinTaxes returns tobin taxes of all denoms",
        "operationId": "TobinTaxes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "tobin_taxes": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "tobin_tax": {
                        "type": "string"
                      }
                    },
                    "title": "Denom - the object to hold configurations of each denom"
                  },
                  "title": "tobin_taxes defines a list of the tobin tax of all whitelisted denoms"
                }
              },
              "description": "QueryTobinTaxesResponse is response type for the\nQuery/TobinTaxes RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/oracle/v1beta1/denoms/vote_targets": {
      "get": {
        "summary": "VoteTargets returns all vote target denoms",
        "operationId": "VoteTargets",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "vote_targets": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "vote_targets defines a list of the denomination in which everyone\nshould vote in the current vote period."
                }
              },
              "description": "QueryVoteTargetsResponse is response type for the\nQuery/VoteTargets RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/oracle/v1beta1/denoms/{denom}/exchange_rate": {
      "get": {
        "summary": "ExchangeRate returns exchange rate of a denom",
        "operationId": "ExchangeRate",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "exchange_rate": {
                  "type": "string",
                  "title": "exchange_rate defines the exchange rate of Luna denominated in various Terra"
                }
              },
              "description": "QueryExchangeRateResponse is response type for the\nQuery/ExchangeRate RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "denom",
            "description": "denom defines the denomination to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/oracle/v1beta1/denoms/{denom}/tobin_tax": {
      "get": {
        "summary": "TobinTax returns tobin tax of a denom",
        "operationId": "TobinTax",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "tobin_tax": {
                  "type": "string",
                  "title": "tobin_taxe defines the tobin tax of a denom"
                }
              },
              "description": "QueryTobinTaxResponse is response type for the\nQuery/TobinTax RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "denom",
            "description": "denom defines the denomination to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/oracle/v1beta1/params": {
      "get": {
        "summary": "Params queries all parameters.",
        "operationId": "OracleParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params defines the parameters of the module.",
                  "type": "object",
                  "properties": {
                    "vote_period": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "vote_threshold": {
                      "type": "string"
                    },
                    "reward_band": {
                      "type": "string"
                    },
                    "reward_distribution_window": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "whitelist": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "name": {
                            "type": "string"
                          },
                          "tobin_tax": {
                            "type": "string"
                          }
                        },
                        "title": "Denom - the object to hold configurations of each denom"
                      }
                    },
                    "slash_fraction": {
                      "type": "string"
                    },
                    "slash_window": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "min_valid_per_window": {
                      "type": "string"
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/oracle/v1beta1/valdiators/{validator_addr}/aggregate_vote": {
      "get": {
        "summary": "AggregateVote returns an aggregate vote of a validator",
        "operationId": "AggregateVote",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "aggregate_vote": {
                  "title": "aggregate_vote defines oracle aggregate vote submitted by a validator in the current vote period",
                  "type": "object",
                  "properties": {
                    "exchange_rate_tuples": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "exchange_rate": {
                            "type": "string"
                          }
                        },
                        "title": "ExchangeRateTuple - struct to store interpreted exchange rates data to store"
                      }
                    },
                    "voter": {
                      "type": "string"
                    }
                  },
                  "description": "MsgAggregateExchangeRateVote - struct for voting on\nthe exchange rates of Luna denominated in various Terra assets."
                }
              },
              "description": "QueryAggregateVoteResponse is response type for the\nQuery/AggregateVote RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "validator_addr",
            "description": "validator defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/oracle/v1beta1/validators/aggregate_prevotes": {
      "get": {
        "summary": "AggregatePrevotes returns aggregate prevotes of all validators",
        "operationId": "AggregatePrevotes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "aggregate_prevotes": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "hash": {
                        "type": "string"
                      },
                      "voter": {
                        "type": "string"
                      },
                      "submit_block": {
                        "type": "string",
                        "format": "uint64"
                      }
                    },
                    "title": "struct for aggregate prevoting on the ExchangeRateVote.\nThe purpose of aggregate prevote is to hide vote exchange rates with hash\nwhich is formatted as hex string in SHA256(\"{salt}:{exchange rate}{denom},...,{exchange rate}{denom}:{voter}\")"
                  },
                  "title": "aggregate_prevotes defines all oracle aggregate prevotes submitted in the current vote period"
                }
              },
              "description": "QueryAggregatePrevotesResponse is response type for the\nQuery/AggregatePrevotes RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/oracle/v1beta1/validators/aggregate_votes": {
      "get": {
        "summary": "AggregateVotes returns aggregate votes of all validators",
        "operationId": "AggregateVotes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "aggregate_votes": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "exchange_rate_tuples": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "denom": {
                              "type": "string"
                            },
                            "exchange_rate": {
                              "type": "string"
                            }
                          },
                          "title": "ExchangeRateTuple - struct to store interpreted exchange rates data to store"
                        }
                      },
                      "voter": {
                        "type": "string"
                      }
                    },
                    "description": "MsgAggregateExchangeRateVote - struct for voting on\nthe exchange rates of Luna denominated in various Terra assets."
                  },
                  "title": "aggregate_votes defines all oracle aggregate votes submitted in the current vote period"
                }
              },
              "description": "QueryAggregateVotesResponse is response type for the\nQuery/AggregateVotes RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/oracle/v1beta1/validators/{validator_addr}/aggregate_prevote": {
      "get": {
        "summary": "AggregatePrevote returns an aggregate prevote of a validator",
        "operationId": "AggregatePrevote",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "aggregate_prevote": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string"
                    },
                    "voter": {
                      "type": "string"
                    },
                    "submit_block": {
                      "type": "string",
                      "format": "uint64"
                    }
                  },
                  "title": "struct for aggregate prevoting on the ExchangeRateVote.\nThe purpose of aggregate prevote is to hide vote exchange rates with hash\nwhich is formatted as hex string in SHA256(\"{salt}:{exchange rate}{denom},...,{exchange rate}{denom}:{voter}\")"
                }
              },
              "description": "QueryAggregatePrevoteResponse is response type for the\nQuery/AggregatePrevote RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "validator_addr",
            "description": "validator defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/oracle/v1beta1/validators/{validator_addr}/feeder": {
      "get": {
        "summary": "FeederDelegation returns feeder delegation of a validator",
        "operationId": "FeederDelegation",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "feeder_addr": {
                  "type": "string",
                  "title": "feeder_addr defines the feeder delegation of a validator"
                }
              },
              "description": "QueryFeederDelegationResponse is response type for the\nQuery/FeederDelegation RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "validator_addr",
            "description": "validator defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/oracle/v1beta1/validators/{validator_addr}/miss": {
      "get": {
        "summary": "MissCounter returns oracle miss counter of a validator",
        "operationId": "MissCounter",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "miss_counter": {
                  "type": "string",
                  "format": "uint64",
                  "title": "miss_counter defines the oracle miss counter of a validator"
                }
              },
              "description": "QueryMissCounterResponse is response type for the\nQuery/MissCounter RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "validator_addr",
            "description": "validator defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/treasury/v1beta1/indicators": {
      "get": {
        "summary": "Indicators return the current trl informations",
        "operationId": "Indicators",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "trl_year": {
                  "type": "string"
                },
                "trl_month": {
                  "type": "string"
                }
              },
              "description": "QueryIndicatorsResponse is response type for the\nQuery/Indicators RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/treasury/v1beta1/params": {
      "get": {
        "summary": "Params queries all parameters.",
        "operationId": "TreasuryParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params defines the parameters of the module.",
                  "type": "object",
                  "properties": {
                    "tax_policy": {
                      "type": "object",
                      "properties": {
                        "rate_min": {
                          "type": "string"
                        },
                        "rate_max": {
                          "type": "string"
                        },
                        "cap": {
                          "type": "object",
                          "properties": {
                            "denom": {
                              "type": "string"
                            },
                            "amount": {
                              "type": "string"
                            }
                          },
                          "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                        },
                        "change_rate_max": {
                          "type": "string"
                        }
                      },
                      "title": "PolicyConstraints - defines policy constraints can be applied in tax & reward policies"
                    },
                    "reward_policy": {
                      "type": "object",
                      "properties": {
                        "rate_min": {
                          "type": "string"
                        },
                        "rate_max": {
                          "type": "string"
                        },
                        "cap": {
                          "type": "object",
                          "properties": {
                            "denom": {
                              "type": "string"
                            },
                            "amount": {
                              "type": "string"
                            }
                          },
                          "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                        },
                        "change_rate_max": {
                          "type": "string"
                        }
                      },
                      "title": "PolicyConstraints - defines policy constraints can be applied in tax & reward policies"
                    },
                    "seigniorage_burden_target": {
                      "type": "string"
                    },
                    "mining_increment": {
                      "type": "string"
                    },
                    "window_short": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "window_long": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "window_probation": {
                      "type": "string",
                      "format": "uint64"
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/treasury/v1beta1/reward_weight": {
      "get": {
        "summary": "RewardWeight return the current reward weight",
        "operationId": "RewardWeight",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "reward_weight": {
                  "type": "string"
                }
              },
              "description": "QueryRewardWeightResponse is response type for the\nQuery/RewardWeight RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/treasury/v1beta1/seigniorage_proceeds": {
      "get": {
        "summary": "SeigniorageProceeds return the current seigniorage proceeds",
        "operationId": "SeigniorageProceeds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "seigniorage_proceeds": {
                  "type": "string"
                }
              },
              "description": "QuerySeigniorageProceedsResponse is response type for the\nQuery/SeigniorageProceeds RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/treasury/v1beta1/tax_caps": {
      "get": {
        "summary": "TaxCaps returns the all tax caps",
        "operationId": "TaxCaps",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "tax_caps": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "tax_cap": {
                        "type": "string"
                      }
                    },
                    "description": "QueryTaxCapsResponseItem is response item type for the\nQuery/TaxCaps RPC method."
                  }
                }
              },
              "description": "QueryTaxCapsResponse is response type for the\nQuery/TaxCaps RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/treasury/v1beta1/tax_caps/{denom}": {
      "get": {
        "summary": "TaxCap returns the tax cap of a denom",
        "operationId": "TaxCap",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "tax_cap": {
                  "type": "string"
                }
              },
              "description": "QueryTaxCapResponse is response type for the\nQuery/TaxCap RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "denom",
            "description": "denom defines the denomination to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/treasury/v1beta1/tax_proceeds": {
      "get": {
        "summary": "TaxProceeds return the current tax proceeds",
        "operationId": "TaxProceeds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "tax_proceeds": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                  }
                }
              },
              "description": "QueryTaxProceedsResponse is response type for the\nQuery/TaxProceeds RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/treasury/v1beta1/tax_rate": {
      "get": {
        "summary": "TaxRate return the current tax rate",
        "operationId": "TaxRate",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "tax_rate": {
                  "type": "string"
                }
              },
              "description": "QueryTaxRateResponse is response type for the\nQuery/TaxRate RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/wasm/v1beta1/codes/{code_id}": {
      "get": {
        "summary": "CodeInfo returns the stored code info",
        "operationId": "CodeInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "code_info": {
                  "type": "object",
                  "properties": {
                    "code_id": {
                      "type": "string",
                      "format": "uint64",
                      "title": "CodeID is the sequentially increasing unique identifier"
                    },
                    "code_hash": {
                      "type": "string",
                      "format": "byte",
                      "title": "CodeHash is the unique identifier created by wasmvm"
                    },
                    "creator": {
                      "type": "string",
                      "title": "Creator address who initially stored the code"
                    }
                  },
                  "title": "CodeInfo is data for the uploaded contract WASM code"
                }
              },
              "description": "QueryCodeInfoResponse is response type for the\nQueryyCodeInfo RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "code_id",
            "description": "grpc-gateway_out does not support Go style CodID",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/wasm/v1beta1/codes/{code_id}/byte_code": {
      "get": {
        "summary": "ByteCode returns the stored byte code",
        "operationId": "ByteCode",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "byte_code": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "description": "QueryByteCodeResponse is response type for the\nQueryyByteCode RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "code_id",
            "description": "grpc-gateway_out does not support Go style CodID",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/wasm/v1beta1/contracts/{contract_address}": {
      "get": {
        "summary": "ContractInfo returns the stored contract info",
        "operationId": "ContractInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "contract_info": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "title": "Address is the address of the contract"
                    },
                    "creator": {
                      "type": "string",
                      "title": "Creator is the contract creator address"
                    },
                    "admin": {
                      "type": "string",
                      "title": "Admin is who can execute the contract migration"
                    },
                    "code_id": {
                      "type": "string",
                      "format": "uint64",
                      "title": "CodeID is the reference to the stored Wasm code"
                    },
                    "init_msg": {
                      "type": "string",
                      "format": "byte",
                      "title": "InitMsg is the raw message used when instantiating a contract"
                    }
                  },
                  "title": "ContractInfo stores a WASM contract instance"
                }
              },
              "description": "QueryContractInfoResponse is response type for the\nQuery/ContractInfo RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "contract_address",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/wasm/v1beta1/contracts/{contract_address}/store": {
      "get": {
        "summary": "ContractStore return smart query result from the contract",
        "operationId": "ContractStore",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "query_result": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "description": "QueryContractStoreResponse is response type for the\nQuery/ContractStore RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "contract_address",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "query_msg",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/wasm/v1beta1/contracts/{contract_address}/store/raw": {
      "get": {
        "summary": "RawStore return single key from the raw store data of a contract",
        "operationId": "RawStore",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "data": {
                  "type": "string",
                  "format": "byte",
                  "title": "Data contains the raw store data"
                }
              },
              "description": "QueryRawStoreResponse is response type for the\nQuery/RawStore RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "contract_address",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "key",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/terra/wasm/v1beta1/params": {
      "get": {
        "summary": "Params queries all parameters.",
        "operationId": "WasmParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params defines the parameters of the module.",
                  "type": "object",
                  "properties": {
                    "max_contract_size": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "max_contract_gas": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "max_contract_msg_size": {
                      "type": "string",
                      "format": "uint64"
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels": {
      "get": {
        "summary": "Channels queries all the IBC channels of a chain.",
        "operationId": "Channels",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "channels": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "state": {
                        "title": "current state of the channel end",
                        "type": "string",
                        "enum": [
                          "STATE_UNINITIALIZED_UNSPECIFIED",
                          "STATE_INIT",
                          "STATE_TRYOPEN",
                          "STATE_OPEN",
                          "STATE_CLOSED"
                        ],
                        "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                        "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
                      },
                      "ordering": {
                        "title": "whether the channel is ordered or unordered",
                        "type": "string",
                        "enum": [
                          "ORDER_NONE_UNSPECIFIED",
                          "ORDER_UNORDERED",
                          "ORDER_ORDERED"
                        ],
                        "default": "ORDER_NONE_UNSPECIFIED",
                        "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
                      },
                      "counterparty": {
                        "title": "counterparty channel end",
                        "type": "object",
                        "properties": {
                          "port_id": {
                            "type": "string",
                            "description": "port on the counterparty chain which owns the other end of the channel."
                          },
                          "channel_id": {
                            "type": "string",
                            "title": "channel end on the counterparty chain"
                          }
                        }
                      },
                      "connection_hops": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel"
                      },
                      "version": {
                        "type": "string",
                        "title": "opaque channel version, which is agreed upon during the handshake"
                      },
                      "port_id": {
                        "type": "string",
                        "title": "port identifier"
                      },
                      "channel_id": {
                        "type": "string",
                        "title": "channel identifier"
                      }
                    },
                    "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields."
                  },
                  "description": "list of stored channels of the chain."
                },
                "pagination": {
                  "title": "pagination response",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                },
                "height": {
                  "title": "query block height",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "description": "QueryChannelsResponse is the response type for the Query/Channels RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}": {
      "get": {
        "summary": "Channel queries an IBC Channel.",
        "operationId": "Channel",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "channel": {
                  "title": "channel associated with the request identifiers",
                  "type": "object",
                  "properties": {
                    "state": {
                      "title": "current state of the channel end",
                      "type": "string",
                      "enum": [
                        "STATE_UNINITIALIZED_UNSPECIFIED",
                        "STATE_INIT",
                        "STATE_TRYOPEN",
                        "STATE_OPEN",
                        "STATE_CLOSED"
                      ],
                      "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                      "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
                    },
                    "ordering": {
                      "title": "whether the channel is ordered or unordered",
                      "type": "string",
                      "enum": [
                        "ORDER_NONE_UNSPECIFIED",
                        "ORDER_UNORDERED",
                        "ORDER_ORDERED"
                      ],
                      "default": "ORDER_NONE_UNSPECIFIED",
                      "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
                    },
                    "counterparty": {
                      "title": "counterparty channel end",
                      "type": "object",
                      "properties": {
                        "port_id": {
                          "type": "string",
                          "description": "port on the counterparty chain which owns the other end of the channel."
                        },
                        "channel_id": {
                          "type": "string",
                          "title": "channel end on the counterparty chain"
                        }
                      }
                    },
                    "connection_hops": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel"
                    },
                    "version": {
                      "type": "string",
                      "title": "opaque channel version, which is agreed upon during the handshake"
                    }
                  },
                  "description": "Channel defines pipeline for exactly-once packet delivery between specific\nmodules on separate blockchains, which has at least one end capable of\nsending packets and one end capable of receiving packets."
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "description": "QueryChannelResponse is the response type for the Query/Channel RPC method.\nBesides the Channel end, it includes a proof and the height from which the\nproof was retrieved."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/client_state": {
      "get": {
        "summary": "ChannelClientState queries for the client state for the channel associated\nwith the provided channel identifiers.",
        "operationId": "ChannelClientState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "identified_client_state": {
                  "title": "client state associated with the channel",
                  "type": "object",
                  "properties": {
                    "client_id": {
                      "type": "string",
                      "title": "client identifier"
                    },
                    "client_state": {
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "type": "string",
                          "format": "byte",
                          "description": "Must be a valid serialized protocol buffer of the above specified type."
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                      "title": "client state"
                    }
                  },
                  "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field."
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryChannelClientStateResponse is the Response type for the\nQuery/QueryChannelClientState RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/consensus_state/revision/{revision_number}/height/{revision_height}": {
      "get": {
        "summary": "ChannelConsensusState queries for the consensus state for the channel\nassociated with the provided channel identifiers.",
        "operationId": "ChannelConsensusState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "consensus_state": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                  "title": "consensus state associated with the channel"
                },
                "client_id": {
                  "type": "string",
                  "title": "client ID associated with the consensus state"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryChannelClientStateResponse is the Response type for the\nQuery/QueryChannelClientState RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "revision_number",
            "description": "revision number of the consensus state",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "revision_height",
            "description": "revision height of the consensus state",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence": {
      "get": {
        "summary": "NextSequenceReceive returns the next receive sequence for a given channel.",
        "operationId": "NextSequenceReceive",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "next_sequence_receive": {
                  "type": "string",
                  "format": "uint64",
                  "title": "next sequence receive number"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QuerySequenceResponse is the request type for the\nQuery/QueryNextSequenceReceiveResponse RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acknowledgements": {
      "get": {
        "summary": "PacketAcknowledgements returns all the packet acknowledgements associated\nwith a channel.",
        "operationId": "PacketAcknowledgements",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "acknowledgements": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "port_id": {
                        "type": "string",
                        "description": "channel port identifier."
                      },
                      "channel_id": {
                        "type": "string",
                        "description": "channel unique identifier."
                      },
                      "sequence": {
                        "type": "string",
                        "format": "uint64",
                        "description": "packet sequence."
                      },
                      "data": {
                        "type": "string",
                        "format": "byte",
                        "description": "embedded data that represents packet state."
                      }
                    },
                    "description": "PacketState defines the generic type necessary to retrieve and store\npacket commitments, acknowledgements, and receipts.\nCaller is responsible for knowing the context necessary to interpret this\nstate as a commitment, acknowledgement, or a receipt."
                  }
                },
                "pagination": {
                  "title": "pagination response",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                },
                "height": {
                  "title": "query block height",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryPacketAcknowledgemetsResponse is the request type for the\nQuery/QueryPacketAcknowledgements RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acks/{sequence}": {
      "get": {
        "summary": "PacketAcknowledgement queries a stored packet acknowledgement hash.",
        "operationId": "PacketAcknowledgement",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "acknowledgement": {
                  "type": "string",
                  "format": "byte",
                  "title": "packet associated with the request fields"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryPacketAcknowledgementResponse defines the client query response for a\npacket which also includes a proof and the height from which the\nproof was retrieved"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "sequence",
            "description": "packet sequence",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments": {
      "get": {
        "summary": "PacketCommitments returns all the packet commitments hashes associated\nwith a channel.",
        "operationId": "PacketCommitments",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "commitments": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "port_id": {
                        "type": "string",
                        "description": "channel port identifier."
                      },
                      "channel_id": {
                        "type": "string",
                        "description": "channel unique identifier."
                      },
                      "sequence": {
                        "type": "string",
                        "format": "uint64",
                        "description": "packet sequence."
                      },
                      "data": {
                        "type": "string",
                        "format": "byte",
                        "description": "embedded data that represents packet state."
                      }
                    },
                    "description": "PacketState defines the generic type necessary to retrieve and store\npacket commitments, acknowledgements, and receipts.\nCaller is responsible for knowing the context necessary to interpret this\nstate as a commitment, acknowledgement, or a receipt."
                  }
                },
                "pagination": {
                  "title": "pagination response",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                },
                "height": {
                  "title": "query block height",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryPacketCommitmentsResponse is the request type for the\nQuery/QueryPacketCommitments RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_ack_sequences}/unreceived_acks": {
      "get": {
        "summary": "UnreceivedAcks returns all the unreceived IBC acknowledgements associated\nwith a channel and sequences.",
        "operationId": "UnreceivedAcks",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "sequences": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "uint64"
                  },
                  "title": "list of unreceived acknowledgement sequences"
                },
                "height": {
                  "title": "query block height",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryUnreceivedAcksResponse is the response type for the\nQuery/UnreceivedAcks RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "packet_ack_sequences",
            "description": "list of acknowledgement sequences",
            "in": "path",
            "required": true,
            "type": "array",
            "items": {
              "type": "string",
              "format": "uint64"
            },
            "collectionFormat": "csv",
            "minItems": 1
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_commitment_sequences}/unreceived_packets": {
      "get": {
        "summary": "UnreceivedPackets returns all the unreceived IBC packets associated with a\nchannel and sequences.",
        "operationId": "UnreceivedPackets",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "sequences": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "uint64"
                  },
                  "title": "list of unreceived packet sequences"
                },
                "height": {
                  "title": "query block height",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryUnreceivedPacketsResponse is the response type for the\nQuery/UnreceivedPacketCommitments RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "packet_commitment_sequences",
            "description": "list of packet sequences",
            "in": "path",
            "required": true,
            "type": "array",
            "items": {
              "type": "string",
              "format": "uint64"
            },
            "collectionFormat": "csv",
            "minItems": 1
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequence}": {
      "get": {
        "summary": "PacketCommitment queries a stored packet commitment hash.",
        "operationId": "PacketCommitment",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "commitment": {
                  "type": "string",
                  "format": "byte",
                  "title": "packet associated with the request fields"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryPacketCommitmentResponse defines the client query response for a packet\nwhich also includes a proof and the height from which the proof was\nretrieved"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "sequence",
            "description": "packet sequence",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_receipts/{sequence}": {
      "get": {
        "summary": "PacketReceipt queries if a given packet sequence has been received on the\nqueried chain",
        "operationId": "PacketReceipt",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "received": {
                  "type": "boolean",
                  "format": "boolean",
                  "title": "success flag for if receipt exists"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryPacketReceiptResponse defines the client query response for a packet\nreceipt which also includes a proof, and the height from which the proof was\nretrieved"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "sequence",
            "description": "packet sequence",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/connections/{connection}/channels": {
      "get": {
        "summary": "ConnectionChannels queries all the channels associated with a connection\nend.",
        "operationId": "ConnectionChannels",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "channels": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "state": {
                        "title": "current state of the channel end",
                        "type": "string",
                        "enum": [
                          "STATE_UNINITIALIZED_UNSPECIFIED",
                          "STATE_INIT",
                          "STATE_TRYOPEN",
                          "STATE_OPEN",
                          "STATE_CLOSED"
                        ],
                        "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                        "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
                      },
                      "ordering": {
                        "title": "whether the channel is ordered or unordered",
                        "type": "string",
                        "enum": [
                          "ORDER_NONE_UNSPECIFIED",
                          "ORDER_UNORDERED",
                          "ORDER_ORDERED"
                        ],
                        "default": "ORDER_NONE_UNSPECIFIED",
                        "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
                      },
                      "counterparty": {
                        "title": "counterparty channel end",
                        "type": "object",
                        "properties": {
                          "port_id": {
                            "type": "string",
                            "description": "port on the counterparty chain which owns the other end of the channel."
                          },
                          "channel_id": {
                            "type": "string",
                            "title": "channel end on the counterparty chain"
                          }
                        }
                      },
                      "connection_hops": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel"
                      },
                      "version": {
                        "type": "string",
                        "title": "opaque channel version, which is agreed upon during the handshake"
                      },
                      "port_id": {
                        "type": "string",
                        "title": "port identifier"
                      },
                      "channel_id": {
                        "type": "string",
                        "title": "channel identifier"
                      }
                    },
                    "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields."
                  },
                  "description": "list of channels associated with a connection."
                },
                "pagination": {
                  "title": "pagination response",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                },
                "height": {
                  "title": "query block height",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryConnectionChannelsResponse is the Response type for the\nQuery/QueryConnectionChannels RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "connection",
            "description": "connection unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/client/v1/params": {
      "get": {
        "summary": "ClientParams queries all parameters of the ibc client.",
        "operationId": "ClientParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params defines the parameters of the module.",
                  "type": "object",
                  "properties": {
                    "allowed_clients": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "allowed_clients defines the list of allowed client state types."
                    }
                  }
                }
              },
              "description": "QueryClientParamsResponse is the response type for the Query/ClientParams RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/client/v1/client_states": {
      "get": {
        "summary": "ClientStates queries all the IBC light clients of a chain.",
        "operationId": "ClientStates",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "client_states": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "client_id": {
                        "type": "string",
                        "title": "client identifier"
                      },
                      "client_state": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                        "title": "client state"
                      }
                    },
                    "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field."
                  },
                  "description": "list of stored ClientStates of the chain."
                },
                "pagination": {
                  "title": "pagination response",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                }
              },
              "description": "QueryClientStatesResponse is the response type for the Query/ClientStates RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/client/v1/client_states/{client_id}": {
      "get": {
        "summary": "ClientState queries an IBC light client.",
        "operationId": "ClientState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "client_state": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                  "title": "client state associated with the request identifier"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "description": "QueryClientStateResponse is the response type for the Query/ClientState RPC\nmethod. Besides the client state, it includes a proof and the height from\nwhich the proof was retrieved."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "client_id",
            "description": "client state unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/client/v1/client_status/{client_id}": {
      "get": {
        "summary": "Status queries the status of an IBC client.",
        "operationId": "ClientStatus",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "status": {
                  "type": "string"
                }
              },
              "description": "QueryClientStatusResponse is the response type for the Query/ClientStatus RPC\nmethod. It returns the current status of the IBC client."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "client_id",
            "description": "client unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/client/v1/consensus_states/{client_id}": {
      "get": {
        "summary": "ConsensusStates queries all the consensus state associated with a given\nclient.",
        "operationId": "ConsensusStates",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "consensus_states": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "height": {
                        "title": "consensus state height",
                        "type": "object",
                        "properties": {
                          "revision_number": {
                            "type": "string",
                            "format": "uint64",
                            "title": "the revision that the client is currently on"
                          },
                          "revision_height": {
                            "type": "string",
                            "format": "uint64",
                            "title": "the height within the given revision"
                          }
                        },
                        "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                      },
                      "consensus_state": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                        "title": "consensus state"
                      }
                    },
                    "description": "ConsensusStateWithHeight defines a consensus state with an additional height\nfield."
                  },
                  "title": "consensus states associated with the identifier"
                },
                "pagination": {
                  "title": "pagination response",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                }
              },
              "title": "QueryConsensusStatesResponse is the response type for the\nQuery/ConsensusStates RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "client_id",
            "description": "client identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/client/v1/consensus_states/{client_id}/revision/{revision_number}/height/{revision_height}": {
      "get": {
        "summary": "ConsensusState queries a consensus state associated with a client state at\na given height.",
        "operationId": "ConsensusState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "consensus_state": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                  "title": "consensus state associated with the client identifier at the given height"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryConsensusStateResponse is the response type for the Query/ConsensusState\nRPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "client_id",
            "description": "client identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "revision_number",
            "description": "consensus state revision number",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "revision_height",
            "description": "consensus state revision height",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "latest_height",
            "description": "latest_height overrrides the height field and queries the latest stored\nConsensusState.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/client/v1/upgraded_client_states": {
      "get": {
        "summary": "UpgradedClientState queries an Upgraded IBC light client.",
        "operationId": "UpgradedClientState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "upgraded_client_state": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                  "title": "client state associated with the request identifier"
                }
              },
              "description": "QueryUpgradedClientStateResponse is the response type for the\nQuery/UpgradedClientState RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/client/v1/upgraded_consensus_states": {
      "get": {
        "summary": "UpgradedConsensusState queries an Upgraded IBC consensus state.",
        "operationId": "IBCUpgradedConsensusState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "upgraded_consensus_state": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                  "title": "Consensus state associated with the request identifier"
                }
              },
              "description": "QueryUpgradedConsensusStateResponse is the response type for the\nQuery/UpgradedConsensusState RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/connection/v1/client_connections/{client_id}": {
      "get": {
        "summary": "ClientConnections queries the connection paths associated with a client\nstate.",
        "operationId": "ClientConnections",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "connection_paths": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "slice of all the connection paths associated with a client."
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was generated",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryClientConnectionsResponse is the response type for the\nQuery/ClientConnections RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "client_id",
            "description": "client identifier associated with a connection",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/connection/v1/connections": {
      "get": {
        "summary": "Connections queries all the IBC connections of a chain.",
        "operationId": "Connections",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "connections": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "id": {
                        "type": "string",
                        "description": "connection identifier."
                      },
                      "client_id": {
                        "type": "string",
                        "description": "client associated with this connection."
                      },
                      "versions": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "identifier": {
                              "type": "string",
                              "title": "unique version identifier"
                            },
                            "features": {
                              "type": "array",
                              "items": {
                                "type": "string"
                              },
                              "title": "list of features compatible with the specified identifier"
                            }
                          },
                          "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake."
                        },
                        "title": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection"
                      },
                      "state": {
                        "description": "current state of the connection end.",
                        "type": "string",
                        "enum": [
                          "STATE_UNINITIALIZED_UNSPECIFIED",
                          "STATE_INIT",
                          "STATE_TRYOPEN",
                          "STATE_OPEN"
                        ],
                        "default": "STATE_UNINITIALIZED_UNSPECIFIED"
                      },
                      "counterparty": {
                        "description": "counterparty chain associated with this connection.",
                        "type": "object",
                        "properties": {
                          "client_id": {
                            "type": "string",
                            "description": "identifies the client on the counterparty chain associated with a given\nconnection."
                          },
                          "connection_id": {
                            "type": "string",
                            "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
                          },
                          "prefix": {
                            "description": "commitment merkle prefix of the counterparty chain.",
                            "type": "object",
                            "properties": {
                              "key_prefix": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))"
                          }
                        }
                      },
                      "delay_period": {
                        "type": "string",
                        "format": "uint64",
                        "description": "delay period associated with this connection."
                      }
                    },
                    "description": "IdentifiedConnection defines a connection with additional connection\nidentifier field."
                  },
                  "description": "list of stored connections of the chain."
                },
                "pagination": {
                  "title": "pagination response",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                },
                "height": {
                  "title": "query block height",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "description": "QueryConnectionsResponse is the response type for the Query/Connections RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/connection/v1/connections/{connection_id}": {
      "get": {
        "summary": "Connection queries an IBC connection end.",
        "operationId": "Connection",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "connection": {
                  "title": "connection associated with the request identifier",
                  "type": "object",
                  "properties": {
                    "client_id": {
                      "type": "string",
                      "description": "client associated with this connection."
                    },
                    "versions": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "identifier": {
                            "type": "string",
                            "title": "unique version identifier"
                          },
                          "features": {
                            "type": "array",
                            "items": {
                              "type": "string"
                            },
                            "title": "list of features compatible with the specified identifier"
                          }
                        },
                        "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake."
                      },
                      "description": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection."
                    },
                    "state": {
                      "description": "current state of the connection end.",
                      "type": "string",
                      "enum": [
                        "STATE_UNINITIALIZED_UNSPECIFIED",
                        "STATE_INIT",
                        "STATE_TRYOPEN",
                        "STATE_OPEN"
                      ],
                      "default": "STATE_UNINITIALIZED_UNSPECIFIED"
                    },
                    "counterparty": {
                      "description": "counterparty chain associated with this connection.",
                      "type": "object",
                      "properties": {
                        "client_id": {
                          "type": "string",
                          "description": "identifies the client on the counterparty chain associated with a given\nconnection."
                        },
                        "connection_id": {
                          "type": "string",
                          "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
                        },
                        "prefix": {
                          "description": "commitment merkle prefix of the counterparty chain.",
                          "type": "object",
                          "properties": {
                            "key_prefix": {
                              "type": "string",
                              "format": "byte"
                            }
                          },
                          "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))"
                        }
                      }
                    },
                    "delay_period": {
                      "type": "string",
                      "format": "uint64",
                      "description": "delay period that must pass before a consensus state can be used for\npacket-verification NOTE: delay period logic is only implemented by some\nclients."
                    }
                  },
                  "description": "ConnectionEnd defines a stateful object on a chain connected to another\nseparate one.\nNOTE: there must only be 2 defined ConnectionEnds to establish\na connection between two chains."
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "description": "QueryConnectionResponse is the response type for the Query/Connection RPC\nmethod. Besides the connection end, it includes a proof and the height from\nwhich the proof was retrieved."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "connection_id",
            "description": "connection unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/connection/v1/connections/{connection_id}/client_state": {
      "get": {
        "summary": "ConnectionClientState queries the client state associated with the\nconnection.",
        "operationId": "ConnectionClientState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "identified_client_state": {
                  "title": "client state associated with the channel",
                  "type": "object",
                  "properties": {
                    "client_id": {
                      "type": "string",
                      "title": "client identifier"
                    },
                    "client_state": {
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "type": "string",
                          "format": "byte",
                          "description": "Must be a valid serialized protocol buffer of the above specified type."
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                      "title": "client state"
                    }
                  },
                  "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field."
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryConnectionClientStateResponse is the response type for the\nQuery/ConnectionClientState RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "connection_id",
            "description": "connection identifier",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/connection/v1/connections/{connection_id}/consensus_state/revision/{revision_number}/height/{revision_height}": {
      "get": {
        "summary": "ConnectionConsensusState queries the consensus state associated with the\nconnection.",
        "operationId": "ConnectionConsensusState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "consensus_state": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                  "title": "consensus state associated with the channel"
                },
                "client_id": {
                  "type": "string",
                  "title": "client ID associated with the consensus state"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryConnectionConsensusStateResponse is the response type for the\nQuery/ConnectionConsensusState RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "connection_id",
            "description": "connection identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "revision_number",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "revision_height",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/apps/transfer/v1/denom_traces": {
      "get": {
        "summary": "DenomTraces queries all denomination traces.",
        "operationId": "DenomTraces",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "denom_traces": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "path": {
                        "type": "string",
                        "description": "path defines the chain of port/channel identifiers used for tracing the\nsource of the fungible token."
                      },
                      "base_denom": {
                        "type": "string",
                        "description": "base denomination of the relayed fungible token."
                      }
                    },
                    "description": "DenomTrace contains the base denomination for ICS20 fungible tokens and the\nsource tracing information path."
                  },
                  "description": "denom_traces returns all denominations trace information."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryConnectionsResponse is the response type for the Query/DenomTraces RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/apps/transfer/v1/denom_traces/{hash}": {
      "get": {
        "summary": "DenomTrace queries a denomination trace information.",
        "operationId": "DenomTrace",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "denom_trace": {
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "description": "path defines the chain of port/channel identifiers used for tracing the\nsource of the fungible token."
                    },
                    "base_denom": {
                      "type": "string",
                      "description": "base denomination of the relayed fungible token."
                    }
                  },
                  "description": "DenomTrace contains the base denomination for ICS20 fungible tokens and the\nsource tracing information path."
                }
              },
              "description": "QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "hash",
            "description": "hash (in hex format) of the denomination trace information.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/apps/transfer/v1/params": {
      "get": {
        "summary": "Params queries all parameters of the ibc-transfer module.",
        "operationId": "IBCTransferParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params defines the parameters of the module.",
                  "type": "object",
                  "properties": {
                    "send_enabled": {
                      "type": "boolean",
                      "format": "boolean",
                      "description": "send_enabled enables or disables all cross-chain token transfers from this\nchain."
                    },
                    "receive_enabled": {
                      "type": "boolean",
                      "format": "boolean",
                      "description": "receive_enabled enables or disables all cross-chain token transfers to this\nchain."
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/v1/bank/{account}": {
      "get": {
        "tags": [
          "Bank"
        ],
        "summary": "Get account information",
        "description": "Get account information",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "account",
            "in": "path",
            "required": true,
            "type": "string",
            "description": "Account address in bech32 format"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getBankResult"
            }
          }
        }
      }
    },
    "/v1/dashboard/account_growth": {
      "get": {
        "tags": [
          "Dashboard"
        ],
        "summary": "Get account growth history",
        "description": "Get account growth history",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getAccountGrowthResult"
            }
          }
        }
      }
    },
    "/v1/dashboard/active_accounts": {
      "get": {
        "tags": [
          "Dashboard"
        ],
        "summary": "Get active accounts count history",
        "description": "Get active accounts count history",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getActiveAccountsResult"
            }
          }
        }
      }
    },
    "/v1/dashboard/block_rewards": {
      "get": {
        "tags": [
          "Dashboard"
        ],
        "summary": "Get block reward history",
        "description": "Get block reward history",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getBlockRewardResult"
            }
          }
        }
      }
    },
    "/v1/dashboard": {
      "get": {
        "tags": [
          "Dashboard"
        ],
        "summary": "Get information to be used on the dashboard",
        "description": "Get information to be used on the dashboard",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getDashboardResult"
            }
          }
        }
      }
    },
    "/v1/dashboard/last_hour_ops_txs_count": {
      "get": {
        "tags": [
          "Dashboard"
        ],
        "description": "",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getLastHourTxAndOpsCountResult"
            }
          }
        }
      }
    },
    "/v1/dashboard/registered_accounts": {
      "get": {
        "tags": [
          "Dashboard"
        ],
        "summary": "Get registered accounts count history",
        "description": "Get registered accounts count history",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getRegisteredAccountsResult"
            }
          }
        }
      }
    },
    "/v1/dashboard/seigniorage_proceeds": {
      "get": {
        "tags": [
          "Dashboard"
        ],
        "summary": "Get the amount of seigniorage in the start of the day",
        "description": "Get the amount of seigniorage in the start of the day",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/seigniorage"
              }
            }
          }
        }
      }
    },
    "/v1/dashboard/staking_ratio": {
      "get": {
        "tags": [
          "Dashboard"
        ],
        "summary": "Get the historical staking ratio",
        "description": "Get the historical staking ratio",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/stakingHistory"
              }
            }
          }
        }
      }
    },
    "/v1/dashboard/staking_return": {
      "get": {
        "tags": [
          "Dashboard"
        ],
        "summary": "Get staking return history",
        "description": "Get staking return history",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/seigniorage"
              }
            }
          }
        }
      }
    },
    "/v1/dashboard/tx_volume": {
      "get": {
        "tags": [
          "Dashboard"
        ],
        "summary": "Get tx volume history",
        "description": "Get tx volume history",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getTxVolumeResult"
            }
          }
        }
      }
    },
    "/v1/gov/proposals/{proposalId}": {
      "get": {
        "tags": [
          "Governance"
        ],
        "summary": "Get proposal",
        "description": "Get proposal",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "proposalId",
            "in": "path",
            "required": true,
            "type": "string",
            "description": "Proposal id"
          },
          {
            "name": "account",
            "in": "query",
            "required": false,
            "type": "string",
            "description": "User account"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getProposalResult"
            }
          }
        }
      }
    },
    "/v1/gov/proposals/{proposalId}/deposits": {
      "get": {
        "tags": [
          "Governance"
        ],
        "summary": "Get proposal's deposits",
        "description": "Get proposal's deposits",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "proposalId",
            "in": "path",
            "required": true,
            "type": "string",
            "description": "Proposal id"
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "type": "number",
            "description": "Page number"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "number",
            "description": "Page size"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getProposalDepositsResult"
            }
          }
        }
      }
    },
    "/v1/gov/proposals": {
      "get": {
        "tags": [
          "Governance"
        ],
        "summary": "Get proposal list",
        "description": "Get proposal list",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "status",
            "in": "query",
            "required": false,
            "type": "string",
            "description": "'deposit', 'voting', 'passed', 'rejected'"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getProposalListResult"
            }
          }
        }
      }
    },
    "/v1/gov/proposals/{proposalId}/votes": {
      "get": {
        "tags": [
          "Governance"
        ],
        "summary": "Get proposal's votes",
        "description": "Get proposal's votes",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "proposalId",
            "in": "path",
            "required": true,
            "type": "string",
            "description": "Proposal id"
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "type": "number",
            "description": "Page number"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "number",
            "description": "Page size"
          },
          {
            "name": "option",
            "in": "query",
            "required": false,
            "type": "string",
            "description": "'Yes', 'No', 'NoWithVeto', 'Abstain'"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getProposalVotesResult"
            }
          }
        }
      }
    },
    "/v1/market/price": {
      "get": {
        "tags": [
          "Market"
        ],
        "summary": "Get price history",
        "description": "Get price history",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "denom",
            "in": "query",
            "required": true,
            "type": "string",
            "description": "Coin denomination"
          },
          {
            "name": "interval",
            "in": "query",
            "required": true,
            "type": "string",
            "description": "Price interval"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getMarketPriceResult"
            }
          }
        }
      }
    },
    "/v1/market/swaprate/{base}": {
      "get": {
        "tags": [
          "Market"
        ],
        "summary": "Get current swaprate",
        "description": "Get current swaprate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "base",
            "in": "path",
            "required": true,
            "type": "string",
            "description": "Coin denomination"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/rates"
              }
            }
          }
        }
      }
    },
    "/v1/staking": {
      "get": {
        "tags": [
          "Staking"
        ],
        "summary": "Get all validators and staking info",
        "description": "Get all validators and staking info",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/validators"
              }
            }
          }
        }
      }
    },
    "/v1/staking/{account}": {
      "get": {
        "tags": [
          "Staking"
        ],
        "summary": "Get all validators and staking info with account",
        "description": "Get all validators and staking info with account",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "account",
            "in": "path",
            "required": true,
            "type": "string",
            "description": "User's account address"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getStakingForAccountResult"
            }
          }
        }
      }
    },
    "/v1/staking/return": {
      "get": {
        "tags": [
          "Staking"
        ],
        "summary": "Get total staking return",
        "description": "Get total staking return",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "number"
            }
          }
        }
      }
    },
    "/v1/staking/validators/{operatorAddr}/claims": {
      "get": {
        "tags": [
          "Staking"
        ],
        "summary": "Get validators claims",
        "description": "Get validators claims",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "operatorAddr",
            "in": "path",
            "required": true,
            "type": "string",
            "description": "validators operator address"
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "type": "number",
            "description": "Page number"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "number",
            "description": "Page size"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getValidatorClaimsResult"
            }
          }
        }
      }
    },
    "/v1/staking/validators/{operatorAddr}/delegations": {
      "get": {
        "tags": [
          "Staking"
        ],
        "summary": "Get validators delegations",
        "description": "Get validators delegations",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "operatorAddr",
            "in": "path",
            "required": true,
            "type": "string",
            "description": "validators operator address"
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "type": "number",
            "description": "Page number"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "number",
            "description": "Page size"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getValidatorDelegationsResult"
            }
          }
        }
      }
    },
    "/v1/staking/validators/{operatorAddr}/delegators": {
      "get": {
        "tags": [
          "Staking"
        ],
        "summary": "Get validators delegators",
        "description": "Get validators delegators",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "operatorAddr",
            "in": "path",
            "required": true,
            "type": "string",
            "description": "validators operator address"
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "type": "number",
            "description": "Page number"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "number",
            "description": "Page size"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getValidatorDelegatorsResult"
            }
          }
        }
      }
    },
    "/v1/staking/validators/{operatorAddr}": {
      "get": {
        "tags": [
          "Staking"
        ],
        "summary": "Get validator detail",
        "description": "Get validator detail",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "operatorAddr",
            "in": "path",
            "required": true,
            "type": "string",
            "description": "Operator address"
          },
          {
            "name": "account",
            "in": "query",
            "required": false,
            "type": "string",
            "description": "User address"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getValidatorDetailResult"
            }
          }
        }
      }
    },
    "/v1/staking/return/{operatorAddr}": {
      "get": {
        "tags": [
          "Staking"
        ],
        "summary": "Get validators staking return",
        "description": "Get validators staking return",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "operatorAddr",
            "in": "path",
            "required": true,
            "type": "string",
            "description": "validators operator address"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "number"
            }
          }
        }
      }
    },
    "/v1/staking/validators": {
      "get": {
        "tags": [
          "Staking"
        ],
        "summary": "Get all validator info",
        "description": "Get all validator info",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/validator"
              }
            }
          }
        }
      }
    },
    "/v1/txs/gas_prices": {
      "get": {
        "tags": [
          "Transactions"
        ],
        "summary": "Get gas prices",
        "description": "Get gas prices",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getGasPricesResult"
            }
          }
        }
      }
    },
    "/v1/mempool": {
      "get": {
        "tags": [
          "Transactions"
        ],
        "summary": "Get transactions in mempool",
        "description": "Get transactions in mempool",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "account",
            "in": "query",
            "required": false,
            "type": "string",
            "description": "Account address"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/txs"
              }
            }
          }
        }
      }
    },
    "/v1/mempool/{txhash}": {
      "get": {
        "tags": [
          "Transactions"
        ],
        "summary": "Get transaction in mempool",
        "description": "Get transaction in mempool",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getMempoolByHashResult"
            }
          }
        }
      }
    },
    "/v1/tx/{txhash}": {
      "get": {
        "tags": [
          "Transactions"
        ],
        "summary": "Get Tx",
        "description": "Get Tx",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "txhash",
            "in": "path",
            "required": true,
            "type": "string",
            "description": "Tx Hash"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getTxResult"
            }
          }
        }
      }
    },
    "/v1/txs": {
      "get": {
        "tags": [
          "Transactions"
        ],
        "summary": "Get Tx List",
        "description": "Get Tx List",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "account",
            "in": "query",
            "required": false,
            "type": "string",
            "description": "Account address"
          },
          {
            "name": "block",
            "in": "query",
            "required": false,
            "type": "string",
            "description": "Block number"
          },
          {
            "name": "chainId",
            "in": "query",
            "required": false,
            "type": "string",
            "description": "Chain ID of Blockchain (default: chain id of mainnet)"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "type": "number",
            "description": "Use next property from previous result for pagination"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "number",
            "description": "Size of page"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getTxListResult"
            }
          }
        }
      },
      "post": {
        "tags": [
          "Transactions"
        ],
        "summary": "Broadcast Txs",
        "description": "Broadcast Txs",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "postTxsBody",
            "required": true,
            "schema": {
              "$ref": "#/definitions/postTxsBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/postTxsResult"
            }
          }
        }
      }
    },
    "/v1/circulatingsupply/{denom}": {
      "get": {
        "tags": [
          "Treasury"
        ],
        "summary": "Get circulating supply of coins",
        "description": "Get circulating supply of coins",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "denom",
            "in": "path",
            "required": true,
            "type": "string",
            "description": "Coin denomination"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "number"
            }
          }
        }
      }
    },
    "/v1/richlist/{denom}": {
      "get": {
        "tags": [
          "Treasury"
        ],
        "summary": "Get richlist of coins",
        "description": "Get richlist of coins",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "denom",
            "in": "path",
            "required": true,
            "type": "string",
            "description": "Coin denomination"
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "type": "number",
            "description": "Page number"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "number",
            "description": "Page size"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/accounts"
              }
            }
          }
        }
      }
    },
    "/v1/taxproceeds": {
      "get": {
        "tags": [
          "Treasury"
        ],
        "summary": "Get taxproceeds",
        "description": "Get taxproceeds",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/getTaxProceedsResult"
            }
          }
        }
      }
    },
    "/v1/totalsupply/{denom}": {
      "get": {
        "tags": [
          "Treasury"
        ],
        "summary": "Get total supply of coins",
        "description": "Get total supply of coins",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "denom",
            "in": "path",
            "required": true,
            "type": "string",
            "description": "Coin denomination"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "string"
            }
          }
        }
      }
    }
  },
  "definitions": {
    "CheckTxResult": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer"
        },
        "data": {
          "type": "string"
        },
        "gas_used": {
          "type": "integer"
        },
        "gas_wanted": {
          "type": "integer"
        },
        "info": {
          "type": "string"
        },
        "log": {
          "type": "string"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "key": {
                "type": "string"
              },
              "value": {
                "type": "string"
              }
            }
          }
        }
      },
      "example": {
        "code": 0,
        "data": "data",
        "log": "log",
        "gas_used": 5000,
        "gas_wanted": 10000,
        "info": "info",
        "tags": [
          "",
          ""
        ]
      }
    },
    "DeliverTxResult": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer"
        },
        "data": {
          "type": "string"
        },
        "gas_used": {
          "type": "integer"
        },
        "gas_wanted": {
          "type": "integer"
        },
        "info": {
          "type": "string"
        },
        "log": {
          "type": "string"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "key": {
                "type": "string"
              },
              "value": {
                "type": "string"
              }
            }
          }
        }
      },
      "example": {
        "code": 5,
        "data": "data",
        "log": "log",
        "gas_used": 5000,
        "gas_wanted": 10000,
        "info": "info",
        "tags": [
          "",
          ""
        ]
      }
    },
    "BroadcastTxCommitResult": {
      "type": "object",
      "properties": {
        "check_tx": {
          "type": "object",
          "properties": {
            "code": {
              "type": "integer"
            },
            "data": {
              "type": "string"
            },
            "gas_used": {
              "type": "integer"
            },
            "gas_wanted": {
              "type": "integer"
            },
            "info": {
              "type": "string"
            },
            "log": {
              "type": "string"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string"
                  },
                  "value": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "example": {
            "code": 0,
            "data": "data",
            "log": "log",
            "gas_used": 5000,
            "gas_wanted": 10000,
            "info": "info",
            "tags": [
              "",
              ""
            ]
          }
        },
        "deliver_tx": {
          "type": "object",
          "properties": {
            "code": {
              "type": "integer"
            },
            "data": {
              "type": "string"
            },
            "gas_used": {
              "type": "integer"
            },
            "gas_wanted": {
              "type": "integer"
            },
            "info": {
              "type": "string"
            },
            "log": {
              "type": "string"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string"
                  },
                  "value": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "example": {
            "code": 5,
            "data": "data",
            "log": "log",
            "gas_used": 5000,
            "gas_wanted": 10000,
            "info": "info",
            "tags": [
              "",
              ""
            ]
          }
        },
        "hash": {
          "type": "string",
          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
        },
        "height": {
          "type": "integer"
        }
      }
    },
    "KVPair": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      }
    },
    "Msg": {
      "type": "string"
    },
    "Address": {
      "type": "string",
      "description": "bech32 encoded address",
      "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
    },
    "ValidatorAddress": {
      "type": "string",
      "description": "bech32 encoded address",
      "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
    },
    "Coin": {
      "type": "object",
      "properties": {
        "denom": {
          "type": "string",
          "example": "uluna"
        },
        "amount": {
          "type": "string",
          "example": "50"
        }
      }
    },
    "DecCoin": {
      "type": "object",
      "properties": {
        "denom": {
          "type": "string",
          "example": "ukrw"
        },
        "amount": {
          "type": "string",
          "example": "50.000"
        }
      }
    },
    "Hash": {
      "type": "string",
      "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
    },
    "TxQuery": {
      "type": "object",
      "properties": {
        "hash": {
          "type": "string",
          "example": "D085138D913993919295FF4B0A9107F1F2CDE0D37A87CE0644E217CBF3B49656"
        },
        "height": {
          "type": "number",
          "example": 368
        },
        "tx": {
          "type": "object",
          "properties": {
            "msg": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "fee": {
              "type": "object",
              "properties": {
                "gas": {
                  "type": "string"
                },
                "amount": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                }
              }
            },
            "memo": {
              "type": "string"
            },
            "signature": {
              "type": "object",
              "properties": {
                "signature": {
                  "type": "string",
                  "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                },
                "pub_key": {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "example": "tendermint/PubKeySecp256k1"
                    },
                    "value": {
                      "type": "string",
                      "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                    }
                  }
                },
                "account_number": {
                  "type": "string",
                  "example": "0"
                },
                "sequence": {
                  "type": "string",
                  "example": "0"
                }
              }
            }
          }
        },
        "result": {
          "type": "object",
          "properties": {
            "log": {
              "type": "string"
            },
            "gas_wanted": {
              "type": "string",
              "example": "200000"
            },
            "gas_used": {
              "type": "string",
              "example": "26354"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string"
                  },
                  "value": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "PaginatedQueryTxs": {
      "type": "object",
      "properties": {
        "total_count": {
          "type": "number",
          "example": 1
        },
        "count": {
          "type": "number",
          "example": 1
        },
        "page_number": {
          "type": "number",
          "example": 1
        },
        "page_total": {
          "type": "number",
          "example": 1
        },
        "limit": {
          "type": "number",
          "example": 30
        },
        "txs": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "hash": {
                "type": "string",
                "example": "D085138D913993919295FF4B0A9107F1F2CDE0D37A87CE0644E217CBF3B49656"
              },
              "height": {
                "type": "number",
                "example": 368
              },
              "tx": {
                "type": "object",
                "properties": {
                  "msg": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "fee": {
                    "type": "object",
                    "properties": {
                      "gas": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "denom": {
                              "type": "string",
                              "example": "uluna"
                            },
                            "amount": {
                              "type": "string",
                              "example": "50"
                            }
                          }
                        }
                      }
                    }
                  },
                  "memo": {
                    "type": "string"
                  },
                  "signature": {
                    "type": "object",
                    "properties": {
                      "signature": {
                        "type": "string",
                        "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                      },
                      "pub_key": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string",
                            "example": "tendermint/PubKeySecp256k1"
                          },
                          "value": {
                            "type": "string",
                            "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                          }
                        }
                      },
                      "account_number": {
                        "type": "string",
                        "example": "0"
                      },
                      "sequence": {
                        "type": "string",
                        "example": "0"
                      }
                    }
                  }
                }
              },
              "result": {
                "type": "object",
                "properties": {
                  "log": {
                    "type": "string"
                  },
                  "gas_wanted": {
                    "type": "string",
                    "example": "200000"
                  },
                  "gas_used": {
                    "type": "string",
                    "example": "26354"
                  },
                  "tags": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "key": {
                          "type": "string"
                        },
                        "value": {
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "StdTx": {
      "type": "object",
      "properties": {
        "msg": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "fee": {
          "type": "object",
          "properties": {
            "gas": {
              "type": "string"
            },
            "amount": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            }
          }
        },
        "memo": {
          "type": "string"
        },
        "signature": {
          "type": "object",
          "properties": {
            "signature": {
              "type": "string",
              "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
            },
            "pub_key": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string",
                  "example": "tendermint/PubKeySecp256k1"
                },
                "value": {
                  "type": "string",
                  "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                }
              }
            },
            "account_number": {
              "type": "string",
              "example": "0"
            },
            "sequence": {
              "type": "string",
              "example": "0"
            }
          }
        }
      }
    },
    "BlockID": {
      "type": "object",
      "properties": {
        "hash": {
          "type": "string",
          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
        },
        "parts": {
          "type": "object",
          "properties": {
            "total": {
              "type": "number",
              "example": 0
            },
            "hash": {
              "type": "string",
              "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
            }
          }
        }
      }
    },
    "BlockHeader": {
      "type": "object",
      "properties": {
        "chain_id": {
          "type": "string",
          "example": "columbus-5"
        },
        "height": {
          "type": "number",
          "example": 1
        },
        "time": {
          "type": "string",
          "example": "2017-12-30T05:53:09.287+01:00"
        },
        "num_txs": {
          "type": "number",
          "example": 0
        },
        "last_block_id": {
          "type": "object",
          "properties": {
            "hash": {
              "type": "string",
              "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
            },
            "parts": {
              "type": "object",
              "properties": {
                "total": {
                  "type": "number",
                  "example": 0
                },
                "hash": {
                  "type": "string",
                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                }
              }
            }
          }
        },
        "total_txs": {
          "type": "number",
          "example": 35
        },
        "last_commit_hash": {
          "type": "string",
          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
        },
        "data_hash": {
          "type": "string",
          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
        },
        "validators_hash": {
          "type": "string",
          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
        },
        "next_validators_hash": {
          "type": "string",
          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
        },
        "consensus_hash": {
          "type": "string",
          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
        },
        "app_hash": {
          "type": "string",
          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
        },
        "last_results_hash": {
          "type": "string",
          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
        },
        "evidence_hash": {
          "type": "string",
          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
        },
        "proposer_address": {
          "type": "string",
          "description": "bech32 encoded address",
          "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
        },
        "version": {
          "type": "object",
          "properties": {
            "block": {
              "type": "string",
              "example": 10
            },
            "app": {
              "type": "string",
              "example": 0
            }
          }
        }
      }
    },
    "Block": {
      "type": "object",
      "properties": {
        "header": {
          "type": "object",
          "properties": {
            "chain_id": {
              "type": "string",
              "example": "columbus-5"
            },
            "height": {
              "type": "number",
              "example": 1
            },
            "time": {
              "type": "string",
              "example": "2017-12-30T05:53:09.287+01:00"
            },
            "num_txs": {
              "type": "number",
              "example": 0
            },
            "last_block_id": {
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "parts": {
                  "type": "object",
                  "properties": {
                    "total": {
                      "type": "number",
                      "example": 0
                    },
                    "hash": {
                      "type": "string",
                      "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                    }
                  }
                }
              }
            },
            "total_txs": {
              "type": "number",
              "example": 35
            },
            "last_commit_hash": {
              "type": "string",
              "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
            },
            "data_hash": {
              "type": "string",
              "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
            },
            "validators_hash": {
              "type": "string",
              "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
            },
            "next_validators_hash": {
              "type": "string",
              "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
            },
            "consensus_hash": {
              "type": "string",
              "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
            },
            "app_hash": {
              "type": "string",
              "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
            },
            "last_results_hash": {
              "type": "string",
              "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
            },
            "evidence_hash": {
              "type": "string",
              "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
            },
            "proposer_address": {
              "type": "string",
              "description": "bech32 encoded address",
              "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
            },
            "version": {
              "type": "object",
              "properties": {
                "block": {
                  "type": "string",
                  "example": 10
                },
                "app": {
                  "type": "string",
                  "example": 0
                }
              }
            }
          }
        },
        "txs": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "evidence": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "last_commit": {
          "type": "object",
          "properties": {
            "block_id": {
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "parts": {
                  "type": "object",
                  "properties": {
                    "total": {
                      "type": "number",
                      "example": 0
                    },
                    "hash": {
                      "type": "string",
                      "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                    }
                  }
                }
              }
            },
            "precommits": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "validator_address": {
                    "type": "string"
                  },
                  "validator_index": {
                    "type": "string",
                    "example": "0"
                  },
                  "height": {
                    "type": "string",
                    "example": "0"
                  },
                  "round": {
                    "type": "string",
                    "example": "0"
                  },
                  "timestamp": {
                    "type": "string",
                    "example": "2017-12-30T05:53:09.287+01:00"
                  },
                  "type": {
                    "type": "number",
                    "example": 2
                  },
                  "block_id": {
                    "type": "object",
                    "properties": {
                      "hash": {
                        "type": "string",
                        "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                      },
                      "parts": {
                        "type": "object",
                        "properties": {
                          "total": {
                            "type": "number",
                            "example": 0
                          },
                          "hash": {
                            "type": "string",
                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                          }
                        }
                      }
                    }
                  },
                  "signature": {
                    "type": "string",
                    "example": "7uTC74QlknqYWEwg7Vn6M8Om7FuZ0EO4bjvuj6rwH1mTUJrRuMMZvAAqT9VjNgP0RA/TDp6u/92AqrZfXJSpBQ=="
                  }
                }
              }
            }
          }
        }
      }
    },
    "BlockQuery": {
      "type": "object",
      "properties": {
        "block_meta": {
          "type": "object",
          "properties": {
            "header": {
              "type": "object",
              "properties": {
                "chain_id": {
                  "type": "string",
                  "example": "columbus-5"
                },
                "height": {
                  "type": "number",
                  "example": 1
                },
                "time": {
                  "type": "string",
                  "example": "2017-12-30T05:53:09.287+01:00"
                },
                "num_txs": {
                  "type": "number",
                  "example": 0
                },
                "last_block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                    },
                    "parts": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "number",
                          "example": 0
                        },
                        "hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        }
                      }
                    }
                  }
                },
                "total_txs": {
                  "type": "number",
                  "example": 35
                },
                "last_commit_hash": {
                  "type": "string",
                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "data_hash": {
                  "type": "string",
                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "validators_hash": {
                  "type": "string",
                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "next_validators_hash": {
                  "type": "string",
                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "consensus_hash": {
                  "type": "string",
                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "app_hash": {
                  "type": "string",
                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "last_results_hash": {
                  "type": "string",
                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "evidence_hash": {
                  "type": "string",
                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "proposer_address": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                },
                "version": {
                  "type": "object",
                  "properties": {
                    "block": {
                      "type": "string",
                      "example": 10
                    },
                    "app": {
                      "type": "string",
                      "example": 0
                    }
                  }
                }
              }
            },
            "block_id": {
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "parts": {
                  "type": "object",
                  "properties": {
                    "total": {
                      "type": "number",
                      "example": 0
                    },
                    "hash": {
                      "type": "string",
                      "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                    }
                  }
                }
              }
            }
          }
        },
        "block": {
          "type": "object",
          "properties": {
            "header": {
              "type": "object",
              "properties": {
                "chain_id": {
                  "type": "string",
                  "example": "columbus-5"
                },
                "height": {
                  "type": "number",
                  "example": 1
                },
                "time": {
                  "type": "string",
                  "example": "2017-12-30T05:53:09.287+01:00"
                },
                "num_txs": {
                  "type": "number",
                  "example": 0
                },
                "last_block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                    },
                    "parts": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "number",
                          "example": 0
                        },
                        "hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        }
                      }
                    }
                  }
                },
                "total_txs": {
                  "type": "number",
                  "example": 35
                },
                "last_commit_hash": {
                  "type": "string",
                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "data_hash": {
                  "type": "string",
                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "validators_hash": {
                  "type": "string",
                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "next_validators_hash": {
                  "type": "string",
                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "consensus_hash": {
                  "type": "string",
                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "app_hash": {
                  "type": "string",
                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "last_results_hash": {
                  "type": "string",
                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "evidence_hash": {
                  "type": "string",
                  "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "proposer_address": {
                  "type": "string",
                  "description": "bech32 encoded address",
                  "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                },
                "version": {
                  "type": "object",
                  "properties": {
                    "block": {
                      "type": "string",
                      "example": 10
                    },
                    "app": {
                      "type": "string",
                      "example": 0
                    }
                  }
                }
              }
            },
            "txs": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "evidence": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "last_commit": {
              "type": "object",
              "properties": {
                "block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                    },
                    "parts": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "number",
                          "example": 0
                        },
                        "hash": {
                          "type": "string",
                          "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        }
                      }
                    }
                  }
                },
                "precommits": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "validator_address": {
                        "type": "string"
                      },
                      "validator_index": {
                        "type": "string",
                        "example": "0"
                      },
                      "height": {
                        "type": "string",
                        "example": "0"
                      },
                      "round": {
                        "type": "string",
                        "example": "0"
                      },
                      "timestamp": {
                        "type": "string",
                        "example": "2017-12-30T05:53:09.287+01:00"
                      },
                      "type": {
                        "type": "number",
                        "example": 2
                      },
                      "block_id": {
                        "type": "object",
                        "properties": {
                          "hash": {
                            "type": "string",
                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                          },
                          "parts": {
                            "type": "object",
                            "properties": {
                              "total": {
                                "type": "number",
                                "example": 0
                              },
                              "hash": {
                                "type": "string",
                                "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                              }
                            }
                          }
                        }
                      },
                      "signature": {
                        "type": "string",
                        "example": "7uTC74QlknqYWEwg7Vn6M8Om7FuZ0EO4bjvuj6rwH1mTUJrRuMMZvAAqT9VjNgP0RA/TDp6u/92AqrZfXJSpBQ=="
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "DelegationDelegatorReward": {
      "type": "object",
      "properties": {
        "validator_address": {
          "type": "string",
          "description": "bech32 encoded address",
          "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
        },
        "reward": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string",
                "example": "uluna"
              },
              "amount": {
                "type": "string",
                "example": "50"
              }
            }
          }
        }
      }
    },
    "DelegatorTotalRewards": {
      "type": "object",
      "properties": {
        "rewards": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "validator_address": {
                "type": "string",
                "description": "bech32 encoded address",
                "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
              },
              "reward": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string",
                      "example": "uluna"
                    },
                    "amount": {
                      "type": "string",
                      "example": "50"
                    }
                  }
                }
              }
            }
          }
        },
        "total": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string",
                "example": "uluna"
              },
              "amount": {
                "type": "string",
                "example": "50"
              }
            }
          }
        }
      }
    },
    "BaseReq": {
      "type": "object",
      "properties": {
        "from": {
          "type": "string",
          "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
          "description": "Sender address or Keybase name to generate a transaction"
        },
        "memo": {
          "type": "string",
          "example": "Sent via Terra Station 🚀"
        },
        "chain_id": {
          "type": "string",
          "example": "Columbus-5"
        },
        "account_number": {
          "type": "string",
          "example": "0"
        },
        "sequence": {
          "type": "string",
          "example": "1"
        },
        "gas": {
          "type": "string",
          "example": "200000"
        },
        "gas_adjustment": {
          "type": "string",
          "example": "1.2"
        },
        "fees": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string",
                "example": "uluna"
              },
              "amount": {
                "type": "string",
                "example": "50"
              }
            }
          }
        },
        "simulate": {
          "type": "boolean",
          "example": false,
          "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
        }
      }
    },
    "TendermintValidator": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "bech32 encoded address",
          "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
        },
        "pub_key": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string"
            },
            "value": {
              "type": "string"
            }
          }
        },
        "voting_power": {
          "type": "string",
          "example": "1000"
        },
        "proposer_priority": {
          "type": "string",
          "example": "1000"
        }
      }
    },
    "TextProposal": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "example": "1"
        },
        "content": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "example": "gov/TextProposal"
            },
            "value": {
              "type": "object",
              "properties": {
                "title": {
                  "type": "string"
                },
                "description": {
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "number"
        },
        "final_tally_result": {
          "type": "object",
          "properties": {
            "yes": {
              "type": "string",
              "example": "0.0000000000"
            },
            "abstain": {
              "type": "string",
              "example": "0.0000000000"
            },
            "no": {
              "type": "string",
              "example": "0.0000000000"
            },
            "no_with_veto": {
              "type": "string",
              "example": "0.0000000000"
            }
          }
        },
        "total_deposit": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string",
                "example": "uluna"
              },
              "amount": {
                "type": "string",
                "example": "50"
              }
            }
          }
        },
        "submit_time": {
          "type": "string"
        },
        "deposit_end_time": {
          "type": "string"
        },
        "voting_start_time": {
          "type": "string"
        },
        "voting_end_time": {
          "type": "string"
        }
      }
    },
    "Proposer": {
      "type": "object",
      "properties": {
        "proposal_id": {
          "type": "string"
        },
        "proposer": {
          "type": "string"
        }
      }
    },
    "Deposit": {
      "type": "object",
      "properties": {
        "amount": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string",
                "example": "uluna"
              },
              "amount": {
                "type": "string",
                "example": "50"
              }
            }
          }
        },
        "proposal_id": {
          "type": "string"
        },
        "depositor": {
          "type": "string",
          "description": "bech32 encoded address",
          "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
        }
      }
    },
    "TallyResult": {
      "type": "object",
      "properties": {
        "yes": {
          "type": "string",
          "example": "0.0000000000"
        },
        "abstain": {
          "type": "string",
          "example": "0.0000000000"
        },
        "no": {
          "type": "string",
          "example": "0.0000000000"
        },
        "no_with_veto": {
          "type": "string",
          "example": "0.0000000000"
        }
      }
    },
    "Vote": {
      "type": "object",
      "properties": {
        "voter": {
          "type": "string"
        },
        "proposal_id": {
          "type": "string"
        },
        "options": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "option": {
                "type": "string",
                "enum": [
                  "VOTE_OPTION_UNSPECIFIED",
                  "VOTE_OPTION_YES",
                  "VOTE_OPTION_ABSTAIN",
                  "VOTE_OPTION_NO",
                  "VOTE_OPTION_NO_WITH_VETO"
                ],
                "default": "VOTE_OPTION_UNSPECIFIED",
                "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n- VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option. - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option. - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option. - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option. - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."
              },
              "weight": {
                "type": "string"
              }
            }
          }
        }
      }
    },
    "Validator": {
      "type": "object",
      "properties": {
        "operator_address": {
          "type": "string",
          "description": "bech32 encoded address",
          "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
        },
        "consensus_pubkey": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string"
            },
            "value": {
              "type": "string"
            }
          }
        },
        "jailed": {
          "type": "boolean"
        },
        "status": {
          "type": "integer"
        },
        "tokens": {
          "type": "string"
        },
        "delegator_shares": {
          "type": "string"
        },
        "description": {
          "type": "object",
          "properties": {
            "moniker": {
              "type": "string"
            },
            "identity": {
              "type": "string"
            },
            "website": {
              "type": "string"
            },
            "security_contact": {
              "type": "string"
            },
            "details": {
              "type": "string"
            }
          }
        },
        "bond_height": {
          "type": "string",
          "example": "0"
        },
        "bond_intra_tx_counter": {
          "type": "integer",
          "example": 0
        },
        "unbonding_height": {
          "type": "string",
          "example": "0"
        },
        "unbonding_time": {
          "type": "string",
          "example": "1970-01-01T00:00:00Z"
        },
        "commission": {
          "type": "object",
          "properties": {
            "rate": {
              "type": "string",
              "example": "0"
            },
            "max_rate": {
              "type": "string",
              "example": "0"
            },
            "max_change_rate": {
              "type": "string",
              "example": "0"
            },
            "update_time": {
              "type": "string",
              "example": "1970-01-01T00:00:00Z"
            }
          }
        }
      }
    },
    "Delegation": {
      "type": "object",
      "properties": {
        "delegation": {
          "type": "object",
          "properties": {
            "delegator_address": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            },
            "shares": {
              "type": "string"
            }
          }
        },
        "balance": {
          "type": "object",
          "properties": {
            "denom": {
              "type": "string",
              "example": "uluna"
            },
            "amount": {
              "type": "string",
              "example": "50"
            }
          }
        }
      }
    },
    "UnbondingDelegation": {
      "type": "object",
      "properties": {
        "delegator_address": {
          "type": "string"
        },
        "validator_address": {
          "type": "string"
        },
        "entries": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "initial_balance": {
                "type": "string"
              },
              "balance": {
                "type": "string"
              },
              "creation_height": {
                "type": "string"
              },
              "completion_time": {
                "type": "string"
              }
            }
          }
        }
      }
    },
    "UnbondingEntry": {
      "type": "object",
      "properties": {
        "initial_balance": {
          "type": "string"
        },
        "balance": {
          "type": "string"
        },
        "creation_height": {
          "type": "string"
        },
        "completion_time": {
          "type": "string"
        }
      }
    },
    "Redelegation": {
      "type": "object",
      "properties": {
        "delegator_address": {
          "type": "string"
        },
        "validator_src_address": {
          "type": "string"
        },
        "validator_dst_address": {
          "type": "string"
        },
        "entries": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "creation_height": {
                "type": "integer"
              },
              "completion_time": {
                "type": "integer"
              },
              "initial_balance": {
                "type": "string"
              },
              "balance": {
                "type": "string"
              },
              "shares_dst": {
                "type": "string"
              }
            }
          }
        }
      }
    },
    "RedelegationEntry": {
      "type": "object",
      "properties": {
        "creation_height": {
          "type": "integer"
        },
        "completion_time": {
          "type": "integer"
        },
        "initial_balance": {
          "type": "string"
        },
        "balance": {
          "type": "string"
        },
        "shares_dst": {
          "type": "string"
        }
      }
    },
    "ValidatorDistInfo": {
      "type": "object",
      "properties": {
        "operator_address": {
          "type": "string",
          "description": "bech32 encoded address",
          "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
        },
        "self_bond_rewards": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string",
                "example": "uluna"
              },
              "amount": {
                "type": "string",
                "example": "50"
              }
            }
          }
        },
        "val_commission": {
          "type": "object",
          "properties": {
            "commission": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            }
          }
        }
      }
    },
    "PublicKey": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      }
    },
    "SigningInfo": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "example": "terravalcons1qsdpq864szmfk8nh82qcg7lyle6k95w07acdqn"
        },
        "start_height": {
          "type": "string"
        },
        "index_offset": {
          "type": "string"
        },
        "jailed_until": {
          "type": "string"
        },
        "missed_blocks_counter": {
          "type": "string"
        }
      }
    },
    "ParamChange": {
      "type": "object",
      "properties": {
        "subspace": {
          "type": "string",
          "example": "staking"
        },
        "key": {
          "type": "string",
          "example": "MaxValidators"
        },
        "subkey": {
          "type": "string",
          "example": ""
        },
        "value": {
          "type": "object"
        }
      }
    },
    "Supply": {
      "type": "object",
      "properties": {
        "total": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string",
                "example": "uluna"
              },
              "amount": {
                "type": "string",
                "example": "50"
              }
            }
          }
        }
      }
    },
    "BaseAccount": {
      "type": "object",
      "properties": {
        "account_number": {
          "type": "string"
        },
        "address": {
          "type": "string"
        },
        "public_key": {
          "type": "string"
        },
        "sequence": {
          "type": "string"
        }
      }
    },
    "Account": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "example": "core/Account"
        },
        "value": {
          "type": "object",
          "properties": {
            "account_number": {
              "type": "string"
            },
            "address": {
              "type": "string"
            },
            "public_key": {
              "type": "string"
            },
            "sequence": {
              "type": "string"
            }
          }
        }
      }
    },
    "BaseVestingAccount": {
      "type": "object",
      "properties": {
        "BaseAccount": {
          "type": "object",
          "properties": {
            "account_number": {
              "type": "string"
            },
            "address": {
              "type": "string"
            },
            "public_key": {
              "type": "string"
            },
            "sequence": {
              "type": "string"
            }
          }
        },
        "original_vesting": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string",
                "example": "uluna"
              },
              "amount": {
                "type": "string",
                "example": "50"
              }
            }
          }
        },
        "delegated_free": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string",
                "example": "uluna"
              },
              "amount": {
                "type": "string",
                "example": "50"
              }
            }
          }
        },
        "delegated_vesting": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string",
                "example": "uluna"
              },
              "amount": {
                "type": "string",
                "example": "50"
              }
            }
          }
        },
        "end_time": {
          "type": "string",
          "example": "0"
        }
      }
    },
    "Schedule": {
      "type": "object",
      "properties": {
        "start_time": {
          "type": "string",
          "example": "1556085600"
        },
        "end_time": {
          "type": "string",
          "example": "1556085600"
        },
        "ratio": {
          "type": "string",
          "example": "0.100000000000000000"
        }
      }
    },
    "VestingSchedule": {
      "type": "object",
      "properties": {
        "denom": {
          "type": "string",
          "example": "usdr"
        },
        "lazy_schedules": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "start_time": {
                "type": "string",
                "example": "1556085600"
              },
              "end_time": {
                "type": "string",
                "example": "1556085600"
              },
              "ratio": {
                "type": "string",
                "example": "0.100000000000000000"
              }
            }
          }
        }
      }
    },
    "BaseLazyGradedVestingAccount": {
      "type": "object",
      "properties": {
        "BaseVestingAccount": {
          "type": "object",
          "properties": {
            "BaseAccount": {
              "type": "object",
              "properties": {
                "account_number": {
                  "type": "string"
                },
                "address": {
                  "type": "string"
                },
                "public_key": {
                  "type": "string"
                },
                "sequence": {
                  "type": "string"
                }
              }
            },
            "original_vesting": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            },
            "delegated_free": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            },
            "delegated_vesting": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            },
            "end_time": {
              "type": "string",
              "example": "0"
            }
          }
        },
        "vesting_schedules": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string",
                "example": "usdr"
              },
              "lazy_schedules": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "start_time": {
                      "type": "string",
                      "example": "1556085600"
                    },
                    "end_time": {
                      "type": "string",
                      "example": "1556085600"
                    },
                    "ratio": {
                      "type": "string",
                      "example": "0.100000000000000000"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "LazyGradedVestingAccount": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "example": "core/LazyGradedVestingAccount"
        },
        "value": {
          "type": "object",
          "properties": {
            "BaseVestingAccount": {
              "type": "object",
              "properties": {
                "BaseAccount": {
                  "type": "object",
                  "properties": {
                    "account_number": {
                      "type": "string"
                    },
                    "address": {
                      "type": "string"
                    },
                    "public_key": {
                      "type": "string"
                    },
                    "sequence": {
                      "type": "string"
                    }
                  }
                },
                "original_vesting": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                },
                "delegated_free": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                },
                "delegated_vesting": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                },
                "end_time": {
                  "type": "string",
                  "example": "0"
                }
              }
            },
            "vesting_schedules": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "usdr"
                  },
                  "lazy_schedules": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "start_time": {
                          "type": "string",
                          "example": "1556085600"
                        },
                        "end_time": {
                          "type": "string",
                          "example": "1556085600"
                        },
                        "ratio": {
                          "type": "string",
                          "example": "0.100000000000000000"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "SwapReq": {
      "type": "object",
      "required": [
        "base_req",
        "offer_coin",
        "ask_denom"
      ],
      "properties": {
        "base_req": {
          "type": "object",
          "properties": {
            "from": {
              "type": "string",
              "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
              "description": "Sender address or Keybase name to generate a transaction"
            },
            "memo": {
              "type": "string",
              "example": "Sent via Terra Station 🚀"
            },
            "chain_id": {
              "type": "string",
              "example": "Columbus-5"
            },
            "account_number": {
              "type": "string",
              "example": "0"
            },
            "sequence": {
              "type": "string",
              "example": "1"
            },
            "gas": {
              "type": "string",
              "example": "200000"
            },
            "gas_adjustment": {
              "type": "string",
              "example": "1.2"
            },
            "fees": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            },
            "simulate": {
              "type": "boolean",
              "example": false,
              "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
            }
          }
        },
        "offer_coin": {
          "type": "object",
          "properties": {
            "denom": {
              "type": "string",
              "example": "uluna"
            },
            "amount": {
              "type": "string",
              "example": "50"
            }
          }
        },
        "ask_denom": {
          "type": "string",
          "example": "uluna"
        },
        "receiver": {
          "type": "string",
          "description": "the `receiver` field can be skipped when the receiver is trader",
          "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
        }
      }
    },
    "MarketParams": {
      "type": "object",
      "properties": {
        "base_pool": {
          "type": "number",
          "example": "1000000.0"
        },
        "pool_recovery_period": {
          "type": "number",
          "example": "16000"
        },
        "min_stability_spread": {
          "type": "number",
          "example": "0.02"
        }
      }
    },
    "PrevoteReq": {
      "type": "object",
      "properties": {
        "base_req": {
          "type": "object",
          "properties": {
            "from": {
              "type": "string",
              "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
              "description": "Sender address or Keybase name to generate a transaction"
            },
            "memo": {
              "type": "string",
              "example": "Sent via Terra Station 🚀"
            },
            "chain_id": {
              "type": "string",
              "example": "Columbus-5"
            },
            "account_number": {
              "type": "string",
              "example": "0"
            },
            "sequence": {
              "type": "string",
              "example": "1"
            },
            "gas": {
              "type": "string",
              "example": "200000"
            },
            "gas_adjustment": {
              "type": "string",
              "example": "1.2"
            },
            "fees": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            },
            "simulate": {
              "type": "boolean",
              "example": false,
              "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
            }
          }
        },
        "exchange_rate": {
          "type": "number",
          "example": "1000.0",
          "description": "exchange rate of Luna in denom currency is to make prevote hash; this field is required to submit prevote in case absence of hash"
        },
        "salt": {
          "type": "string",
          "example": "abcd",
          "description": "salt is to make prevote hash; this field is required to submit prevote in case  absence of hash"
        },
        "hash": {
          "type": "string",
          "example": "061bf1e27dfff121f40c826e593c8a28ec299a02",
          "description": "hex string; hash of next vote; empty == skip prevote"
        },
        "validator": {
          "type": "string",
          "description": "bech32 encoded address",
          "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
        }
      }
    },
    "VoteReq": {
      "type": "object",
      "properties": {
        "base_req": {
          "type": "object",
          "properties": {
            "from": {
              "type": "string",
              "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
              "description": "Sender address or Keybase name to generate a transaction"
            },
            "memo": {
              "type": "string",
              "example": "Sent via Terra Station 🚀"
            },
            "chain_id": {
              "type": "string",
              "example": "Columbus-5"
            },
            "account_number": {
              "type": "string",
              "example": "0"
            },
            "sequence": {
              "type": "string",
              "example": "1"
            },
            "gas": {
              "type": "string",
              "example": "200000"
            },
            "gas_adjustment": {
              "type": "string",
              "example": "1.2"
            },
            "fees": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            },
            "simulate": {
              "type": "boolean",
              "example": false,
              "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
            }
          }
        },
        "exchange_rate": {
          "type": "number",
          "example": "1000.0",
          "description": "proof exchange rate of Luna in denom currency was used to make prevote hash; initial prevote does not require this field"
        },
        "salt": {
          "type": "string",
          "example": "abcd",
          "description": "proof salt was used to make prevote hash; initial prevote does not require this field"
        },
        "validator": {
          "type": "string",
          "description": "bech32 encoded address",
          "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
        }
      }
    },
    "AggregatePrevoteReq": {
      "type": "object",
      "properties": {
        "base_req": {
          "type": "object",
          "properties": {
            "from": {
              "type": "string",
              "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
              "description": "Sender address or Keybase name to generate a transaction"
            },
            "memo": {
              "type": "string",
              "example": "Sent via Terra Station 🚀"
            },
            "chain_id": {
              "type": "string",
              "example": "Columbus-5"
            },
            "account_number": {
              "type": "string",
              "example": "0"
            },
            "sequence": {
              "type": "string",
              "example": "1"
            },
            "gas": {
              "type": "string",
              "example": "200000"
            },
            "gas_adjustment": {
              "type": "string",
              "example": "1.2"
            },
            "fees": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            },
            "simulate": {
              "type": "boolean",
              "example": false,
              "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
            }
          }
        },
        "exchange_rates": {
          "type": "string",
          "example": "1000.0ukrw,1.2uusd,0.99usdr",
          "description": "exchange rates of Luna in denom currencies are to make aggregate prevote hash; this field is required to submit prevote in case absence of hash"
        },
        "salt": {
          "type": "string",
          "example": "abcd",
          "description": "salt is to make prevote hash; this field is required to submit prevote in case  absence of hash"
        },
        "hash": {
          "type": "string",
          "example": "061bf1e27dfff121f40c826e593c8a28ec299a02",
          "description": "hex string; hash of next vote; empty == skip prevote"
        }
      }
    },
    "AggregateVoteReq": {
      "type": "object",
      "properties": {
        "base_req": {
          "type": "object",
          "properties": {
            "from": {
              "type": "string",
              "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
              "description": "Sender address or Keybase name to generate a transaction"
            },
            "memo": {
              "type": "string",
              "example": "Sent via Terra Station 🚀"
            },
            "chain_id": {
              "type": "string",
              "example": "Columbus-5"
            },
            "account_number": {
              "type": "string",
              "example": "0"
            },
            "sequence": {
              "type": "string",
              "example": "1"
            },
            "gas": {
              "type": "string",
              "example": "200000"
            },
            "gas_adjustment": {
              "type": "string",
              "example": "1.2"
            },
            "fees": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            },
            "simulate": {
              "type": "boolean",
              "example": false,
              "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
            }
          }
        },
        "exchange_rates": {
          "type": "string",
          "example": "1000.0ukrw,1.2uusd,0.99usdr",
          "description": "proof exchange rates of Luna in denom currency were used to make aggregate prevote hash"
        },
        "salt": {
          "type": "string",
          "example": "abcd",
          "description": "proof salt was used to make prevote hash; initial prevote does not require this field"
        }
      }
    },
    "DelegateReq": {
      "type": "object",
      "properties": {
        "base_req": {
          "type": "object",
          "properties": {
            "from": {
              "type": "string",
              "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
              "description": "Sender address or Keybase name to generate a transaction"
            },
            "memo": {
              "type": "string",
              "example": "Sent via Terra Station 🚀"
            },
            "chain_id": {
              "type": "string",
              "example": "Columbus-5"
            },
            "account_number": {
              "type": "string",
              "example": "0"
            },
            "sequence": {
              "type": "string",
              "example": "1"
            },
            "gas": {
              "type": "string",
              "example": "200000"
            },
            "gas_adjustment": {
              "type": "string",
              "example": "1.2"
            },
            "fees": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            },
            "simulate": {
              "type": "boolean",
              "example": false,
              "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
            }
          }
        },
        "feeder": {
          "type": "string",
          "description": "bech32 encoded address",
          "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
        }
      }
    },
    "ExchangeRateVote": {
      "type": "object",
      "properties": {
        "exchange_rate": {
          "type": "number",
          "example": "0.01241"
        },
        "denom": {
          "type": "string",
          "example": "ukrw"
        },
        "voter": {
          "type": "string",
          "description": "bech32 encoded address",
          "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
        }
      }
    },
    "ExchangeRatePrevote": {
      "type": "object",
      "properties": {
        "hash": {
          "type": "string",
          "example": "061bf1e27dfff121f40c826e593c8a28ec299a02"
        },
        "denom": {
          "type": "string",
          "example": "uusd"
        },
        "voter": {
          "type": "string",
          "description": "bech32 encoded address",
          "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
        },
        "submit_block": {
          "type": "number",
          "example": "1"
        }
      }
    },
    "AggregateExchangeRatePrevote": {
      "type": "object",
      "properties": {
        "hash": {
          "type": "string",
          "example": "061bf1e27dfff121f40c826e593c8a28ec299a02"
        },
        "voter": {
          "type": "string",
          "description": "bech32 encoded address",
          "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
        },
        "submit_block": {
          "type": "number",
          "example": "1"
        }
      }
    },
    "AggregateExchangeRateVote": {
      "type": "object",
      "properties": {
        "exchange_rates": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string",
                "example": "ukrw"
              },
              "amount": {
                "type": "string",
                "example": "50.000"
              }
            }
          }
        },
        "voter": {
          "type": "string",
          "description": "bech32 encoded address",
          "example": "terravaloper1wg2mlrxdmnnkkykgqg4znky86nyrtc45q7a85l"
        }
      }
    },
    "OracleParams": {
      "type": "object",
      "properties": {
        "vote_period": {
          "type": "number",
          "example": "900"
        },
        "vote_threshold": {
          "type": "number",
          "example": "0.67"
        },
        "drop_threshold": {
          "type": "number",
          "example": "10"
        },
        "oracle_reward_band": {
          "type": "number",
          "example": "0.02"
        }
      }
    },
    "PolicyConstraints": {
      "type": "object",
      "properties": {
        "rate_min": {
          "type": "number",
          "format": "float",
          "example": "0.0005",
          "description": "0.05%"
        },
        "rate_max": {
          "type": "number",
          "format": "float",
          "example": "0.01",
          "description": "1%"
        },
        "cap": {
          "type": "object",
          "properties": {
            "denom": {
              "type": "string",
              "example": "uluna"
            },
            "amount": {
              "type": "string",
              "example": "50"
            }
          }
        },
        "change_max": {
          "type": "number",
          "format": "float",
          "example": "0.00025",
          "description": "0.025%"
        }
      }
    },
    "TreasuryParams": {
      "type": "object",
      "properties": {
        "tax_policy": {
          "type": "object",
          "properties": {
            "rate_min": {
              "type": "number",
              "format": "float",
              "example": "0.0005",
              "description": "0.05%"
            },
            "rate_max": {
              "type": "number",
              "format": "float",
              "example": "0.01",
              "description": "1%"
            },
            "cap": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string",
                  "example": "uluna"
                },
                "amount": {
                  "type": "string",
                  "example": "50"
                }
              }
            },
            "change_max": {
              "type": "number",
              "format": "float",
              "example": "0.00025",
              "description": "0.025%"
            }
          }
        },
        "reward_policy": {
          "type": "object",
          "properties": {
            "rate_min": {
              "type": "number",
              "format": "float",
              "example": "0.0005",
              "description": "0.05%"
            },
            "rate_max": {
              "type": "number",
              "format": "float",
              "example": "0.01",
              "description": "1%"
            },
            "cap": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string",
                  "example": "uluna"
                },
                "amount": {
                  "type": "string",
                  "example": "50"
                }
              }
            },
            "change_max": {
              "type": "number",
              "format": "float",
              "example": "0.00025",
              "description": "0.025%"
            }
          }
        },
        "seigniorage_burden_target": {
          "type": "number",
          "format": "float",
          "example": "0.67",
          "description": "67%"
        },
        "mining_increment": {
          "type": "number",
          "format": "float",
          "example": "1.07"
        },
        "window_short": {
          "type": "integer",
          "example": "4"
        },
        "window_long": {
          "type": "integer",
          "example": "52"
        },
        "window_probation": {
          "type": "integer",
          "example": "12"
        }
      }
    },
    "WasmParams": {
      "type": "object",
      "properties": {
        "max_contract_size": {
          "type": "number",
          "format": "integer",
          "example": "1000000",
          "description": "allowed max contract bytes size"
        },
        "max_contract_gas": {
          "type": "number",
          "format": "integer",
          "example": "1000000",
          "description": "allowed max gas usages per each contract execution"
        },
        "max_contract_msg_size": {
          "type": "number",
          "format": "integer",
          "example": "1000000",
          "description": "allowed max contract exe msg bytes size"
        },
        "max_contract_data_size": {
          "type": "number",
          "format": "integer",
          "example": "100",
          "description": "allowed max contract return data size"
        },
        "event_params": {
          "type": "object",
          "properties": {
            "max_attribute_num": {
              "type": "string",
              "example": "128",
              "description": "allowed max # of contract attribute num"
            },
            "max_attribute_key_length": {
              "type": "string",
              "example": "128",
              "description": "allowed max length of a contract event attribute key"
            },
            "max_attribute_value_length": {
              "type": "string",
              "example": "128",
              "description": "allowed max length of a contract event attribute value"
            }
          }
        }
      }
    },
    "MultiSignPubKey": {
      "type": "object",
      "properties": {
        "threshold": {
          "type": "number",
          "example": 1
        },
        "pubkeys": {
          "type": "array",
          "items": {
            "type": "string",
            "example": "terrapub1addwnpepq2l6pwj8h9fwxdjuge7lazu0sszpkck0nlhjag6q9drffrd93atywdt8ksu"
          }
        }
      }
    },
    "StdSignature": {
      "type": "object",
      "properties": {
        "signature": {
          "type": "string",
          "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
        },
        "pub_key": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "example": "tendermint/PubKeySecp256k1"
            },
            "value": {
              "type": "string",
              "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
            }
          }
        }
      }
    },
    "EstimateFeeResp": {
      "type": "object",
      "properties": {
        "fee": {
          "type": "object",
          "properties": {
            "gas": {
              "type": "string"
            },
            "amount": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            }
          }
        }
      }
    },
    "CodeInfo": {
      "type": "object",
      "properties": {
        "code_hash": {
          "type": "string"
        },
        "creator": {
          "type": "string"
        }
      }
    },
    "ContractInfo": {
      "type": "object",
      "properties": {
        "code_id": {
          "type": "string"
        },
        "address": {
          "type": "string",
          "description": "bech32 encoded address",
          "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
        },
        "creator": {
          "type": "string",
          "description": "bech32 encoded address",
          "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
        },
        "admin": {
          "type": "string",
          "description": "bech32 encoded address",
          "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
        },
        "init_msg": {
          "type": "string"
        }
      }
    },
    "StoreCodeReq": {
      "type": "object",
      "properties": {
        "base_req": {
          "type": "object",
          "properties": {
            "from": {
              "type": "string",
              "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
              "description": "Sender address or Keybase name to generate a transaction"
            },
            "memo": {
              "type": "string",
              "example": "Sent via Terra Station 🚀"
            },
            "chain_id": {
              "type": "string",
              "example": "Columbus-5"
            },
            "account_number": {
              "type": "string",
              "example": "0"
            },
            "sequence": {
              "type": "string",
              "example": "1"
            },
            "gas": {
              "type": "string",
              "example": "200000"
            },
            "gas_adjustment": {
              "type": "string",
              "example": "1.2"
            },
            "fees": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            },
            "simulate": {
              "type": "boolean",
              "example": false,
              "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
            }
          }
        },
        "wasm_bytes": {
          "type": "string",
          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
        }
      }
    },
    "MigrateCodeReq": {
      "type": "object",
      "properties": {
        "base_req": {
          "type": "object",
          "properties": {
            "from": {
              "type": "string",
              "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
              "description": "Sender address or Keybase name to generate a transaction"
            },
            "memo": {
              "type": "string",
              "example": "Sent via Terra Station 🚀"
            },
            "chain_id": {
              "type": "string",
              "example": "Columbus-5"
            },
            "account_number": {
              "type": "string",
              "example": "0"
            },
            "sequence": {
              "type": "string",
              "example": "1"
            },
            "gas": {
              "type": "string",
              "example": "200000"
            },
            "gas_adjustment": {
              "type": "string",
              "example": "1.2"
            },
            "fees": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            },
            "simulate": {
              "type": "boolean",
              "example": false,
              "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
            }
          }
        },
        "wasm_bytes": {
          "type": "string",
          "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
        }
      }
    },
    "InstantiateContractReq": {
      "type": "object",
      "properties": {
        "base_req": {
          "type": "object",
          "properties": {
            "from": {
              "type": "string",
              "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
              "description": "Sender address or Keybase name to generate a transaction"
            },
            "memo": {
              "type": "string",
              "example": "Sent via Terra Station 🚀"
            },
            "chain_id": {
              "type": "string",
              "example": "Columbus-5"
            },
            "account_number": {
              "type": "string",
              "example": "0"
            },
            "sequence": {
              "type": "string",
              "example": "1"
            },
            "gas": {
              "type": "string",
              "example": "200000"
            },
            "gas_adjustment": {
              "type": "string",
              "example": "1.2"
            },
            "fees": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            },
            "simulate": {
              "type": "boolean",
              "example": false,
              "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
            }
          }
        },
        "init_coins": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string",
                "example": "uluna"
              },
              "amount": {
                "type": "string",
                "example": "50"
              }
            }
          }
        },
        "init_msg": {
          "type": "string",
          "description": "json formatted string",
          "example": "{}"
        },
        "admin": {
          "type": "string",
          "description": "bech32 encoded address",
          "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
        }
      }
    },
    "ExecuteContractReq": {
      "type": "object",
      "properties": {
        "base_req": {
          "type": "object",
          "properties": {
            "from": {
              "type": "string",
              "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
              "description": "Sender address or Keybase name to generate a transaction"
            },
            "memo": {
              "type": "string",
              "example": "Sent via Terra Station 🚀"
            },
            "chain_id": {
              "type": "string",
              "example": "Columbus-5"
            },
            "account_number": {
              "type": "string",
              "example": "0"
            },
            "sequence": {
              "type": "string",
              "example": "1"
            },
            "gas": {
              "type": "string",
              "example": "200000"
            },
            "gas_adjustment": {
              "type": "string",
              "example": "1.2"
            },
            "fees": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            },
            "simulate": {
              "type": "boolean",
              "example": false,
              "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
            }
          }
        },
        "coins": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string",
                "example": "uluna"
              },
              "amount": {
                "type": "string",
                "example": "50"
              }
            }
          }
        },
        "exec_msg": {
          "type": "string",
          "example": "{}"
        }
      }
    },
    "MigrateContractReq": {
      "type": "object",
      "properties": {
        "base_req": {
          "type": "object",
          "properties": {
            "from": {
              "type": "string",
              "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
              "description": "Sender address or Keybase name to generate a transaction"
            },
            "memo": {
              "type": "string",
              "example": "Sent via Terra Station 🚀"
            },
            "chain_id": {
              "type": "string",
              "example": "Columbus-5"
            },
            "account_number": {
              "type": "string",
              "example": "0"
            },
            "sequence": {
              "type": "string",
              "example": "1"
            },
            "gas": {
              "type": "string",
              "example": "200000"
            },
            "gas_adjustment": {
              "type": "string",
              "example": "1.2"
            },
            "fees": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            },
            "simulate": {
              "type": "boolean",
              "example": false,
              "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
            }
          }
        },
        "new_code_id": {
          "type": "number",
          "format": "integer",
          "example": 10
        },
        "migrate_msg": {
          "type": "string",
          "example": "{}"
        }
      }
    },
    "UpdateContractAdminReq": {
      "type": "object",
      "properties": {
        "base_req": {
          "type": "object",
          "properties": {
            "from": {
              "type": "string",
              "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
              "description": "Sender address or Keybase name to generate a transaction"
            },
            "memo": {
              "type": "string",
              "example": "Sent via Terra Station 🚀"
            },
            "chain_id": {
              "type": "string",
              "example": "Columbus-5"
            },
            "account_number": {
              "type": "string",
              "example": "0"
            },
            "sequence": {
              "type": "string",
              "example": "1"
            },
            "gas": {
              "type": "string",
              "example": "200000"
            },
            "gas_adjustment": {
              "type": "string",
              "example": "1.2"
            },
            "fees": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            },
            "simulate": {
              "type": "boolean",
              "example": false,
              "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
            }
          }
        },
        "new_admin": {
          "type": "string",
          "description": "bech32 encoded address",
          "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
        }
      }
    },
    "ClearContractAdminReq": {
      "type": "object",
      "properties": {
        "base_req": {
          "type": "object",
          "properties": {
            "from": {
              "type": "string",
              "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
              "description": "Sender address or Keybase name to generate a transaction"
            },
            "memo": {
              "type": "string",
              "example": "Sent via Terra Station 🚀"
            },
            "chain_id": {
              "type": "string",
              "example": "Columbus-5"
            },
            "account_number": {
              "type": "string",
              "example": "0"
            },
            "sequence": {
              "type": "string",
              "example": "1"
            },
            "gas": {
              "type": "string",
              "example": "200000"
            },
            "gas_adjustment": {
              "type": "string",
              "example": "1.2"
            },
            "fees": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            },
            "simulate": {
              "type": "boolean",
              "example": false,
              "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
            }
          }
        }
      }
    },
    "GenericAuthorization": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "example": "msgauth/GenericAuthorization"
        },
        "value": {
          "type": "object",
          "properties": {
            "msg_type": {
              "type": "string",
              "example": "send"
            }
          }
        }
      }
    },
    "SendAuthorization": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "example": "msgauth/SendAuthorization"
        },
        "value": {
          "type": "object",
          "properties": {
            "spend_limit": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            }
          }
        }
      }
    },
    "GenericGrantInfo": {
      "type": "object",
      "properties": {
        "authorization": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "example": "msgauth/GenericAuthorization"
            },
            "value": {
              "type": "object",
              "properties": {
                "msg_type": {
                  "type": "string",
                  "example": "send"
                }
              }
            }
          }
        },
        "expiration": {
          "type": "string",
          "example": "2021-06-24T09:33:20.012999Z"
        }
      }
    },
    "SendGrantInfo": {
      "type": "object",
      "properties": {
        "authorization": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "example": "msgauth/SendAuthorization"
            },
            "value": {
              "type": "object",
              "properties": {
                "spend_limit": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "example": "uluna"
                      },
                      "amount": {
                        "type": "string",
                        "example": "50"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "expiration": {
          "type": "string",
          "example": "2021-06-24T09:33:20.012999Z"
        }
      }
    },
    "GrantReq": {
      "type": "object",
      "required": [
        "base_req",
        "period"
      ],
      "properties": {
        "base_req": {
          "type": "object",
          "properties": {
            "from": {
              "type": "string",
              "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
              "description": "Sender address or Keybase name to generate a transaction"
            },
            "memo": {
              "type": "string",
              "example": "Sent via Terra Station 🚀"
            },
            "chain_id": {
              "type": "string",
              "example": "Columbus-5"
            },
            "account_number": {
              "type": "string",
              "example": "0"
            },
            "sequence": {
              "type": "string",
              "example": "1"
            },
            "gas": {
              "type": "string",
              "example": "200000"
            },
            "gas_adjustment": {
              "type": "string",
              "example": "1.2"
            },
            "fees": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            },
            "simulate": {
              "type": "boolean",
              "example": false,
              "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
            }
          }
        },
        "period": {
          "type": "string",
          "description": "nano second of time duration",
          "example": "3600000000000"
        },
        "limit": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string",
                "example": "uluna"
              },
              "amount": {
                "type": "string",
                "example": "50"
              }
            }
          },
          "description": "required when grant MsgType == send"
        }
      }
    },
    "RevokeGrantReq": {
      "type": "object",
      "required": [
        "base_req"
      ],
      "properties": {
        "base_req": {
          "type": "object",
          "properties": {
            "from": {
              "type": "string",
              "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
              "description": "Sender address or Keybase name to generate a transaction"
            },
            "memo": {
              "type": "string",
              "example": "Sent via Terra Station 🚀"
            },
            "chain_id": {
              "type": "string",
              "example": "Columbus-5"
            },
            "account_number": {
              "type": "string",
              "example": "0"
            },
            "sequence": {
              "type": "string",
              "example": "1"
            },
            "gas": {
              "type": "string",
              "example": "200000"
            },
            "gas_adjustment": {
              "type": "string",
              "example": "1.2"
            },
            "fees": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            },
            "simulate": {
              "type": "boolean",
              "example": false,
              "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
            }
          }
        }
      }
    },
    "ExecuteGrantReq": {
      "type": "object",
      "required": [
        "base_req",
        "msgs"
      ],
      "properties": {
        "base_req": {
          "type": "object",
          "properties": {
            "from": {
              "type": "string",
              "example": "terra1wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv",
              "description": "Sender address or Keybase name to generate a transaction"
            },
            "memo": {
              "type": "string",
              "example": "Sent via Terra Station 🚀"
            },
            "chain_id": {
              "type": "string",
              "example": "Columbus-5"
            },
            "account_number": {
              "type": "string",
              "example": "0"
            },
            "sequence": {
              "type": "string",
              "example": "1"
            },
            "gas": {
              "type": "string",
              "example": "200000"
            },
            "gas_adjustment": {
              "type": "string",
              "example": "1.2"
            },
            "fees": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "example": "uluna"
                  },
                  "amount": {
                    "type": "string",
                    "example": "50"
                  }
                }
              }
            },
            "simulate": {
              "type": "boolean",
              "example": false,
              "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)"
            }
          }
        },
        "msgs": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "TaxCap": {
      "type": "object",
      "properties": {
        "denom": {
          "type": "string",
          "example": "uluna"
        },
        "tax_cap": {
          "type": "string",
          "example": "50"
        }
      }
    },
    "cosmos.auth.v1beta1.Params": {
      "type": "object",
      "properties": {
        "max_memo_characters": {
          "type": "string",
          "format": "uint64"
        },
        "tx_sig_limit": {
          "type": "string",
          "format": "uint64"
        },
        "tx_size_cost_per_byte": {
          "type": "string",
          "format": "uint64"
        },
        "sig_verify_cost_ed25519": {
          "type": "string",
          "format": "uint64"
        },
        "sig_verify_cost_secp256k1": {
          "type": "string",
          "format": "uint64"
        }
      },
      "description": "Params defines the parameters for the auth module."
    },
    "cosmos.auth.v1beta1.QueryAccountResponse": {
      "type": "object",
      "properties": {
        "account": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        }
      },
      "description": "QueryAccountResponse is the response type for the Query/Account RPC method."
    },
    "cosmos.auth.v1beta1.QueryAccountsResponse": {
      "type": "object",
      "properties": {
        "accounts": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "type": "string",
                "format": "byte",
                "description": "Must be a valid serialized protocol buffer of the above specified type."
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "title": "accounts are the existing accounts"
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryAccountsResponse is the response type for the Query/Accounts RPC method.\n\nSince: cosmos-sdk 0.43"
    },
    "cosmos.auth.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params defines the parameters of the module.",
          "type": "object",
          "properties": {
            "max_memo_characters": {
              "type": "string",
              "format": "uint64"
            },
            "tx_sig_limit": {
              "type": "string",
              "format": "uint64"
            },
            "tx_size_cost_per_byte": {
              "type": "string",
              "format": "uint64"
            },
            "sig_verify_cost_ed25519": {
              "type": "string",
              "format": "uint64"
            },
            "sig_verify_cost_secp256k1": {
              "type": "string",
              "format": "uint64"
            }
          }
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "cosmos.base.query.v1beta1.PageRequest": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "format": "byte",
          "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set."
        },
        "offset": {
          "type": "string",
          "format": "uint64",
          "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set."
        },
        "limit": {
          "type": "string",
          "format": "uint64",
          "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app."
        },
        "count_total": {
          "type": "boolean",
          "format": "boolean",
          "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set."
        },
        "reverse": {
          "type": "boolean",
          "format": "boolean",
          "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43"
        }
      },
      "description": "message SomeRequest {\n         Foo some_parameter = 1;\n         PageRequest pagination = 2;\n }",
      "title": "PageRequest is to be embedded in gRPC request messages for efficient\npagination. Ex:"
    },
    "cosmos.base.query.v1beta1.PageResponse": {
      "type": "object",
      "properties": {
        "next_key": {
          "type": "string",
          "format": "byte",
          "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
        },
        "total": {
          "type": "string",
          "format": "uint64",
          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
        }
      },
      "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
    },
    "google.protobuf.Any": {
      "type": "object",
      "properties": {
        "type_url": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        },
        "value": {
          "type": "string",
          "format": "byte",
          "description": "Must be a valid serialized protocol buffer of the above specified type."
        }
      },
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "grpc.gateway.runtime.Error": {
      "type": "object",
      "properties": {
        "error": {
          "type": "string"
        },
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "type": "string",
                "format": "byte",
                "description": "Must be a valid serialized protocol buffer of the above specified type."
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          }
        }
      }
    },
    "cosmos.authz.v1beta1.Grant": {
      "type": "object",
      "properties": {
        "authorization": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        },
        "expiration": {
          "type": "string",
          "format": "date-time"
        }
      },
      "description": "Grant gives permissions to execute\nthe provide method with expiration time."
    },
    "cosmos.authz.v1beta1.QueryGrantsResponse": {
      "type": "object",
      "properties": {
        "grants": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "authorization": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "expiration": {
                "type": "string",
                "format": "date-time"
              }
            },
            "description": "Grant gives permissions to execute\nthe provide method with expiration time."
          },
          "description": "authorizations is a list of grants granted for grantee by granter."
        },
        "pagination": {
          "description": "pagination defines an pagination for the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryGrantsResponse is the response type for the Query/Authorizations RPC method."
    },
    "cosmos.bank.v1beta1.DenomUnit": {
      "type": "object",
      "properties": {
        "denom": {
          "type": "string",
          "description": "denom represents the string name of the given denom unit (e.g uatom)."
        },
        "exponent": {
          "type": "integer",
          "format": "int64",
          "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 1^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom)."
        },
        "aliases": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "aliases is a list of string aliases for the given denom"
        }
      },
      "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token."
    },
    "cosmos.bank.v1beta1.Metadata": {
      "type": "object",
      "properties": {
        "description": {
          "type": "string"
        },
        "denom_units": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string",
                "description": "denom represents the string name of the given denom unit (e.g uatom)."
              },
              "exponent": {
                "type": "integer",
                "format": "int64",
                "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 1^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom)."
              },
              "aliases": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "aliases is a list of string aliases for the given denom"
              }
            },
            "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token."
          },
          "title": "denom_units represents the list of DenomUnit's for a given coin"
        },
        "base": {
          "type": "string",
          "description": "base represents the base denom (should be the DenomUnit with exponent = 0)."
        },
        "display": {
          "type": "string",
          "description": "display indicates the suggested denom that should be\ndisplayed in clients."
        },
        "name": {
          "type": "string",
          "description": "Since: cosmos-sdk 0.43",
          "title": "name defines the name of the token (eg: Cosmos Atom)"
        },
        "symbol": {
          "type": "string",
          "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.\n\nSince: cosmos-sdk 0.43"
        }
      },
      "description": "Metadata represents a struct that describes\na basic token."
    },
    "cosmos.bank.v1beta1.Params": {
      "type": "object",
      "properties": {
        "send_enabled": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "enabled": {
                "type": "boolean",
                "format": "boolean"
              }
            },
            "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is\nsendable)."
          }
        },
        "default_send_enabled": {
          "type": "boolean",
          "format": "boolean"
        }
      },
      "description": "Params defines the parameters for the bank module."
    },
    "cosmos.bank.v1beta1.QueryAllBalancesResponse": {
      "type": "object",
      "properties": {
        "balances": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          },
          "description": "balances is the balances of all the coins."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryAllBalancesResponse is the response type for the Query/AllBalances RPC\nmethod."
    },
    "cosmos.bank.v1beta1.QueryBalanceResponse": {
      "type": "object",
      "properties": {
        "balance": {
          "type": "object",
          "properties": {
            "denom": {
              "type": "string"
            },
            "amount": {
              "type": "string"
            }
          },
          "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
        }
      },
      "description": "QueryBalanceResponse is the response type for the Query/Balance RPC method."
    },
    "cosmos.bank.v1beta1.QueryDenomMetadataResponse": {
      "type": "object",
      "properties": {
        "metadata": {
          "type": "object",
          "properties": {
            "description": {
              "type": "string"
            },
            "denom_units": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "description": "denom represents the string name of the given denom unit (e.g uatom)."
                  },
                  "exponent": {
                    "type": "integer",
                    "format": "int64",
                    "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 1^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom)."
                  },
                  "aliases": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "title": "aliases is a list of string aliases for the given denom"
                  }
                },
                "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token."
              },
              "title": "denom_units represents the list of DenomUnit's for a given coin"
            },
            "base": {
              "type": "string",
              "description": "base represents the base denom (should be the DenomUnit with exponent = 0)."
            },
            "display": {
              "type": "string",
              "description": "display indicates the suggested denom that should be\ndisplayed in clients."
            },
            "name": {
              "type": "string",
              "description": "Since: cosmos-sdk 0.43",
              "title": "name defines the name of the token (eg: Cosmos Atom)"
            },
            "symbol": {
              "type": "string",
              "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.\n\nSince: cosmos-sdk 0.43"
            }
          },
          "description": "Metadata represents a struct that describes\na basic token."
        }
      },
      "description": "QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC\nmethod."
    },
    "cosmos.bank.v1beta1.QueryDenomsMetadataResponse": {
      "type": "object",
      "properties": {
        "metadatas": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "description": {
                "type": "string"
              },
              "denom_units": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string",
                      "description": "denom represents the string name of the given denom unit (e.g uatom)."
                    },
                    "exponent": {
                      "type": "integer",
                      "format": "int64",
                      "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 1^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom)."
                    },
                    "aliases": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "title": "aliases is a list of string aliases for the given denom"
                    }
                  },
                  "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token."
                },
                "title": "denom_units represents the list of DenomUnit's for a given coin"
              },
              "base": {
                "type": "string",
                "description": "base represents the base denom (should be the DenomUnit with exponent = 0)."
              },
              "display": {
                "type": "string",
                "description": "display indicates the suggested denom that should be\ndisplayed in clients."
              },
              "name": {
                "type": "string",
                "description": "Since: cosmos-sdk 0.43",
                "title": "name defines the name of the token (eg: Cosmos Atom)"
              },
              "symbol": {
                "type": "string",
                "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.\n\nSince: cosmos-sdk 0.43"
              }
            },
            "description": "Metadata represents a struct that describes\na basic token."
          },
          "description": "metadata provides the client information for all the registered tokens."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC\nmethod."
    },
    "cosmos.bank.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "type": "object",
          "properties": {
            "send_enabled": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "enabled": {
                    "type": "boolean",
                    "format": "boolean"
                  }
                },
                "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is\nsendable)."
              }
            },
            "default_send_enabled": {
              "type": "boolean",
              "format": "boolean"
            }
          },
          "description": "Params defines the parameters for the bank module."
        }
      },
      "description": "QueryParamsResponse defines the response type for querying x/bank parameters."
    },
    "cosmos.bank.v1beta1.QuerySupplyOfResponse": {
      "type": "object",
      "properties": {
        "amount": {
          "type": "object",
          "properties": {
            "denom": {
              "type": "string"
            },
            "amount": {
              "type": "string"
            }
          },
          "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
        }
      },
      "description": "QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method."
    },
    "cosmos.bank.v1beta1.QueryTotalSupplyResponse": {
      "type": "object",
      "properties": {
        "supply": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          },
          "title": "supply is the supply of the coins"
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.\n\nSince: cosmos-sdk 0.43",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "title": "QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC\nmethod"
    },
    "cosmos.bank.v1beta1.SendEnabled": {
      "type": "object",
      "properties": {
        "denom": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean",
          "format": "boolean"
        }
      },
      "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is\nsendable)."
    },
    "cosmos.base.v1beta1.Coin": {
      "type": "object",
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
    },
    "cosmos.base.tendermint.v1beta1.GetBlockByHeightResponse": {
      "type": "object",
      "properties": {
        "block_id": {
          "type": "object",
          "properties": {
            "hash": {
              "type": "string",
              "format": "byte"
            },
            "part_set_header": {
              "type": "object",
              "properties": {
                "total": {
                  "type": "integer",
                  "format": "int64"
                },
                "hash": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "title": "PartsetHeader"
            }
          },
          "title": "BlockID"
        },
        "block": {
          "type": "object",
          "properties": {
            "header": {
              "type": "object",
              "properties": {
                "version": {
                  "title": "basic block info",
                  "type": "object",
                  "properties": {
                    "block": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "app": {
                      "type": "string",
                      "format": "uint64"
                    }
                  },
                  "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                },
                "chain_id": {
                  "type": "string"
                },
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "time": {
                  "type": "string",
                  "format": "date-time"
                },
                "last_block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "last_commit_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes of block data"
                },
                "data_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "validators_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes from the app output from the prev block"
                },
                "next_validators_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "consensus_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "app_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "last_results_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "evidence_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "consensus info"
                },
                "proposer_address": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "description": "Header defines the structure of a Tendermint block header."
            },
            "data": {
              "type": "object",
              "properties": {
                "txs": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "byte"
                  },
                  "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs."
                }
              },
              "title": "Data contains the set of transactions included in the block"
            },
            "evidence": {
              "type": "object",
              "properties": {
                "evidence": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "duplicate_vote_evidence": {
                        "type": "object",
                        "properties": {
                          "vote_a": {
                            "type": "object",
                            "properties": {
                              "type": {
                                "type": "string",
                                "enum": [
                                  "SIGNED_MSG_TYPE_UNKNOWN",
                                  "SIGNED_MSG_TYPE_PREVOTE",
                                  "SIGNED_MSG_TYPE_PRECOMMIT",
                                  "SIGNED_MSG_TYPE_PROPOSAL"
                                ],
                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                              },
                              "height": {
                                "type": "string",
                                "format": "int64"
                              },
                              "round": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "block_id": {
                                "type": "object",
                                "properties": {
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "part_set_header": {
                                    "type": "object",
                                    "properties": {
                                      "total": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "title": "PartsetHeader"
                                  }
                                },
                                "title": "BlockID"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "validator_index": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                          },
                          "vote_b": {
                            "type": "object",
                            "properties": {
                              "type": {
                                "type": "string",
                                "enum": [
                                  "SIGNED_MSG_TYPE_UNKNOWN",
                                  "SIGNED_MSG_TYPE_PREVOTE",
                                  "SIGNED_MSG_TYPE_PRECOMMIT",
                                  "SIGNED_MSG_TYPE_PROPOSAL"
                                ],
                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                              },
                              "height": {
                                "type": "string",
                                "format": "int64"
                              },
                              "round": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "block_id": {
                                "type": "object",
                                "properties": {
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "part_set_header": {
                                    "type": "object",
                                    "properties": {
                                      "total": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "title": "PartsetHeader"
                                  }
                                },
                                "title": "BlockID"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "validator_index": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                          },
                          "total_voting_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "validator_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          }
                        },
                        "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                      },
                      "light_client_attack_evidence": {
                        "type": "object",
                        "properties": {
                          "conflicting_block": {
                            "type": "object",
                            "properties": {
                              "signed_header": {
                                "type": "object",
                                "properties": {
                                  "header": {
                                    "type": "object",
                                    "properties": {
                                      "version": {
                                        "title": "basic block info",
                                        "type": "object",
                                        "properties": {
                                          "block": {
                                            "type": "string",
                                            "format": "uint64"
                                          },
                                          "app": {
                                            "type": "string",
                                            "format": "uint64"
                                          }
                                        },
                                        "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                      },
                                      "chain_id": {
                                        "type": "string"
                                      },
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "time": {
                                        "type": "string",
                                        "format": "date-time"
                                      },
                                      "last_block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "last_commit_hash": {
                                        "type": "string",
                                        "format": "byte",
                                        "title": "hashes of block data"
                                      },
                                      "data_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "validators_hash": {
                                        "type": "string",
                                        "format": "byte",
                                        "title": "hashes from the app output from the prev block"
                                      },
                                      "next_validators_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "consensus_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "app_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "last_results_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "evidence_hash": {
                                        "type": "string",
                                        "format": "byte",
                                        "title": "consensus info"
                                      },
                                      "proposer_address": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "description": "Header defines the structure of a Tendermint block header."
                                  },
                                  "commit": {
                                    "type": "object",
                                    "properties": {
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "round": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "signatures": {
                                        "type": "array",
                                        "items": {
                                          "type": "object",
                                          "properties": {
                                            "block_id_flag": {
                                              "type": "string",
                                              "enum": [
                                                "BLOCK_ID_FLAG_UNKNOWN",
                                                "BLOCK_ID_FLAG_ABSENT",
                                                "BLOCK_ID_FLAG_COMMIT",
                                                "BLOCK_ID_FLAG_NIL"
                                              ],
                                              "default": "BLOCK_ID_FLAG_UNKNOWN",
                                              "title": "BlockIdFlag indicates which BlcokID the signature is for"
                                            },
                                            "validator_address": {
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "timestamp": {
                                              "type": "string",
                                              "format": "date-time"
                                            },
                                            "signature": {
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          },
                                          "description": "CommitSig is a part of the Vote included in a Commit."
                                        }
                                      }
                                    },
                                    "description": "Commit contains the evidence that a block was committed by a set of validators."
                                  }
                                }
                              },
                              "validator_set": {
                                "type": "object",
                                "properties": {
                                  "validators": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "address": {
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "pub_key": {
                                          "type": "object",
                                          "properties": {
                                            "ed25519": {
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "secp256k1": {
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          },
                                          "title": "PublicKey defines the keys available for use with Tendermint Validators"
                                        },
                                        "voting_power": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "proposer_priority": {
                                          "type": "string",
                                          "format": "int64"
                                        }
                                      }
                                    }
                                  },
                                  "proposer": {
                                    "type": "object",
                                    "properties": {
                                      "address": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "pub_key": {
                                        "type": "object",
                                        "properties": {
                                          "ed25519": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "secp256k1": {
                                            "type": "string",
                                            "format": "byte"
                                          }
                                        },
                                        "title": "PublicKey defines the keys available for use with Tendermint Validators"
                                      },
                                      "voting_power": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "proposer_priority": {
                                        "type": "string",
                                        "format": "int64"
                                      }
                                    }
                                  },
                                  "total_voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  }
                                }
                              }
                            }
                          },
                          "common_height": {
                            "type": "string",
                            "format": "int64"
                          },
                          "byzantine_validators": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "address": {
                                  "type": "string",
                                  "format": "byte"
                                },
                                "pub_key": {
                                  "type": "object",
                                  "properties": {
                                    "ed25519": {
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "secp256k1": {
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  },
                                  "title": "PublicKey defines the keys available for use with Tendermint Validators"
                                },
                                "voting_power": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "proposer_priority": {
                                  "type": "string",
                                  "format": "int64"
                                }
                              }
                            }
                          },
                          "total_voting_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          }
                        },
                        "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                      }
                    }
                  }
                }
              }
            },
            "last_commit": {
              "type": "object",
              "properties": {
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "round": {
                  "type": "integer",
                  "format": "int32"
                },
                "block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "signatures": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "block_id_flag": {
                        "type": "string",
                        "enum": [
                          "BLOCK_ID_FLAG_UNKNOWN",
                          "BLOCK_ID_FLAG_ABSENT",
                          "BLOCK_ID_FLAG_COMMIT",
                          "BLOCK_ID_FLAG_NIL"
                        ],
                        "default": "BLOCK_ID_FLAG_UNKNOWN",
                        "title": "BlockIdFlag indicates which BlcokID the signature is for"
                      },
                      "validator_address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "timestamp": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "signature": {
                        "type": "string",
                        "format": "byte"
                      }
                    },
                    "description": "CommitSig is a part of the Vote included in a Commit."
                  }
                }
              },
              "description": "Commit contains the evidence that a block was committed by a set of validators."
            }
          }
        }
      },
      "description": "GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method."
    },
    "cosmos.base.tendermint.v1beta1.GetLatestBlockResponse": {
      "type": "object",
      "properties": {
        "block_id": {
          "type": "object",
          "properties": {
            "hash": {
              "type": "string",
              "format": "byte"
            },
            "part_set_header": {
              "type": "object",
              "properties": {
                "total": {
                  "type": "integer",
                  "format": "int64"
                },
                "hash": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "title": "PartsetHeader"
            }
          },
          "title": "BlockID"
        },
        "block": {
          "type": "object",
          "properties": {
            "header": {
              "type": "object",
              "properties": {
                "version": {
                  "title": "basic block info",
                  "type": "object",
                  "properties": {
                    "block": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "app": {
                      "type": "string",
                      "format": "uint64"
                    }
                  },
                  "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                },
                "chain_id": {
                  "type": "string"
                },
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "time": {
                  "type": "string",
                  "format": "date-time"
                },
                "last_block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "last_commit_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes of block data"
                },
                "data_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "validators_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes from the app output from the prev block"
                },
                "next_validators_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "consensus_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "app_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "last_results_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "evidence_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "consensus info"
                },
                "proposer_address": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "description": "Header defines the structure of a Tendermint block header."
            },
            "data": {
              "type": "object",
              "properties": {
                "txs": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "byte"
                  },
                  "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs."
                }
              },
              "title": "Data contains the set of transactions included in the block"
            },
            "evidence": {
              "type": "object",
              "properties": {
                "evidence": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "duplicate_vote_evidence": {
                        "type": "object",
                        "properties": {
                          "vote_a": {
                            "type": "object",
                            "properties": {
                              "type": {
                                "type": "string",
                                "enum": [
                                  "SIGNED_MSG_TYPE_UNKNOWN",
                                  "SIGNED_MSG_TYPE_PREVOTE",
                                  "SIGNED_MSG_TYPE_PRECOMMIT",
                                  "SIGNED_MSG_TYPE_PROPOSAL"
                                ],
                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                              },
                              "height": {
                                "type": "string",
                                "format": "int64"
                              },
                              "round": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "block_id": {
                                "type": "object",
                                "properties": {
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "part_set_header": {
                                    "type": "object",
                                    "properties": {
                                      "total": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "title": "PartsetHeader"
                                  }
                                },
                                "title": "BlockID"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "validator_index": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                          },
                          "vote_b": {
                            "type": "object",
                            "properties": {
                              "type": {
                                "type": "string",
                                "enum": [
                                  "SIGNED_MSG_TYPE_UNKNOWN",
                                  "SIGNED_MSG_TYPE_PREVOTE",
                                  "SIGNED_MSG_TYPE_PRECOMMIT",
                                  "SIGNED_MSG_TYPE_PROPOSAL"
                                ],
                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                              },
                              "height": {
                                "type": "string",
                                "format": "int64"
                              },
                              "round": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "block_id": {
                                "type": "object",
                                "properties": {
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "part_set_header": {
                                    "type": "object",
                                    "properties": {
                                      "total": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "title": "PartsetHeader"
                                  }
                                },
                                "title": "BlockID"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "validator_index": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                          },
                          "total_voting_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "validator_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          }
                        },
                        "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                      },
                      "light_client_attack_evidence": {
                        "type": "object",
                        "properties": {
                          "conflicting_block": {
                            "type": "object",
                            "properties": {
                              "signed_header": {
                                "type": "object",
                                "properties": {
                                  "header": {
                                    "type": "object",
                                    "properties": {
                                      "version": {
                                        "title": "basic block info",
                                        "type": "object",
                                        "properties": {
                                          "block": {
                                            "type": "string",
                                            "format": "uint64"
                                          },
                                          "app": {
                                            "type": "string",
                                            "format": "uint64"
                                          }
                                        },
                                        "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                      },
                                      "chain_id": {
                                        "type": "string"
                                      },
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "time": {
                                        "type": "string",
                                        "format": "date-time"
                                      },
                                      "last_block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "last_commit_hash": {
                                        "type": "string",
                                        "format": "byte",
                                        "title": "hashes of block data"
                                      },
                                      "data_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "validators_hash": {
                                        "type": "string",
                                        "format": "byte",
                                        "title": "hashes from the app output from the prev block"
                                      },
                                      "next_validators_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "consensus_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "app_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "last_results_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "evidence_hash": {
                                        "type": "string",
                                        "format": "byte",
                                        "title": "consensus info"
                                      },
                                      "proposer_address": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "description": "Header defines the structure of a Tendermint block header."
                                  },
                                  "commit": {
                                    "type": "object",
                                    "properties": {
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "round": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "signatures": {
                                        "type": "array",
                                        "items": {
                                          "type": "object",
                                          "properties": {
                                            "block_id_flag": {
                                              "type": "string",
                                              "enum": [
                                                "BLOCK_ID_FLAG_UNKNOWN",
                                                "BLOCK_ID_FLAG_ABSENT",
                                                "BLOCK_ID_FLAG_COMMIT",
                                                "BLOCK_ID_FLAG_NIL"
                                              ],
                                              "default": "BLOCK_ID_FLAG_UNKNOWN",
                                              "title": "BlockIdFlag indicates which BlcokID the signature is for"
                                            },
                                            "validator_address": {
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "timestamp": {
                                              "type": "string",
                                              "format": "date-time"
                                            },
                                            "signature": {
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          },
                                          "description": "CommitSig is a part of the Vote included in a Commit."
                                        }
                                      }
                                    },
                                    "description": "Commit contains the evidence that a block was committed by a set of validators."
                                  }
                                }
                              },
                              "validator_set": {
                                "type": "object",
                                "properties": {
                                  "validators": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "address": {
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "pub_key": {
                                          "type": "object",
                                          "properties": {
                                            "ed25519": {
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "secp256k1": {
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          },
                                          "title": "PublicKey defines the keys available for use with Tendermint Validators"
                                        },
                                        "voting_power": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "proposer_priority": {
                                          "type": "string",
                                          "format": "int64"
                                        }
                                      }
                                    }
                                  },
                                  "proposer": {
                                    "type": "object",
                                    "properties": {
                                      "address": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "pub_key": {
                                        "type": "object",
                                        "properties": {
                                          "ed25519": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "secp256k1": {
                                            "type": "string",
                                            "format": "byte"
                                          }
                                        },
                                        "title": "PublicKey defines the keys available for use with Tendermint Validators"
                                      },
                                      "voting_power": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "proposer_priority": {
                                        "type": "string",
                                        "format": "int64"
                                      }
                                    }
                                  },
                                  "total_voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  }
                                }
                              }
                            }
                          },
                          "common_height": {
                            "type": "string",
                            "format": "int64"
                          },
                          "byzantine_validators": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "address": {
                                  "type": "string",
                                  "format": "byte"
                                },
                                "pub_key": {
                                  "type": "object",
                                  "properties": {
                                    "ed25519": {
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "secp256k1": {
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  },
                                  "title": "PublicKey defines the keys available for use with Tendermint Validators"
                                },
                                "voting_power": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "proposer_priority": {
                                  "type": "string",
                                  "format": "int64"
                                }
                              }
                            }
                          },
                          "total_voting_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          }
                        },
                        "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                      }
                    }
                  }
                }
              }
            },
            "last_commit": {
              "type": "object",
              "properties": {
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "round": {
                  "type": "integer",
                  "format": "int32"
                },
                "block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "signatures": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "block_id_flag": {
                        "type": "string",
                        "enum": [
                          "BLOCK_ID_FLAG_UNKNOWN",
                          "BLOCK_ID_FLAG_ABSENT",
                          "BLOCK_ID_FLAG_COMMIT",
                          "BLOCK_ID_FLAG_NIL"
                        ],
                        "default": "BLOCK_ID_FLAG_UNKNOWN",
                        "title": "BlockIdFlag indicates which BlcokID the signature is for"
                      },
                      "validator_address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "timestamp": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "signature": {
                        "type": "string",
                        "format": "byte"
                      }
                    },
                    "description": "CommitSig is a part of the Vote included in a Commit."
                  }
                }
              },
              "description": "Commit contains the evidence that a block was committed by a set of validators."
            }
          }
        }
      },
      "description": "GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method."
    },
    "cosmos.base.tendermint.v1beta1.GetLatestValidatorSetResponse": {
      "type": "object",
      "properties": {
        "block_height": {
          "type": "string",
          "format": "int64"
        },
        "validators": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "pub_key": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "voting_power": {
                "type": "string",
                "format": "int64"
              },
              "proposer_priority": {
                "type": "string",
                "format": "int64"
              }
            },
            "description": "Validator is the type for the validator-set."
          }
        },
        "pagination": {
          "description": "pagination defines an pagination for the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method."
    },
    "cosmos.base.tendermint.v1beta1.GetNodeInfoResponse": {
      "type": "object",
      "properties": {
        "default_node_info": {
          "type": "object",
          "properties": {
            "protocol_version": {
              "type": "object",
              "properties": {
                "p2p": {
                  "type": "string",
                  "format": "uint64"
                },
                "block": {
                  "type": "string",
                  "format": "uint64"
                },
                "app": {
                  "type": "string",
                  "format": "uint64"
                }
              }
            },
            "default_node_id": {
              "type": "string"
            },
            "listen_addr": {
              "type": "string"
            },
            "network": {
              "type": "string"
            },
            "version": {
              "type": "string"
            },
            "channels": {
              "type": "string",
              "format": "byte"
            },
            "moniker": {
              "type": "string"
            },
            "other": {
              "type": "object",
              "properties": {
                "tx_index": {
                  "type": "string"
                },
                "rpc_address": {
                  "type": "string"
                }
              }
            }
          }
        },
        "application_version": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "app_name": {
              "type": "string"
            },
            "version": {
              "type": "string"
            },
            "git_commit": {
              "type": "string"
            },
            "build_tags": {
              "type": "string"
            },
            "go_version": {
              "type": "string"
            },
            "build_deps": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "path": {
                    "type": "string",
                    "title": "module path"
                  },
                  "version": {
                    "type": "string",
                    "title": "module version"
                  },
                  "sum": {
                    "type": "string",
                    "title": "checksum"
                  }
                },
                "title": "Module is the type for VersionInfo"
              }
            },
            "cosmos_sdk_version": {
              "type": "string",
              "title": "Since: cosmos-sdk 0.43"
            }
          },
          "description": "VersionInfo is the type for the GetNodeInfoResponse message."
        }
      },
      "description": "GetNodeInfoResponse is the request type for the Query/GetNodeInfo RPC method."
    },
    "cosmos.base.tendermint.v1beta1.GetSyncingResponse": {
      "type": "object",
      "properties": {
        "syncing": {
          "type": "boolean",
          "format": "boolean"
        }
      },
      "description": "GetSyncingResponse is the response type for the Query/GetSyncing RPC method."
    },
    "cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightResponse": {
      "type": "object",
      "properties": {
        "block_height": {
          "type": "string",
          "format": "int64"
        },
        "validators": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "pub_key": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "voting_power": {
                "type": "string",
                "format": "int64"
              },
              "proposer_priority": {
                "type": "string",
                "format": "int64"
              }
            },
            "description": "Validator is the type for the validator-set."
          }
        },
        "pagination": {
          "description": "pagination defines an pagination for the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method."
    },
    "cosmos.base.tendermint.v1beta1.Module": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "title": "module path"
        },
        "version": {
          "type": "string",
          "title": "module version"
        },
        "sum": {
          "type": "string",
          "title": "checksum"
        }
      },
      "title": "Module is the type for VersionInfo"
    },
    "cosmos.base.tendermint.v1beta1.Validator": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string"
        },
        "pub_key": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        },
        "voting_power": {
          "type": "string",
          "format": "int64"
        },
        "proposer_priority": {
          "type": "string",
          "format": "int64"
        }
      },
      "description": "Validator is the type for the validator-set."
    },
    "cosmos.base.tendermint.v1beta1.VersionInfo": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "app_name": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "git_commit": {
          "type": "string"
        },
        "build_tags": {
          "type": "string"
        },
        "go_version": {
          "type": "string"
        },
        "build_deps": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "path": {
                "type": "string",
                "title": "module path"
              },
              "version": {
                "type": "string",
                "title": "module version"
              },
              "sum": {
                "type": "string",
                "title": "checksum"
              }
            },
            "title": "Module is the type for VersionInfo"
          }
        },
        "cosmos_sdk_version": {
          "type": "string",
          "title": "Since: cosmos-sdk 0.43"
        }
      },
      "description": "VersionInfo is the type for the GetNodeInfoResponse message."
    },
    "tendermint.crypto.PublicKey": {
      "type": "object",
      "properties": {
        "ed25519": {
          "type": "string",
          "format": "byte"
        },
        "secp256k1": {
          "type": "string",
          "format": "byte"
        }
      },
      "title": "PublicKey defines the keys available for use with Tendermint Validators"
    },
    "tendermint.p2p.DefaultNodeInfo": {
      "type": "object",
      "properties": {
        "protocol_version": {
          "type": "object",
          "properties": {
            "p2p": {
              "type": "string",
              "format": "uint64"
            },
            "block": {
              "type": "string",
              "format": "uint64"
            },
            "app": {
              "type": "string",
              "format": "uint64"
            }
          }
        },
        "default_node_id": {
          "type": "string"
        },
        "listen_addr": {
          "type": "string"
        },
        "network": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "channels": {
          "type": "string",
          "format": "byte"
        },
        "moniker": {
          "type": "string"
        },
        "other": {
          "type": "object",
          "properties": {
            "tx_index": {
              "type": "string"
            },
            "rpc_address": {
              "type": "string"
            }
          }
        }
      }
    },
    "tendermint.p2p.DefaultNodeInfoOther": {
      "type": "object",
      "properties": {
        "tx_index": {
          "type": "string"
        },
        "rpc_address": {
          "type": "string"
        }
      }
    },
    "tendermint.p2p.ProtocolVersion": {
      "type": "object",
      "properties": {
        "p2p": {
          "type": "string",
          "format": "uint64"
        },
        "block": {
          "type": "string",
          "format": "uint64"
        },
        "app": {
          "type": "string",
          "format": "uint64"
        }
      }
    },
    "tendermint.types.Block": {
      "type": "object",
      "properties": {
        "header": {
          "type": "object",
          "properties": {
            "version": {
              "title": "basic block info",
              "type": "object",
              "properties": {
                "block": {
                  "type": "string",
                  "format": "uint64"
                },
                "app": {
                  "type": "string",
                  "format": "uint64"
                }
              },
              "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
            },
            "chain_id": {
              "type": "string"
            },
            "height": {
              "type": "string",
              "format": "int64"
            },
            "time": {
              "type": "string",
              "format": "date-time"
            },
            "last_block_id": {
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "format": "byte"
                },
                "part_set_header": {
                  "type": "object",
                  "properties": {
                    "total": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "title": "PartsetHeader"
                }
              },
              "title": "BlockID"
            },
            "last_commit_hash": {
              "type": "string",
              "format": "byte",
              "title": "hashes of block data"
            },
            "data_hash": {
              "type": "string",
              "format": "byte"
            },
            "validators_hash": {
              "type": "string",
              "format": "byte",
              "title": "hashes from the app output from the prev block"
            },
            "next_validators_hash": {
              "type": "string",
              "format": "byte"
            },
            "consensus_hash": {
              "type": "string",
              "format": "byte"
            },
            "app_hash": {
              "type": "string",
              "format": "byte"
            },
            "last_results_hash": {
              "type": "string",
              "format": "byte"
            },
            "evidence_hash": {
              "type": "string",
              "format": "byte",
              "title": "consensus info"
            },
            "proposer_address": {
              "type": "string",
              "format": "byte"
            }
          },
          "description": "Header defines the structure of a Tendermint block header."
        },
        "data": {
          "type": "object",
          "properties": {
            "txs": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "byte"
              },
              "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs."
            }
          },
          "title": "Data contains the set of transactions included in the block"
        },
        "evidence": {
          "type": "object",
          "properties": {
            "evidence": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "duplicate_vote_evidence": {
                    "type": "object",
                    "properties": {
                      "vote_a": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string",
                            "enum": [
                              "SIGNED_MSG_TYPE_UNKNOWN",
                              "SIGNED_MSG_TYPE_PREVOTE",
                              "SIGNED_MSG_TYPE_PRECOMMIT",
                              "SIGNED_MSG_TYPE_PROPOSAL"
                            ],
                            "default": "SIGNED_MSG_TYPE_UNKNOWN",
                            "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                          },
                          "height": {
                            "type": "string",
                            "format": "int64"
                          },
                          "round": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "block_id": {
                            "type": "object",
                            "properties": {
                              "hash": {
                                "type": "string",
                                "format": "byte"
                              },
                              "part_set_header": {
                                "type": "object",
                                "properties": {
                                  "total": {
                                    "type": "integer",
                                    "format": "int64"
                                  },
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  }
                                },
                                "title": "PartsetHeader"
                              }
                            },
                            "title": "BlockID"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          },
                          "validator_address": {
                            "type": "string",
                            "format": "byte"
                          },
                          "validator_index": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "signature": {
                            "type": "string",
                            "format": "byte"
                          }
                        },
                        "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                      },
                      "vote_b": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string",
                            "enum": [
                              "SIGNED_MSG_TYPE_UNKNOWN",
                              "SIGNED_MSG_TYPE_PREVOTE",
                              "SIGNED_MSG_TYPE_PRECOMMIT",
                              "SIGNED_MSG_TYPE_PROPOSAL"
                            ],
                            "default": "SIGNED_MSG_TYPE_UNKNOWN",
                            "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                          },
                          "height": {
                            "type": "string",
                            "format": "int64"
                          },
                          "round": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "block_id": {
                            "type": "object",
                            "properties": {
                              "hash": {
                                "type": "string",
                                "format": "byte"
                              },
                              "part_set_header": {
                                "type": "object",
                                "properties": {
                                  "total": {
                                    "type": "integer",
                                    "format": "int64"
                                  },
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  }
                                },
                                "title": "PartsetHeader"
                              }
                            },
                            "title": "BlockID"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          },
                          "validator_address": {
                            "type": "string",
                            "format": "byte"
                          },
                          "validator_index": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "signature": {
                            "type": "string",
                            "format": "byte"
                          }
                        },
                        "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                      },
                      "total_voting_power": {
                        "type": "string",
                        "format": "int64"
                      },
                      "validator_power": {
                        "type": "string",
                        "format": "int64"
                      },
                      "timestamp": {
                        "type": "string",
                        "format": "date-time"
                      }
                    },
                    "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                  },
                  "light_client_attack_evidence": {
                    "type": "object",
                    "properties": {
                      "conflicting_block": {
                        "type": "object",
                        "properties": {
                          "signed_header": {
                            "type": "object",
                            "properties": {
                              "header": {
                                "type": "object",
                                "properties": {
                                  "version": {
                                    "title": "basic block info",
                                    "type": "object",
                                    "properties": {
                                      "block": {
                                        "type": "string",
                                        "format": "uint64"
                                      },
                                      "app": {
                                        "type": "string",
                                        "format": "uint64"
                                      }
                                    },
                                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                  },
                                  "chain_id": {
                                    "type": "string"
                                  },
                                  "height": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "time": {
                                    "type": "string",
                                    "format": "date-time"
                                  },
                                  "last_block_id": {
                                    "type": "object",
                                    "properties": {
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "part_set_header": {
                                        "type": "object",
                                        "properties": {
                                          "total": {
                                            "type": "integer",
                                            "format": "int64"
                                          },
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          }
                                        },
                                        "title": "PartsetHeader"
                                      }
                                    },
                                    "title": "BlockID"
                                  },
                                  "last_commit_hash": {
                                    "type": "string",
                                    "format": "byte",
                                    "title": "hashes of block data"
                                  },
                                  "data_hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "validators_hash": {
                                    "type": "string",
                                    "format": "byte",
                                    "title": "hashes from the app output from the prev block"
                                  },
                                  "next_validators_hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "consensus_hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "app_hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "last_results_hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "evidence_hash": {
                                    "type": "string",
                                    "format": "byte",
                                    "title": "consensus info"
                                  },
                                  "proposer_address": {
                                    "type": "string",
                                    "format": "byte"
                                  }
                                },
                                "description": "Header defines the structure of a Tendermint block header."
                              },
                              "commit": {
                                "type": "object",
                                "properties": {
                                  "height": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "round": {
                                    "type": "integer",
                                    "format": "int32"
                                  },
                                  "block_id": {
                                    "type": "object",
                                    "properties": {
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "part_set_header": {
                                        "type": "object",
                                        "properties": {
                                          "total": {
                                            "type": "integer",
                                            "format": "int64"
                                          },
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          }
                                        },
                                        "title": "PartsetHeader"
                                      }
                                    },
                                    "title": "BlockID"
                                  },
                                  "signatures": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "block_id_flag": {
                                          "type": "string",
                                          "enum": [
                                            "BLOCK_ID_FLAG_UNKNOWN",
                                            "BLOCK_ID_FLAG_ABSENT",
                                            "BLOCK_ID_FLAG_COMMIT",
                                            "BLOCK_ID_FLAG_NIL"
                                          ],
                                          "default": "BLOCK_ID_FLAG_UNKNOWN",
                                          "title": "BlockIdFlag indicates which BlcokID the signature is for"
                                        },
                                        "validator_address": {
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "timestamp": {
                                          "type": "string",
                                          "format": "date-time"
                                        },
                                        "signature": {
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      },
                                      "description": "CommitSig is a part of the Vote included in a Commit."
                                    }
                                  }
                                },
                                "description": "Commit contains the evidence that a block was committed by a set of validators."
                              }
                            }
                          },
                          "validator_set": {
                            "type": "object",
                            "properties": {
                              "validators": {
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "address": {
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "pub_key": {
                                      "type": "object",
                                      "properties": {
                                        "ed25519": {
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "secp256k1": {
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      },
                                      "title": "PublicKey defines the keys available for use with Tendermint Validators"
                                    },
                                    "voting_power": {
                                      "type": "string",
                                      "format": "int64"
                                    },
                                    "proposer_priority": {
                                      "type": "string",
                                      "format": "int64"
                                    }
                                  }
                                }
                              },
                              "proposer": {
                                "type": "object",
                                "properties": {
                                  "address": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "pub_key": {
                                    "type": "object",
                                    "properties": {
                                      "ed25519": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "secp256k1": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "title": "PublicKey defines the keys available for use with Tendermint Validators"
                                  },
                                  "voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "proposer_priority": {
                                    "type": "string",
                                    "format": "int64"
                                  }
                                }
                              },
                              "total_voting_power": {
                                "type": "string",
                                "format": "int64"
                              }
                            }
                          }
                        }
                      },
                      "common_height": {
                        "type": "string",
                        "format": "int64"
                      },
                      "byzantine_validators": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "address": {
                              "type": "string",
                              "format": "byte"
                            },
                            "pub_key": {
                              "type": "object",
                              "properties": {
                                "ed25519": {
                                  "type": "string",
                                  "format": "byte"
                                },
                                "secp256k1": {
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "title": "PublicKey defines the keys available for use with Tendermint Validators"
                            },
                            "voting_power": {
                              "type": "string",
                              "format": "int64"
                            },
                            "proposer_priority": {
                              "type": "string",
                              "format": "int64"
                            }
                          }
                        }
                      },
                      "total_voting_power": {
                        "type": "string",
                        "format": "int64"
                      },
                      "timestamp": {
                        "type": "string",
                        "format": "date-time"
                      }
                    },
                    "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                  }
                }
              }
            }
          }
        },
        "last_commit": {
          "type": "object",
          "properties": {
            "height": {
              "type": "string",
              "format": "int64"
            },
            "round": {
              "type": "integer",
              "format": "int32"
            },
            "block_id": {
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "format": "byte"
                },
                "part_set_header": {
                  "type": "object",
                  "properties": {
                    "total": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "title": "PartsetHeader"
                }
              },
              "title": "BlockID"
            },
            "signatures": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "block_id_flag": {
                    "type": "string",
                    "enum": [
                      "BLOCK_ID_FLAG_UNKNOWN",
                      "BLOCK_ID_FLAG_ABSENT",
                      "BLOCK_ID_FLAG_COMMIT",
                      "BLOCK_ID_FLAG_NIL"
                    ],
                    "default": "BLOCK_ID_FLAG_UNKNOWN",
                    "title": "BlockIdFlag indicates which BlcokID the signature is for"
                  },
                  "validator_address": {
                    "type": "string",
                    "format": "byte"
                  },
                  "timestamp": {
                    "type": "string",
                    "format": "date-time"
                  },
                  "signature": {
                    "type": "string",
                    "format": "byte"
                  }
                },
                "description": "CommitSig is a part of the Vote included in a Commit."
              }
            }
          },
          "description": "Commit contains the evidence that a block was committed by a set of validators."
        }
      }
    },
    "tendermint.types.BlockID": {
      "type": "object",
      "properties": {
        "hash": {
          "type": "string",
          "format": "byte"
        },
        "part_set_header": {
          "type": "object",
          "properties": {
            "total": {
              "type": "integer",
              "format": "int64"
            },
            "hash": {
              "type": "string",
              "format": "byte"
            }
          },
          "title": "PartsetHeader"
        }
      },
      "title": "BlockID"
    },
    "tendermint.types.BlockIDFlag": {
      "type": "string",
      "enum": [
        "BLOCK_ID_FLAG_UNKNOWN",
        "BLOCK_ID_FLAG_ABSENT",
        "BLOCK_ID_FLAG_COMMIT",
        "BLOCK_ID_FLAG_NIL"
      ],
      "default": "BLOCK_ID_FLAG_UNKNOWN",
      "title": "BlockIdFlag indicates which BlcokID the signature is for"
    },
    "tendermint.types.Commit": {
      "type": "object",
      "properties": {
        "height": {
          "type": "string",
          "format": "int64"
        },
        "round": {
          "type": "integer",
          "format": "int32"
        },
        "block_id": {
          "type": "object",
          "properties": {
            "hash": {
              "type": "string",
              "format": "byte"
            },
            "part_set_header": {
              "type": "object",
              "properties": {
                "total": {
                  "type": "integer",
                  "format": "int64"
                },
                "hash": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "title": "PartsetHeader"
            }
          },
          "title": "BlockID"
        },
        "signatures": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "block_id_flag": {
                "type": "string",
                "enum": [
                  "BLOCK_ID_FLAG_UNKNOWN",
                  "BLOCK_ID_FLAG_ABSENT",
                  "BLOCK_ID_FLAG_COMMIT",
                  "BLOCK_ID_FLAG_NIL"
                ],
                "default": "BLOCK_ID_FLAG_UNKNOWN",
                "title": "BlockIdFlag indicates which BlcokID the signature is for"
              },
              "validator_address": {
                "type": "string",
                "format": "byte"
              },
              "timestamp": {
                "type": "string",
                "format": "date-time"
              },
              "signature": {
                "type": "string",
                "format": "byte"
              }
            },
            "description": "CommitSig is a part of the Vote included in a Commit."
          }
        }
      },
      "description": "Commit contains the evidence that a block was committed by a set of validators."
    },
    "tendermint.types.CommitSig": {
      "type": "object",
      "properties": {
        "block_id_flag": {
          "type": "string",
          "enum": [
            "BLOCK_ID_FLAG_UNKNOWN",
            "BLOCK_ID_FLAG_ABSENT",
            "BLOCK_ID_FLAG_COMMIT",
            "BLOCK_ID_FLAG_NIL"
          ],
          "default": "BLOCK_ID_FLAG_UNKNOWN",
          "title": "BlockIdFlag indicates which BlcokID the signature is for"
        },
        "validator_address": {
          "type": "string",
          "format": "byte"
        },
        "timestamp": {
          "type": "string",
          "format": "date-time"
        },
        "signature": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "CommitSig is a part of the Vote included in a Commit."
    },
    "tendermint.types.Data": {
      "type": "object",
      "properties": {
        "txs": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          },
          "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs."
        }
      },
      "title": "Data contains the set of transactions included in the block"
    },
    "tendermint.types.DuplicateVoteEvidence": {
      "type": "object",
      "properties": {
        "vote_a": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "SIGNED_MSG_TYPE_UNKNOWN",
                "SIGNED_MSG_TYPE_PREVOTE",
                "SIGNED_MSG_TYPE_PRECOMMIT",
                "SIGNED_MSG_TYPE_PROPOSAL"
              ],
              "default": "SIGNED_MSG_TYPE_UNKNOWN",
              "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
            },
            "height": {
              "type": "string",
              "format": "int64"
            },
            "round": {
              "type": "integer",
              "format": "int32"
            },
            "block_id": {
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "format": "byte"
                },
                "part_set_header": {
                  "type": "object",
                  "properties": {
                    "total": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "title": "PartsetHeader"
                }
              },
              "title": "BlockID"
            },
            "timestamp": {
              "type": "string",
              "format": "date-time"
            },
            "validator_address": {
              "type": "string",
              "format": "byte"
            },
            "validator_index": {
              "type": "integer",
              "format": "int32"
            },
            "signature": {
              "type": "string",
              "format": "byte"
            }
          },
          "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
        },
        "vote_b": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "SIGNED_MSG_TYPE_UNKNOWN",
                "SIGNED_MSG_TYPE_PREVOTE",
                "SIGNED_MSG_TYPE_PRECOMMIT",
                "SIGNED_MSG_TYPE_PROPOSAL"
              ],
              "default": "SIGNED_MSG_TYPE_UNKNOWN",
              "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
            },
            "height": {
              "type": "string",
              "format": "int64"
            },
            "round": {
              "type": "integer",
              "format": "int32"
            },
            "block_id": {
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "format": "byte"
                },
                "part_set_header": {
                  "type": "object",
                  "properties": {
                    "total": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "title": "PartsetHeader"
                }
              },
              "title": "BlockID"
            },
            "timestamp": {
              "type": "string",
              "format": "date-time"
            },
            "validator_address": {
              "type": "string",
              "format": "byte"
            },
            "validator_index": {
              "type": "integer",
              "format": "int32"
            },
            "signature": {
              "type": "string",
              "format": "byte"
            }
          },
          "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
        },
        "total_voting_power": {
          "type": "string",
          "format": "int64"
        },
        "validator_power": {
          "type": "string",
          "format": "int64"
        },
        "timestamp": {
          "type": "string",
          "format": "date-time"
        }
      },
      "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
    },
    "tendermint.types.Evidence": {
      "type": "object",
      "properties": {
        "duplicate_vote_evidence": {
          "type": "object",
          "properties": {
            "vote_a": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string",
                  "enum": [
                    "SIGNED_MSG_TYPE_UNKNOWN",
                    "SIGNED_MSG_TYPE_PREVOTE",
                    "SIGNED_MSG_TYPE_PRECOMMIT",
                    "SIGNED_MSG_TYPE_PROPOSAL"
                  ],
                  "default": "SIGNED_MSG_TYPE_UNKNOWN",
                  "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                },
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "round": {
                  "type": "integer",
                  "format": "int32"
                },
                "block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "timestamp": {
                  "type": "string",
                  "format": "date-time"
                },
                "validator_address": {
                  "type": "string",
                  "format": "byte"
                },
                "validator_index": {
                  "type": "integer",
                  "format": "int32"
                },
                "signature": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
            },
            "vote_b": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string",
                  "enum": [
                    "SIGNED_MSG_TYPE_UNKNOWN",
                    "SIGNED_MSG_TYPE_PREVOTE",
                    "SIGNED_MSG_TYPE_PRECOMMIT",
                    "SIGNED_MSG_TYPE_PROPOSAL"
                  ],
                  "default": "SIGNED_MSG_TYPE_UNKNOWN",
                  "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                },
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "round": {
                  "type": "integer",
                  "format": "int32"
                },
                "block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "timestamp": {
                  "type": "string",
                  "format": "date-time"
                },
                "validator_address": {
                  "type": "string",
                  "format": "byte"
                },
                "validator_index": {
                  "type": "integer",
                  "format": "int32"
                },
                "signature": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
            },
            "total_voting_power": {
              "type": "string",
              "format": "int64"
            },
            "validator_power": {
              "type": "string",
              "format": "int64"
            },
            "timestamp": {
              "type": "string",
              "format": "date-time"
            }
          },
          "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
        },
        "light_client_attack_evidence": {
          "type": "object",
          "properties": {
            "conflicting_block": {
              "type": "object",
              "properties": {
                "signed_header": {
                  "type": "object",
                  "properties": {
                    "header": {
                      "type": "object",
                      "properties": {
                        "version": {
                          "title": "basic block info",
                          "type": "object",
                          "properties": {
                            "block": {
                              "type": "string",
                              "format": "uint64"
                            },
                            "app": {
                              "type": "string",
                              "format": "uint64"
                            }
                          },
                          "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                        },
                        "chain_id": {
                          "type": "string"
                        },
                        "height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "time": {
                          "type": "string",
                          "format": "date-time"
                        },
                        "last_block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            },
                            "part_set_header": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "hash": {
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "title": "PartsetHeader"
                            }
                          },
                          "title": "BlockID"
                        },
                        "last_commit_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "hashes of block data"
                        },
                        "data_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "validators_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "hashes from the app output from the prev block"
                        },
                        "next_validators_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "consensus_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "app_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "last_results_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "evidence_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "consensus info"
                        },
                        "proposer_address": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "description": "Header defines the structure of a Tendermint block header."
                    },
                    "commit": {
                      "type": "object",
                      "properties": {
                        "height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "round": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            },
                            "part_set_header": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "hash": {
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "title": "PartsetHeader"
                            }
                          },
                          "title": "BlockID"
                        },
                        "signatures": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "block_id_flag": {
                                "type": "string",
                                "enum": [
                                  "BLOCK_ID_FLAG_UNKNOWN",
                                  "BLOCK_ID_FLAG_ABSENT",
                                  "BLOCK_ID_FLAG_COMMIT",
                                  "BLOCK_ID_FLAG_NIL"
                                ],
                                "default": "BLOCK_ID_FLAG_UNKNOWN",
                                "title": "BlockIdFlag indicates which BlcokID the signature is for"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "CommitSig is a part of the Vote included in a Commit."
                          }
                        }
                      },
                      "description": "Commit contains the evidence that a block was committed by a set of validators."
                    }
                  }
                },
                "validator_set": {
                  "type": "object",
                  "properties": {
                    "validators": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "address": {
                            "type": "string",
                            "format": "byte"
                          },
                          "pub_key": {
                            "type": "object",
                            "properties": {
                              "ed25519": {
                                "type": "string",
                                "format": "byte"
                              },
                              "secp256k1": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "title": "PublicKey defines the keys available for use with Tendermint Validators"
                          },
                          "voting_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "proposer_priority": {
                            "type": "string",
                            "format": "int64"
                          }
                        }
                      }
                    },
                    "proposer": {
                      "type": "object",
                      "properties": {
                        "address": {
                          "type": "string",
                          "format": "byte"
                        },
                        "pub_key": {
                          "type": "object",
                          "properties": {
                            "ed25519": {
                              "type": "string",
                              "format": "byte"
                            },
                            "secp256k1": {
                              "type": "string",
                              "format": "byte"
                            }
                          },
                          "title": "PublicKey defines the keys available for use with Tendermint Validators"
                        },
                        "voting_power": {
                          "type": "string",
                          "format": "int64"
                        },
                        "proposer_priority": {
                          "type": "string",
                          "format": "int64"
                        }
                      }
                    },
                    "total_voting_power": {
                      "type": "string",
                      "format": "int64"
                    }
                  }
                }
              }
            },
            "common_height": {
              "type": "string",
              "format": "int64"
            },
            "byzantine_validators": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "address": {
                    "type": "string",
                    "format": "byte"
                  },
                  "pub_key": {
                    "type": "object",
                    "properties": {
                      "ed25519": {
                        "type": "string",
                        "format": "byte"
                      },
                      "secp256k1": {
                        "type": "string",
                        "format": "byte"
                      }
                    },
                    "title": "PublicKey defines the keys available for use with Tendermint Validators"
                  },
                  "voting_power": {
                    "type": "string",
                    "format": "int64"
                  },
                  "proposer_priority": {
                    "type": "string",
                    "format": "int64"
                  }
                }
              }
            },
            "total_voting_power": {
              "type": "string",
              "format": "int64"
            },
            "timestamp": {
              "type": "string",
              "format": "date-time"
            }
          },
          "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
        }
      }
    },
    "tendermint.types.EvidenceList": {
      "type": "object",
      "properties": {
        "evidence": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "duplicate_vote_evidence": {
                "type": "object",
                "properties": {
                  "vote_a": {
                    "type": "object",
                    "properties": {
                      "type": {
                        "type": "string",
                        "enum": [
                          "SIGNED_MSG_TYPE_UNKNOWN",
                          "SIGNED_MSG_TYPE_PREVOTE",
                          "SIGNED_MSG_TYPE_PRECOMMIT",
                          "SIGNED_MSG_TYPE_PROPOSAL"
                        ],
                        "default": "SIGNED_MSG_TYPE_UNKNOWN",
                        "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                      },
                      "height": {
                        "type": "string",
                        "format": "int64"
                      },
                      "round": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "block_id": {
                        "type": "object",
                        "properties": {
                          "hash": {
                            "type": "string",
                            "format": "byte"
                          },
                          "part_set_header": {
                            "type": "object",
                            "properties": {
                              "total": {
                                "type": "integer",
                                "format": "int64"
                              },
                              "hash": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "title": "PartsetHeader"
                          }
                        },
                        "title": "BlockID"
                      },
                      "timestamp": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "validator_address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "validator_index": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "signature": {
                        "type": "string",
                        "format": "byte"
                      }
                    },
                    "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                  },
                  "vote_b": {
                    "type": "object",
                    "properties": {
                      "type": {
                        "type": "string",
                        "enum": [
                          "SIGNED_MSG_TYPE_UNKNOWN",
                          "SIGNED_MSG_TYPE_PREVOTE",
                          "SIGNED_MSG_TYPE_PRECOMMIT",
                          "SIGNED_MSG_TYPE_PROPOSAL"
                        ],
                        "default": "SIGNED_MSG_TYPE_UNKNOWN",
                        "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                      },
                      "height": {
                        "type": "string",
                        "format": "int64"
                      },
                      "round": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "block_id": {
                        "type": "object",
                        "properties": {
                          "hash": {
                            "type": "string",
                            "format": "byte"
                          },
                          "part_set_header": {
                            "type": "object",
                            "properties": {
                              "total": {
                                "type": "integer",
                                "format": "int64"
                              },
                              "hash": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "title": "PartsetHeader"
                          }
                        },
                        "title": "BlockID"
                      },
                      "timestamp": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "validator_address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "validator_index": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "signature": {
                        "type": "string",
                        "format": "byte"
                      }
                    },
                    "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                  },
                  "total_voting_power": {
                    "type": "string",
                    "format": "int64"
                  },
                  "validator_power": {
                    "type": "string",
                    "format": "int64"
                  },
                  "timestamp": {
                    "type": "string",
                    "format": "date-time"
                  }
                },
                "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
              },
              "light_client_attack_evidence": {
                "type": "object",
                "properties": {
                  "conflicting_block": {
                    "type": "object",
                    "properties": {
                      "signed_header": {
                        "type": "object",
                        "properties": {
                          "header": {
                            "type": "object",
                            "properties": {
                              "version": {
                                "title": "basic block info",
                                "type": "object",
                                "properties": {
                                  "block": {
                                    "type": "string",
                                    "format": "uint64"
                                  },
                                  "app": {
                                    "type": "string",
                                    "format": "uint64"
                                  }
                                },
                                "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                              },
                              "chain_id": {
                                "type": "string"
                              },
                              "height": {
                                "type": "string",
                                "format": "int64"
                              },
                              "time": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "last_block_id": {
                                "type": "object",
                                "properties": {
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "part_set_header": {
                                    "type": "object",
                                    "properties": {
                                      "total": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "title": "PartsetHeader"
                                  }
                                },
                                "title": "BlockID"
                              },
                              "last_commit_hash": {
                                "type": "string",
                                "format": "byte",
                                "title": "hashes of block data"
                              },
                              "data_hash": {
                                "type": "string",
                                "format": "byte"
                              },
                              "validators_hash": {
                                "type": "string",
                                "format": "byte",
                                "title": "hashes from the app output from the prev block"
                              },
                              "next_validators_hash": {
                                "type": "string",
                                "format": "byte"
                              },
                              "consensus_hash": {
                                "type": "string",
                                "format": "byte"
                              },
                              "app_hash": {
                                "type": "string",
                                "format": "byte"
                              },
                              "last_results_hash": {
                                "type": "string",
                                "format": "byte"
                              },
                              "evidence_hash": {
                                "type": "string",
                                "format": "byte",
                                "title": "consensus info"
                              },
                              "proposer_address": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "Header defines the structure of a Tendermint block header."
                          },
                          "commit": {
                            "type": "object",
                            "properties": {
                              "height": {
                                "type": "string",
                                "format": "int64"
                              },
                              "round": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "block_id": {
                                "type": "object",
                                "properties": {
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "part_set_header": {
                                    "type": "object",
                                    "properties": {
                                      "total": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "title": "PartsetHeader"
                                  }
                                },
                                "title": "BlockID"
                              },
                              "signatures": {
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "block_id_flag": {
                                      "type": "string",
                                      "enum": [
                                        "BLOCK_ID_FLAG_UNKNOWN",
                                        "BLOCK_ID_FLAG_ABSENT",
                                        "BLOCK_ID_FLAG_COMMIT",
                                        "BLOCK_ID_FLAG_NIL"
                                      ],
                                      "default": "BLOCK_ID_FLAG_UNKNOWN",
                                      "title": "BlockIdFlag indicates which BlcokID the signature is for"
                                    },
                                    "validator_address": {
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "timestamp": {
                                      "type": "string",
                                      "format": "date-time"
                                    },
                                    "signature": {
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  },
                                  "description": "CommitSig is a part of the Vote included in a Commit."
                                }
                              }
                            },
                            "description": "Commit contains the evidence that a block was committed by a set of validators."
                          }
                        }
                      },
                      "validator_set": {
                        "type": "object",
                        "properties": {
                          "validators": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "address": {
                                  "type": "string",
                                  "format": "byte"
                                },
                                "pub_key": {
                                  "type": "object",
                                  "properties": {
                                    "ed25519": {
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "secp256k1": {
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  },
                                  "title": "PublicKey defines the keys available for use with Tendermint Validators"
                                },
                                "voting_power": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "proposer_priority": {
                                  "type": "string",
                                  "format": "int64"
                                }
                              }
                            }
                          },
                          "proposer": {
                            "type": "object",
                            "properties": {
                              "address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "pub_key": {
                                "type": "object",
                                "properties": {
                                  "ed25519": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "secp256k1": {
                                    "type": "string",
                                    "format": "byte"
                                  }
                                },
                                "title": "PublicKey defines the keys available for use with Tendermint Validators"
                              },
                              "voting_power": {
                                "type": "string",
                                "format": "int64"
                              },
                              "proposer_priority": {
                                "type": "string",
                                "format": "int64"
                              }
                            }
                          },
                          "total_voting_power": {
                            "type": "string",
                            "format": "int64"
                          }
                        }
                      }
                    }
                  },
                  "common_height": {
                    "type": "string",
                    "format": "int64"
                  },
                  "byzantine_validators": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "address": {
                          "type": "string",
                          "format": "byte"
                        },
                        "pub_key": {
                          "type": "object",
                          "properties": {
                            "ed25519": {
                              "type": "string",
                              "format": "byte"
                            },
                            "secp256k1": {
                              "type": "string",
                              "format": "byte"
                            }
                          },
                          "title": "PublicKey defines the keys available for use with Tendermint Validators"
                        },
                        "voting_power": {
                          "type": "string",
                          "format": "int64"
                        },
                        "proposer_priority": {
                          "type": "string",
                          "format": "int64"
                        }
                      }
                    }
                  },
                  "total_voting_power": {
                    "type": "string",
                    "format": "int64"
                  },
                  "timestamp": {
                    "type": "string",
                    "format": "date-time"
                  }
                },
                "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
              }
            }
          }
        }
      }
    },
    "tendermint.types.Header": {
      "type": "object",
      "properties": {
        "version": {
          "title": "basic block info",
          "type": "object",
          "properties": {
            "block": {
              "type": "string",
              "format": "uint64"
            },
            "app": {
              "type": "string",
              "format": "uint64"
            }
          },
          "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
        },
        "chain_id": {
          "type": "string"
        },
        "height": {
          "type": "string",
          "format": "int64"
        },
        "time": {
          "type": "string",
          "format": "date-time"
        },
        "last_block_id": {
          "type": "object",
          "properties": {
            "hash": {
              "type": "string",
              "format": "byte"
            },
            "part_set_header": {
              "type": "object",
              "properties": {
                "total": {
                  "type": "integer",
                  "format": "int64"
                },
                "hash": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "title": "PartsetHeader"
            }
          },
          "title": "BlockID"
        },
        "last_commit_hash": {
          "type": "string",
          "format": "byte",
          "title": "hashes of block data"
        },
        "data_hash": {
          "type": "string",
          "format": "byte"
        },
        "validators_hash": {
          "type": "string",
          "format": "byte",
          "title": "hashes from the app output from the prev block"
        },
        "next_validators_hash": {
          "type": "string",
          "format": "byte"
        },
        "consensus_hash": {
          "type": "string",
          "format": "byte"
        },
        "app_hash": {
          "type": "string",
          "format": "byte"
        },
        "last_results_hash": {
          "type": "string",
          "format": "byte"
        },
        "evidence_hash": {
          "type": "string",
          "format": "byte",
          "title": "consensus info"
        },
        "proposer_address": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "Header defines the structure of a Tendermint block header."
    },
    "tendermint.types.LightBlock": {
      "type": "object",
      "properties": {
        "signed_header": {
          "type": "object",
          "properties": {
            "header": {
              "type": "object",
              "properties": {
                "version": {
                  "title": "basic block info",
                  "type": "object",
                  "properties": {
                    "block": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "app": {
                      "type": "string",
                      "format": "uint64"
                    }
                  },
                  "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                },
                "chain_id": {
                  "type": "string"
                },
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "time": {
                  "type": "string",
                  "format": "date-time"
                },
                "last_block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "last_commit_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes of block data"
                },
                "data_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "validators_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes from the app output from the prev block"
                },
                "next_validators_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "consensus_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "app_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "last_results_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "evidence_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "consensus info"
                },
                "proposer_address": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "description": "Header defines the structure of a Tendermint block header."
            },
            "commit": {
              "type": "object",
              "properties": {
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "round": {
                  "type": "integer",
                  "format": "int32"
                },
                "block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "signatures": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "block_id_flag": {
                        "type": "string",
                        "enum": [
                          "BLOCK_ID_FLAG_UNKNOWN",
                          "BLOCK_ID_FLAG_ABSENT",
                          "BLOCK_ID_FLAG_COMMIT",
                          "BLOCK_ID_FLAG_NIL"
                        ],
                        "default": "BLOCK_ID_FLAG_UNKNOWN",
                        "title": "BlockIdFlag indicates which BlcokID the signature is for"
                      },
                      "validator_address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "timestamp": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "signature": {
                        "type": "string",
                        "format": "byte"
                      }
                    },
                    "description": "CommitSig is a part of the Vote included in a Commit."
                  }
                }
              },
              "description": "Commit contains the evidence that a block was committed by a set of validators."
            }
          }
        },
        "validator_set": {
          "type": "object",
          "properties": {
            "validators": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "address": {
                    "type": "string",
                    "format": "byte"
                  },
                  "pub_key": {
                    "type": "object",
                    "properties": {
                      "ed25519": {
                        "type": "string",
                        "format": "byte"
                      },
                      "secp256k1": {
                        "type": "string",
                        "format": "byte"
                      }
                    },
                    "title": "PublicKey defines the keys available for use with Tendermint Validators"
                  },
                  "voting_power": {
                    "type": "string",
                    "format": "int64"
                  },
                  "proposer_priority": {
                    "type": "string",
                    "format": "int64"
                  }
                }
              }
            },
            "proposer": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string",
                  "format": "byte"
                },
                "pub_key": {
                  "type": "object",
                  "properties": {
                    "ed25519": {
                      "type": "string",
                      "format": "byte"
                    },
                    "secp256k1": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "title": "PublicKey defines the keys available for use with Tendermint Validators"
                },
                "voting_power": {
                  "type": "string",
                  "format": "int64"
                },
                "proposer_priority": {
                  "type": "string",
                  "format": "int64"
                }
              }
            },
            "total_voting_power": {
              "type": "string",
              "format": "int64"
            }
          }
        }
      }
    },
    "tendermint.types.LightClientAttackEvidence": {
      "type": "object",
      "properties": {
        "conflicting_block": {
          "type": "object",
          "properties": {
            "signed_header": {
              "type": "object",
              "properties": {
                "header": {
                  "type": "object",
                  "properties": {
                    "version": {
                      "title": "basic block info",
                      "type": "object",
                      "properties": {
                        "block": {
                          "type": "string",
                          "format": "uint64"
                        },
                        "app": {
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                    },
                    "chain_id": {
                      "type": "string"
                    },
                    "height": {
                      "type": "string",
                      "format": "int64"
                    },
                    "time": {
                      "type": "string",
                      "format": "date-time"
                    },
                    "last_block_id": {
                      "type": "object",
                      "properties": {
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "part_set_header": {
                          "type": "object",
                          "properties": {
                            "total": {
                              "type": "integer",
                              "format": "int64"
                            },
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            }
                          },
                          "title": "PartsetHeader"
                        }
                      },
                      "title": "BlockID"
                    },
                    "last_commit_hash": {
                      "type": "string",
                      "format": "byte",
                      "title": "hashes of block data"
                    },
                    "data_hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "validators_hash": {
                      "type": "string",
                      "format": "byte",
                      "title": "hashes from the app output from the prev block"
                    },
                    "next_validators_hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "consensus_hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "app_hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "last_results_hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "evidence_hash": {
                      "type": "string",
                      "format": "byte",
                      "title": "consensus info"
                    },
                    "proposer_address": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "description": "Header defines the structure of a Tendermint block header."
                },
                "commit": {
                  "type": "object",
                  "properties": {
                    "height": {
                      "type": "string",
                      "format": "int64"
                    },
                    "round": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "block_id": {
                      "type": "object",
                      "properties": {
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "part_set_header": {
                          "type": "object",
                          "properties": {
                            "total": {
                              "type": "integer",
                              "format": "int64"
                            },
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            }
                          },
                          "title": "PartsetHeader"
                        }
                      },
                      "title": "BlockID"
                    },
                    "signatures": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "block_id_flag": {
                            "type": "string",
                            "enum": [
                              "BLOCK_ID_FLAG_UNKNOWN",
                              "BLOCK_ID_FLAG_ABSENT",
                              "BLOCK_ID_FLAG_COMMIT",
                              "BLOCK_ID_FLAG_NIL"
                            ],
                            "default": "BLOCK_ID_FLAG_UNKNOWN",
                            "title": "BlockIdFlag indicates which BlcokID the signature is for"
                          },
                          "validator_address": {
                            "type": "string",
                            "format": "byte"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          },
                          "signature": {
                            "type": "string",
                            "format": "byte"
                          }
                        },
                        "description": "CommitSig is a part of the Vote included in a Commit."
                      }
                    }
                  },
                  "description": "Commit contains the evidence that a block was committed by a set of validators."
                }
              }
            },
            "validator_set": {
              "type": "object",
              "properties": {
                "validators": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "pub_key": {
                        "type": "object",
                        "properties": {
                          "ed25519": {
                            "type": "string",
                            "format": "byte"
                          },
                          "secp256k1": {
                            "type": "string",
                            "format": "byte"
                          }
                        },
                        "title": "PublicKey defines the keys available for use with Tendermint Validators"
                      },
                      "voting_power": {
                        "type": "string",
                        "format": "int64"
                      },
                      "proposer_priority": {
                        "type": "string",
                        "format": "int64"
                      }
                    }
                  }
                },
                "proposer": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "format": "byte"
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "ed25519": {
                          "type": "string",
                          "format": "byte"
                        },
                        "secp256k1": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PublicKey defines the keys available for use with Tendermint Validators"
                    },
                    "voting_power": {
                      "type": "string",
                      "format": "int64"
                    },
                    "proposer_priority": {
                      "type": "string",
                      "format": "int64"
                    }
                  }
                },
                "total_voting_power": {
                  "type": "string",
                  "format": "int64"
                }
              }
            }
          }
        },
        "common_height": {
          "type": "string",
          "format": "int64"
        },
        "byzantine_validators": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "address": {
                "type": "string",
                "format": "byte"
              },
              "pub_key": {
                "type": "object",
                "properties": {
                  "ed25519": {
                    "type": "string",
                    "format": "byte"
                  },
                  "secp256k1": {
                    "type": "string",
                    "format": "byte"
                  }
                },
                "title": "PublicKey defines the keys available for use with Tendermint Validators"
              },
              "voting_power": {
                "type": "string",
                "format": "int64"
              },
              "proposer_priority": {
                "type": "string",
                "format": "int64"
              }
            }
          }
        },
        "total_voting_power": {
          "type": "string",
          "format": "int64"
        },
        "timestamp": {
          "type": "string",
          "format": "date-time"
        }
      },
      "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
    },
    "tendermint.types.PartSetHeader": {
      "type": "object",
      "properties": {
        "total": {
          "type": "integer",
          "format": "int64"
        },
        "hash": {
          "type": "string",
          "format": "byte"
        }
      },
      "title": "PartsetHeader"
    },
    "tendermint.types.SignedHeader": {
      "type": "object",
      "properties": {
        "header": {
          "type": "object",
          "properties": {
            "version": {
              "title": "basic block info",
              "type": "object",
              "properties": {
                "block": {
                  "type": "string",
                  "format": "uint64"
                },
                "app": {
                  "type": "string",
                  "format": "uint64"
                }
              },
              "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
            },
            "chain_id": {
              "type": "string"
            },
            "height": {
              "type": "string",
              "format": "int64"
            },
            "time": {
              "type": "string",
              "format": "date-time"
            },
            "last_block_id": {
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "format": "byte"
                },
                "part_set_header": {
                  "type": "object",
                  "properties": {
                    "total": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "title": "PartsetHeader"
                }
              },
              "title": "BlockID"
            },
            "last_commit_hash": {
              "type": "string",
              "format": "byte",
              "title": "hashes of block data"
            },
            "data_hash": {
              "type": "string",
              "format": "byte"
            },
            "validators_hash": {
              "type": "string",
              "format": "byte",
              "title": "hashes from the app output from the prev block"
            },
            "next_validators_hash": {
              "type": "string",
              "format": "byte"
            },
            "consensus_hash": {
              "type": "string",
              "format": "byte"
            },
            "app_hash": {
              "type": "string",
              "format": "byte"
            },
            "last_results_hash": {
              "type": "string",
              "format": "byte"
            },
            "evidence_hash": {
              "type": "string",
              "format": "byte",
              "title": "consensus info"
            },
            "proposer_address": {
              "type": "string",
              "format": "byte"
            }
          },
          "description": "Header defines the structure of a Tendermint block header."
        },
        "commit": {
          "type": "object",
          "properties": {
            "height": {
              "type": "string",
              "format": "int64"
            },
            "round": {
              "type": "integer",
              "format": "int32"
            },
            "block_id": {
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "format": "byte"
                },
                "part_set_header": {
                  "type": "object",
                  "properties": {
                    "total": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "title": "PartsetHeader"
                }
              },
              "title": "BlockID"
            },
            "signatures": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "block_id_flag": {
                    "type": "string",
                    "enum": [
                      "BLOCK_ID_FLAG_UNKNOWN",
                      "BLOCK_ID_FLAG_ABSENT",
                      "BLOCK_ID_FLAG_COMMIT",
                      "BLOCK_ID_FLAG_NIL"
                    ],
                    "default": "BLOCK_ID_FLAG_UNKNOWN",
                    "title": "BlockIdFlag indicates which BlcokID the signature is for"
                  },
                  "validator_address": {
                    "type": "string",
                    "format": "byte"
                  },
                  "timestamp": {
                    "type": "string",
                    "format": "date-time"
                  },
                  "signature": {
                    "type": "string",
                    "format": "byte"
                  }
                },
                "description": "CommitSig is a part of the Vote included in a Commit."
              }
            }
          },
          "description": "Commit contains the evidence that a block was committed by a set of validators."
        }
      }
    },
    "tendermint.types.SignedMsgType": {
      "type": "string",
      "enum": [
        "SIGNED_MSG_TYPE_UNKNOWN",
        "SIGNED_MSG_TYPE_PREVOTE",
        "SIGNED_MSG_TYPE_PRECOMMIT",
        "SIGNED_MSG_TYPE_PROPOSAL"
      ],
      "default": "SIGNED_MSG_TYPE_UNKNOWN",
      "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
    },
    "tendermint.types.Validator": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "format": "byte"
        },
        "pub_key": {
          "type": "object",
          "properties": {
            "ed25519": {
              "type": "string",
              "format": "byte"
            },
            "secp256k1": {
              "type": "string",
              "format": "byte"
            }
          },
          "title": "PublicKey defines the keys available for use with Tendermint Validators"
        },
        "voting_power": {
          "type": "string",
          "format": "int64"
        },
        "proposer_priority": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "tendermint.types.ValidatorSet": {
      "type": "object",
      "properties": {
        "validators": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "address": {
                "type": "string",
                "format": "byte"
              },
              "pub_key": {
                "type": "object",
                "properties": {
                  "ed25519": {
                    "type": "string",
                    "format": "byte"
                  },
                  "secp256k1": {
                    "type": "string",
                    "format": "byte"
                  }
                },
                "title": "PublicKey defines the keys available for use with Tendermint Validators"
              },
              "voting_power": {
                "type": "string",
                "format": "int64"
              },
              "proposer_priority": {
                "type": "string",
                "format": "int64"
              }
            }
          }
        },
        "proposer": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "format": "byte"
            },
            "pub_key": {
              "type": "object",
              "properties": {
                "ed25519": {
                  "type": "string",
                  "format": "byte"
                },
                "secp256k1": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "title": "PublicKey defines the keys available for use with Tendermint Validators"
            },
            "voting_power": {
              "type": "string",
              "format": "int64"
            },
            "proposer_priority": {
              "type": "string",
              "format": "int64"
            }
          }
        },
        "total_voting_power": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "tendermint.types.Vote": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "SIGNED_MSG_TYPE_UNKNOWN",
            "SIGNED_MSG_TYPE_PREVOTE",
            "SIGNED_MSG_TYPE_PRECOMMIT",
            "SIGNED_MSG_TYPE_PROPOSAL"
          ],
          "default": "SIGNED_MSG_TYPE_UNKNOWN",
          "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
        },
        "height": {
          "type": "string",
          "format": "int64"
        },
        "round": {
          "type": "integer",
          "format": "int32"
        },
        "block_id": {
          "type": "object",
          "properties": {
            "hash": {
              "type": "string",
              "format": "byte"
            },
            "part_set_header": {
              "type": "object",
              "properties": {
                "total": {
                  "type": "integer",
                  "format": "int64"
                },
                "hash": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "title": "PartsetHeader"
            }
          },
          "title": "BlockID"
        },
        "timestamp": {
          "type": "string",
          "format": "date-time"
        },
        "validator_address": {
          "type": "string",
          "format": "byte"
        },
        "validator_index": {
          "type": "integer",
          "format": "int32"
        },
        "signature": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
    },
    "tendermint.version.Consensus": {
      "type": "object",
      "properties": {
        "block": {
          "type": "string",
          "format": "uint64"
        },
        "app": {
          "type": "string",
          "format": "uint64"
        }
      },
      "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
    },
    "cosmos.base.v1beta1.DecCoin": {
      "type": "object",
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
    },
    "cosmos.distribution.v1beta1.DelegationDelegatorReward": {
      "type": "object",
      "properties": {
        "validator_address": {
          "type": "string"
        },
        "reward": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
          }
        }
      },
      "description": "DelegationDelegatorReward represents the properties\nof a delegator's delegation reward."
    },
    "cosmos.distribution.v1beta1.Params": {
      "type": "object",
      "properties": {
        "community_tax": {
          "type": "string"
        },
        "base_proposer_reward": {
          "type": "string"
        },
        "bonus_proposer_reward": {
          "type": "string"
        },
        "withdraw_addr_enabled": {
          "type": "boolean",
          "format": "boolean"
        }
      },
      "description": "Params defines the set of params for the distribution module."
    },
    "cosmos.distribution.v1beta1.QueryCommunityPoolResponse": {
      "type": "object",
      "properties": {
        "pool": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
          },
          "description": "pool defines community pool's coins."
        }
      },
      "description": "QueryCommunityPoolResponse is the response type for the Query/CommunityPool\nRPC method."
    },
    "cosmos.distribution.v1beta1.QueryDelegationRewardsResponse": {
      "type": "object",
      "properties": {
        "rewards": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
          },
          "description": "rewards defines the rewards accrued by a delegation."
        }
      },
      "description": "QueryDelegationRewardsResponse is the response type for the\nQuery/DelegationRewards RPC method."
    },
    "cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse": {
      "type": "object",
      "properties": {
        "rewards": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "validator_address": {
                "type": "string"
              },
              "reward": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                }
              }
            },
            "description": "DelegationDelegatorReward represents the properties\nof a delegator's delegation reward."
          },
          "description": "rewards defines all the rewards accrued by a delegator."
        },
        "total": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
          },
          "description": "total defines the sum of all the rewards."
        }
      },
      "description": "QueryDelegationTotalRewardsResponse is the response type for the\nQuery/DelegationTotalRewards RPC method."
    },
    "cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse": {
      "type": "object",
      "properties": {
        "validators": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "validators defines the validators a delegator is delegating for."
        }
      },
      "description": "QueryDelegatorValidatorsResponse is the response type for the\nQuery/DelegatorValidators RPC method."
    },
    "cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse": {
      "type": "object",
      "properties": {
        "withdraw_address": {
          "type": "string",
          "description": "withdraw_address defines the delegator address to query for."
        }
      },
      "description": "QueryDelegatorWithdrawAddressResponse is the response type for the\nQuery/DelegatorWithdrawAddress RPC method."
    },
    "cosmos.distribution.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params defines the parameters of the module.",
          "type": "object",
          "properties": {
            "community_tax": {
              "type": "string"
            },
            "base_proposer_reward": {
              "type": "string"
            },
            "bonus_proposer_reward": {
              "type": "string"
            },
            "withdraw_addr_enabled": {
              "type": "boolean",
              "format": "boolean"
            }
          }
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "cosmos.distribution.v1beta1.QueryValidatorCommissionResponse": {
      "type": "object",
      "properties": {
        "commission": {
          "description": "commission defines the commision the validator received.",
          "type": "object",
          "properties": {
            "commission": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
              }
            }
          }
        }
      },
      "title": "QueryValidatorCommissionResponse is the response type for the\nQuery/ValidatorCommission RPC method"
    },
    "cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse": {
      "type": "object",
      "properties": {
        "rewards": {
          "type": "object",
          "properties": {
            "rewards": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
              }
            }
          },
          "description": "ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards\nfor a validator inexpensive to track, allows simple sanity checks."
        }
      },
      "description": "QueryValidatorOutstandingRewardsResponse is the response type for the\nQuery/ValidatorOutstandingRewards RPC method."
    },
    "cosmos.distribution.v1beta1.QueryValidatorSlashesResponse": {
      "type": "object",
      "properties": {
        "slashes": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "validator_period": {
                "type": "string",
                "format": "uint64"
              },
              "fraction": {
                "type": "string"
              }
            },
            "description": "ValidatorSlashEvent represents a validator slash event.\nHeight is implicit within the store key.\nThis is needed to calculate appropriate amount of staking tokens\nfor delegations which are withdrawn after a slash has occurred."
          },
          "description": "slashes defines the slashes the validator received."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryValidatorSlashesResponse is the response type for the\nQuery/ValidatorSlashes RPC method."
    },
    "cosmos.distribution.v1beta1.ValidatorAccumulatedCommission": {
      "type": "object",
      "properties": {
        "commission": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
          }
        }
      },
      "description": "ValidatorAccumulatedCommission represents accumulated commission\nfor a validator kept as a running counter, can be withdrawn at any time."
    },
    "cosmos.distribution.v1beta1.ValidatorOutstandingRewards": {
      "type": "object",
      "properties": {
        "rewards": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
          }
        }
      },
      "description": "ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards\nfor a validator inexpensive to track, allows simple sanity checks."
    },
    "cosmos.distribution.v1beta1.ValidatorSlashEvent": {
      "type": "object",
      "properties": {
        "validator_period": {
          "type": "string",
          "format": "uint64"
        },
        "fraction": {
          "type": "string"
        }
      },
      "description": "ValidatorSlashEvent represents a validator slash event.\nHeight is implicit within the store key.\nThis is needed to calculate appropriate amount of staking tokens\nfor delegations which are withdrawn after a slash has occurred."
    },
    "cosmos.evidence.v1beta1.QueryAllEvidenceResponse": {
      "type": "object",
      "properties": {
        "evidence": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "type": "string",
                "format": "byte",
                "description": "Must be a valid serialized protocol buffer of the above specified type."
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "description": "evidence returns all evidences."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC\nmethod."
    },
    "cosmos.evidence.v1beta1.QueryEvidenceResponse": {
      "type": "object",
      "properties": {
        "evidence": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        }
      },
      "description": "QueryEvidenceResponse is the response type for the Query/Evidence RPC method."
    },
    "cosmos.feegrant.v1beta1.Grant": {
      "type": "object",
      "properties": {
        "granter": {
          "type": "string",
          "description": "granter is the address of the user granting an allowance of their funds."
        },
        "grantee": {
          "type": "string",
          "description": "grantee is the address of the user being granted an allowance of another user's funds."
        },
        "allowance": {
          "description": "allowance can be any of basic and filtered fee allowance.",
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          }
        }
      },
      "title": "Grant is stored in the KVStore to record a grant with full context"
    },
    "cosmos.feegrant.v1beta1.QueryAllowanceResponse": {
      "type": "object",
      "properties": {
        "allowance": {
          "description": "allowance is a allowance granted for grantee by granter.",
          "type": "object",
          "properties": {
            "granter": {
              "type": "string",
              "description": "granter is the address of the user granting an allowance of their funds."
            },
            "grantee": {
              "type": "string",
              "description": "grantee is the address of the user being granted an allowance of another user's funds."
            },
            "allowance": {
              "description": "allowance can be any of basic and filtered fee allowance.",
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "type": "string",
                  "format": "byte",
                  "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
              }
            }
          },
          "title": "Grant is stored in the KVStore to record a grant with full context"
        }
      },
      "description": "QueryAllowanceResponse is the response type for the Query/Allowance RPC method."
    },
    "cosmos.feegrant.v1beta1.QueryAllowancesResponse": {
      "type": "object",
      "properties": {
        "allowances": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "granter": {
                "type": "string",
                "description": "granter is the address of the user granting an allowance of their funds."
              },
              "grantee": {
                "type": "string",
                "description": "grantee is the address of the user being granted an allowance of another user's funds."
              },
              "allowance": {
                "description": "allowance can be any of basic and filtered fee allowance.",
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                }
              }
            },
            "title": "Grant is stored in the KVStore to record a grant with full context"
          },
          "description": "allowances are allowance's granted for grantee by granter."
        },
        "pagination": {
          "description": "pagination defines an pagination for the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryAllowancesResponse is the response type for the Query/Allowances RPC method."
    },
    "cosmos.gov.v1beta1.Deposit": {
      "type": "object",
      "properties": {
        "proposal_id": {
          "type": "string",
          "format": "uint64"
        },
        "depositor": {
          "type": "string"
        },
        "amount": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          }
        }
      },
      "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
    },
    "cosmos.gov.v1beta1.DepositParams": {
      "type": "object",
      "properties": {
        "min_deposit": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          },
          "description": "Minimum deposit for a proposal to enter voting period."
        },
        "max_deposit_period": {
          "type": "string",
          "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\n months."
        }
      },
      "description": "DepositParams defines the params for deposits on governance proposals."
    },
    "cosmos.gov.v1beta1.Proposal": {
      "type": "object",
      "properties": {
        "proposal_id": {
          "type": "string",
          "format": "uint64"
        },
        "content": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        },
        "status": {
          "type": "string",
          "enum": [
            "PROPOSAL_STATUS_UNSPECIFIED",
            "PROPOSAL_STATUS_DEPOSIT_PERIOD",
            "PROPOSAL_STATUS_VOTING_PERIOD",
            "PROPOSAL_STATUS_PASSED",
            "PROPOSAL_STATUS_REJECTED",
            "PROPOSAL_STATUS_FAILED"
          ],
          "default": "PROPOSAL_STATUS_UNSPECIFIED",
          "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed."
        },
        "final_tally_result": {
          "type": "object",
          "properties": {
            "yes": {
              "type": "string"
            },
            "abstain": {
              "type": "string"
            },
            "no": {
              "type": "string"
            },
            "no_with_veto": {
              "type": "string"
            }
          },
          "description": "TallyResult defines a standard tally for a governance proposal."
        },
        "submit_time": {
          "type": "string",
          "format": "date-time"
        },
        "deposit_end_time": {
          "type": "string",
          "format": "date-time"
        },
        "total_deposit": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          }
        },
        "voting_start_time": {
          "type": "string",
          "format": "date-time"
        },
        "voting_end_time": {
          "type": "string",
          "format": "date-time"
        }
      },
      "description": "Proposal defines the core field members of a governance proposal."
    },
    "cosmos.gov.v1beta1.ProposalStatus": {
      "type": "string",
      "enum": [
        "PROPOSAL_STATUS_UNSPECIFIED",
        "PROPOSAL_STATUS_DEPOSIT_PERIOD",
        "PROPOSAL_STATUS_VOTING_PERIOD",
        "PROPOSAL_STATUS_PASSED",
        "PROPOSAL_STATUS_REJECTED",
        "PROPOSAL_STATUS_FAILED"
      ],
      "default": "PROPOSAL_STATUS_UNSPECIFIED",
      "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed."
    },
    "cosmos.gov.v1beta1.QueryDepositResponse": {
      "type": "object",
      "properties": {
        "deposit": {
          "type": "object",
          "properties": {
            "proposal_id": {
              "type": "string",
              "format": "uint64"
            },
            "depositor": {
              "type": "string"
            },
            "amount": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              }
            }
          },
          "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
        }
      },
      "description": "QueryDepositResponse is the response type for the Query/Deposit RPC method."
    },
    "cosmos.gov.v1beta1.QueryDepositsResponse": {
      "type": "object",
      "properties": {
        "deposits": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "proposal_id": {
                "type": "string",
                "format": "uint64"
              },
              "depositor": {
                "type": "string"
              },
              "amount": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              }
            },
            "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
          }
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryDepositsResponse is the response type for the Query/Deposits RPC method."
    },
    "cosmos.gov.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "voting_params": {
          "description": "voting_params defines the parameters related to voting.",
          "type": "object",
          "properties": {
            "voting_period": {
              "type": "string",
              "description": "Length of the voting period."
            }
          }
        },
        "deposit_params": {
          "description": "deposit_params defines the parameters related to deposit.",
          "type": "object",
          "properties": {
            "min_deposit": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              },
              "description": "Minimum deposit for a proposal to enter voting period."
            },
            "max_deposit_period": {
              "type": "string",
              "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\n months."
            }
          }
        },
        "tally_params": {
          "description": "tally_params defines the parameters related to tally.",
          "type": "object",
          "properties": {
            "quorum": {
              "type": "string",
              "format": "byte",
              "description": "Minimum percentage of total stake needed to vote for a result to be\n considered valid."
            },
            "threshold": {
              "type": "string",
              "format": "byte",
              "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
            },
            "veto_threshold": {
              "type": "string",
              "format": "byte",
              "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\n vetoed. Default value: 1/3."
            }
          }
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "cosmos.gov.v1beta1.QueryProposalResponse": {
      "type": "object",
      "properties": {
        "proposal": {
          "type": "object",
          "properties": {
            "proposal_id": {
              "type": "string",
              "format": "uint64"
            },
            "content": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "type": "string",
                  "format": "byte",
                  "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            },
            "status": {
              "type": "string",
              "enum": [
                "PROPOSAL_STATUS_UNSPECIFIED",
                "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                "PROPOSAL_STATUS_VOTING_PERIOD",
                "PROPOSAL_STATUS_PASSED",
                "PROPOSAL_STATUS_REJECTED",
                "PROPOSAL_STATUS_FAILED"
              ],
              "default": "PROPOSAL_STATUS_UNSPECIFIED",
              "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed."
            },
            "final_tally_result": {
              "type": "object",
              "properties": {
                "yes": {
                  "type": "string"
                },
                "abstain": {
                  "type": "string"
                },
                "no": {
                  "type": "string"
                },
                "no_with_veto": {
                  "type": "string"
                }
              },
              "description": "TallyResult defines a standard tally for a governance proposal."
            },
            "submit_time": {
              "type": "string",
              "format": "date-time"
            },
            "deposit_end_time": {
              "type": "string",
              "format": "date-time"
            },
            "total_deposit": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              }
            },
            "voting_start_time": {
              "type": "string",
              "format": "date-time"
            },
            "voting_end_time": {
              "type": "string",
              "format": "date-time"
            }
          },
          "description": "Proposal defines the core field members of a governance proposal."
        }
      },
      "description": "QueryProposalResponse is the response type for the Query/Proposal RPC method."
    },
    "cosmos.gov.v1beta1.QueryProposalsResponse": {
      "type": "object",
      "properties": {
        "proposals": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "proposal_id": {
                "type": "string",
                "format": "uint64"
              },
              "content": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "status": {
                "type": "string",
                "enum": [
                  "PROPOSAL_STATUS_UNSPECIFIED",
                  "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                  "PROPOSAL_STATUS_VOTING_PERIOD",
                  "PROPOSAL_STATUS_PASSED",
                  "PROPOSAL_STATUS_REJECTED",
                  "PROPOSAL_STATUS_FAILED"
                ],
                "default": "PROPOSAL_STATUS_UNSPECIFIED",
                "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed."
              },
              "final_tally_result": {
                "type": "object",
                "properties": {
                  "yes": {
                    "type": "string"
                  },
                  "abstain": {
                    "type": "string"
                  },
                  "no": {
                    "type": "string"
                  },
                  "no_with_veto": {
                    "type": "string"
                  }
                },
                "description": "TallyResult defines a standard tally for a governance proposal."
              },
              "submit_time": {
                "type": "string",
                "format": "date-time"
              },
              "deposit_end_time": {
                "type": "string",
                "format": "date-time"
              },
              "total_deposit": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              },
              "voting_start_time": {
                "type": "string",
                "format": "date-time"
              },
              "voting_end_time": {
                "type": "string",
                "format": "date-time"
              }
            },
            "description": "Proposal defines the core field members of a governance proposal."
          }
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryProposalsResponse is the response type for the Query/Proposals RPC\nmethod."
    },
    "cosmos.gov.v1beta1.QueryTallyResultResponse": {
      "type": "object",
      "properties": {
        "tally": {
          "type": "object",
          "properties": {
            "yes": {
              "type": "string"
            },
            "abstain": {
              "type": "string"
            },
            "no": {
              "type": "string"
            },
            "no_with_veto": {
              "type": "string"
            }
          },
          "description": "TallyResult defines a standard tally for a governance proposal."
        }
      },
      "description": "QueryTallyResultResponse is the response type for the Query/Tally RPC method."
    },
    "cosmos.gov.v1beta1.QueryVoteResponse": {
      "type": "object",
      "properties": {
        "vote": {
          "type": "object",
          "properties": {
            "proposal_id": {
              "type": "string",
              "format": "uint64"
            },
            "voter": {
              "type": "string"
            },
            "option": {
              "description": "Deprecated: Prefer to use `options` instead. This field is set in queries\nif and only if `len(options) == 1` and that option has weight 1. In all\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.",
              "type": "string",
              "enum": [
                "VOTE_OPTION_UNSPECIFIED",
                "VOTE_OPTION_YES",
                "VOTE_OPTION_ABSTAIN",
                "VOTE_OPTION_NO",
                "VOTE_OPTION_NO_WITH_VETO"
              ],
              "default": "VOTE_OPTION_UNSPECIFIED"
            },
            "options": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "option": {
                    "type": "string",
                    "enum": [
                      "VOTE_OPTION_UNSPECIFIED",
                      "VOTE_OPTION_YES",
                      "VOTE_OPTION_ABSTAIN",
                      "VOTE_OPTION_NO",
                      "VOTE_OPTION_NO_WITH_VETO"
                    ],
                    "default": "VOTE_OPTION_UNSPECIFIED",
                    "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."
                  },
                  "weight": {
                    "type": "string"
                  }
                },
                "description": "WeightedVoteOption defines a unit of vote for vote split.\n\nSince: cosmos-sdk 0.43"
              },
              "title": "Since: cosmos-sdk 0.43"
            }
          },
          "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
        }
      },
      "description": "QueryVoteResponse is the response type for the Query/Vote RPC method."
    },
    "cosmos.gov.v1beta1.QueryVotesResponse": {
      "type": "object",
      "properties": {
        "votes": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "proposal_id": {
                "type": "string",
                "format": "uint64"
              },
              "voter": {
                "type": "string"
              },
              "option": {
                "description": "Deprecated: Prefer to use `options` instead. This field is set in queries\nif and only if `len(options) == 1` and that option has weight 1. In all\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.",
                "type": "string",
                "enum": [
                  "VOTE_OPTION_UNSPECIFIED",
                  "VOTE_OPTION_YES",
                  "VOTE_OPTION_ABSTAIN",
                  "VOTE_OPTION_NO",
                  "VOTE_OPTION_NO_WITH_VETO"
                ],
                "default": "VOTE_OPTION_UNSPECIFIED"
              },
              "options": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "option": {
                      "type": "string",
                      "enum": [
                        "VOTE_OPTION_UNSPECIFIED",
                        "VOTE_OPTION_YES",
                        "VOTE_OPTION_ABSTAIN",
                        "VOTE_OPTION_NO",
                        "VOTE_OPTION_NO_WITH_VETO"
                      ],
                      "default": "VOTE_OPTION_UNSPECIFIED",
                      "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."
                    },
                    "weight": {
                      "type": "string"
                    }
                  },
                  "description": "WeightedVoteOption defines a unit of vote for vote split.\n\nSince: cosmos-sdk 0.43"
                },
                "title": "Since: cosmos-sdk 0.43"
              }
            },
            "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
          },
          "description": "votes defined the queried votes."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryVotesResponse is the response type for the Query/Votes RPC method."
    },
    "cosmos.gov.v1beta1.TallyParams": {
      "type": "object",
      "properties": {
        "quorum": {
          "type": "string",
          "format": "byte",
          "description": "Minimum percentage of total stake needed to vote for a result to be\n considered valid."
        },
        "threshold": {
          "type": "string",
          "format": "byte",
          "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
        },
        "veto_threshold": {
          "type": "string",
          "format": "byte",
          "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\n vetoed. Default value: 1/3."
        }
      },
      "description": "TallyParams defines the params for tallying votes on governance proposals."
    },
    "cosmos.gov.v1beta1.TallyResult": {
      "type": "object",
      "properties": {
        "yes": {
          "type": "string"
        },
        "abstain": {
          "type": "string"
        },
        "no": {
          "type": "string"
        },
        "no_with_veto": {
          "type": "string"
        }
      },
      "description": "TallyResult defines a standard tally for a governance proposal."
    },
    "cosmos.gov.v1beta1.Vote": {
      "type": "object",
      "properties": {
        "proposal_id": {
          "type": "string",
          "format": "uint64"
        },
        "voter": {
          "type": "string"
        },
        "option": {
          "description": "Deprecated: Prefer to use `options` instead. This field is set in queries\nif and only if `len(options) == 1` and that option has weight 1. In all\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.",
          "type": "string",
          "enum": [
            "VOTE_OPTION_UNSPECIFIED",
            "VOTE_OPTION_YES",
            "VOTE_OPTION_ABSTAIN",
            "VOTE_OPTION_NO",
            "VOTE_OPTION_NO_WITH_VETO"
          ],
          "default": "VOTE_OPTION_UNSPECIFIED"
        },
        "options": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "option": {
                "type": "string",
                "enum": [
                  "VOTE_OPTION_UNSPECIFIED",
                  "VOTE_OPTION_YES",
                  "VOTE_OPTION_ABSTAIN",
                  "VOTE_OPTION_NO",
                  "VOTE_OPTION_NO_WITH_VETO"
                ],
                "default": "VOTE_OPTION_UNSPECIFIED",
                "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."
              },
              "weight": {
                "type": "string"
              }
            },
            "description": "WeightedVoteOption defines a unit of vote for vote split.\n\nSince: cosmos-sdk 0.43"
          },
          "title": "Since: cosmos-sdk 0.43"
        }
      },
      "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
    },
    "cosmos.gov.v1beta1.VoteOption": {
      "type": "string",
      "enum": [
        "VOTE_OPTION_UNSPECIFIED",
        "VOTE_OPTION_YES",
        "VOTE_OPTION_ABSTAIN",
        "VOTE_OPTION_NO",
        "VOTE_OPTION_NO_WITH_VETO"
      ],
      "default": "VOTE_OPTION_UNSPECIFIED",
      "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."
    },
    "cosmos.gov.v1beta1.VotingParams": {
      "type": "object",
      "properties": {
        "voting_period": {
          "type": "string",
          "description": "Length of the voting period."
        }
      },
      "description": "VotingParams defines the params for voting on governance proposals."
    },
    "cosmos.gov.v1beta1.WeightedVoteOption": {
      "type": "object",
      "properties": {
        "option": {
          "type": "string",
          "enum": [
            "VOTE_OPTION_UNSPECIFIED",
            "VOTE_OPTION_YES",
            "VOTE_OPTION_ABSTAIN",
            "VOTE_OPTION_NO",
            "VOTE_OPTION_NO_WITH_VETO"
          ],
          "default": "VOTE_OPTION_UNSPECIFIED",
          "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."
        },
        "weight": {
          "type": "string"
        }
      },
      "description": "WeightedVoteOption defines a unit of vote for vote split.\n\nSince: cosmos-sdk 0.43"
    },
    "cosmos.mint.v1beta1.Params": {
      "type": "object",
      "properties": {
        "mint_denom": {
          "type": "string",
          "title": "type of coin to mint"
        },
        "inflation_rate_change": {
          "type": "string",
          "title": "maximum annual change in inflation rate"
        },
        "inflation_max": {
          "type": "string",
          "title": "maximum inflation rate"
        },
        "inflation_min": {
          "type": "string",
          "title": "minimum inflation rate"
        },
        "goal_bonded": {
          "type": "string",
          "title": "goal of percent bonded atoms"
        },
        "blocks_per_year": {
          "type": "string",
          "format": "uint64",
          "title": "expected blocks per year"
        }
      },
      "description": "Params holds parameters for the mint module."
    },
    "cosmos.mint.v1beta1.QueryAnnualProvisionsResponse": {
      "type": "object",
      "properties": {
        "annual_provisions": {
          "type": "string",
          "format": "byte",
          "description": "annual_provisions is the current minting annual provisions value."
        }
      },
      "description": "QueryAnnualProvisionsResponse is the response type for the\nQuery/AnnualProvisions RPC method."
    },
    "cosmos.mint.v1beta1.QueryInflationResponse": {
      "type": "object",
      "properties": {
        "inflation": {
          "type": "string",
          "format": "byte",
          "description": "inflation is the current minting inflation value."
        }
      },
      "description": "QueryInflationResponse is the response type for the Query/Inflation RPC\nmethod."
    },
    "cosmos.mint.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params defines the parameters of the module.",
          "type": "object",
          "properties": {
            "mint_denom": {
              "type": "string",
              "title": "type of coin to mint"
            },
            "inflation_rate_change": {
              "type": "string",
              "title": "maximum annual change in inflation rate"
            },
            "inflation_max": {
              "type": "string",
              "title": "maximum inflation rate"
            },
            "inflation_min": {
              "type": "string",
              "title": "minimum inflation rate"
            },
            "goal_bonded": {
              "type": "string",
              "title": "goal of percent bonded atoms"
            },
            "blocks_per_year": {
              "type": "string",
              "format": "uint64",
              "title": "expected blocks per year"
            }
          }
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "cosmos.params.v1beta1.ParamChange": {
      "type": "object",
      "properties": {
        "subspace": {
          "type": "string"
        },
        "key": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      },
      "description": "ParamChange defines an individual parameter change, for use in\nParameterChangeProposal."
    },
    "cosmos.params.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "param": {
          "description": "param defines the queried parameter.",
          "type": "object",
          "properties": {
            "subspace": {
              "type": "string"
            },
            "key": {
              "type": "string"
            },
            "value": {
              "type": "string"
            }
          }
        }
      },
      "description": "QueryParamsResponse is response type for the Query/Params RPC method."
    },
    "cosmos.slashing.v1beta1.Params": {
      "type": "object",
      "properties": {
        "signed_blocks_window": {
          "type": "string",
          "format": "int64"
        },
        "min_signed_per_window": {
          "type": "string",
          "format": "byte"
        },
        "downtime_jail_duration": {
          "type": "string"
        },
        "slash_fraction_double_sign": {
          "type": "string",
          "format": "byte"
        },
        "slash_fraction_downtime": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "Params represents the parameters used for by the slashing module."
    },
    "cosmos.slashing.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "type": "object",
          "properties": {
            "signed_blocks_window": {
              "type": "string",
              "format": "int64"
            },
            "min_signed_per_window": {
              "type": "string",
              "format": "byte"
            },
            "downtime_jail_duration": {
              "type": "string"
            },
            "slash_fraction_double_sign": {
              "type": "string",
              "format": "byte"
            },
            "slash_fraction_downtime": {
              "type": "string",
              "format": "byte"
            }
          },
          "description": "Params represents the parameters used for by the slashing module."
        }
      },
      "title": "QueryParamsResponse is the response type for the Query/Params RPC method"
    },
    "cosmos.slashing.v1beta1.QuerySigningInfoResponse": {
      "type": "object",
      "properties": {
        "val_signing_info": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string"
            },
            "start_height": {
              "type": "string",
              "format": "int64",
              "title": "Height at which validator was first a candidate OR was unjailed"
            },
            "index_offset": {
              "type": "string",
              "format": "int64",
              "description": "Index which is incremented each time the validator was a bonded\nin a block and may have signed a precommit or not. This in conjunction with the\n`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`."
            },
            "jailed_until": {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp until which the validator is jailed due to liveness downtime."
            },
            "tombstoned": {
              "type": "boolean",
              "format": "boolean",
              "description": "Whether or not a validator has been tombstoned (killed out of validator set). It is set\nonce the validator commits an equivocation or for any other configured misbehiavor."
            },
            "missed_blocks_counter": {
              "type": "string",
              "format": "int64",
              "description": "A counter kept to avoid unnecessary array reads.\nNote that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`."
            }
          },
          "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their\nliveness activity.",
          "title": "val_signing_info is the signing info of requested val cons address"
        }
      },
      "title": "QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC\nmethod"
    },
    "cosmos.slashing.v1beta1.QuerySigningInfosResponse": {
      "type": "object",
      "properties": {
        "info": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "start_height": {
                "type": "string",
                "format": "int64",
                "title": "Height at which validator was first a candidate OR was unjailed"
              },
              "index_offset": {
                "type": "string",
                "format": "int64",
                "description": "Index which is incremented each time the validator was a bonded\nin a block and may have signed a precommit or not. This in conjunction with the\n`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`."
              },
              "jailed_until": {
                "type": "string",
                "format": "date-time",
                "description": "Timestamp until which the validator is jailed due to liveness downtime."
              },
              "tombstoned": {
                "type": "boolean",
                "format": "boolean",
                "description": "Whether or not a validator has been tombstoned (killed out of validator set). It is set\nonce the validator commits an equivocation or for any other configured misbehiavor."
              },
              "missed_blocks_counter": {
                "type": "string",
                "format": "int64",
                "description": "A counter kept to avoid unnecessary array reads.\nNote that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`."
              }
            },
            "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their\nliveness activity."
          },
          "title": "info is the signing info of all validators"
        },
        "pagination": {
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        }
      },
      "title": "QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC\nmethod"
    },
    "cosmos.slashing.v1beta1.ValidatorSigningInfo": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string"
        },
        "start_height": {
          "type": "string",
          "format": "int64",
          "title": "Height at which validator was first a candidate OR was unjailed"
        },
        "index_offset": {
          "type": "string",
          "format": "int64",
          "description": "Index which is incremented each time the validator was a bonded\nin a block and may have signed a precommit or not. This in conjunction with the\n`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`."
        },
        "jailed_until": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp until which the validator is jailed due to liveness downtime."
        },
        "tombstoned": {
          "type": "boolean",
          "format": "boolean",
          "description": "Whether or not a validator has been tombstoned (killed out of validator set). It is set\nonce the validator commits an equivocation or for any other configured misbehiavor."
        },
        "missed_blocks_counter": {
          "type": "string",
          "format": "int64",
          "description": "A counter kept to avoid unnecessary array reads.\nNote that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`."
        }
      },
      "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their\nliveness activity."
    },
    "cosmos.staking.v1beta1.BondStatus": {
      "type": "string",
      "enum": [
        "BOND_STATUS_UNSPECIFIED",
        "BOND_STATUS_UNBONDED",
        "BOND_STATUS_UNBONDING",
        "BOND_STATUS_BONDED"
      ],
      "default": "BOND_STATUS_UNSPECIFIED",
      "description": "BondStatus is the status of a validator.\n\n - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.\n - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.\n - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.\n - BOND_STATUS_BONDED: BONDED defines a validator that is bonded."
    },
    "cosmos.staking.v1beta1.Commission": {
      "type": "object",
      "properties": {
        "commission_rates": {
          "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
          "type": "object",
          "properties": {
            "rate": {
              "type": "string",
              "description": "rate is the commission rate charged to delegators, as a fraction."
            },
            "max_rate": {
              "type": "string",
              "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
            },
            "max_change_rate": {
              "type": "string",
              "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
            }
          }
        },
        "update_time": {
          "type": "string",
          "format": "date-time",
          "description": "update_time is the last time the commission rate was changed."
        }
      },
      "description": "Commission defines commission parameters for a given validator."
    },
    "cosmos.staking.v1beta1.CommissionRates": {
      "type": "object",
      "properties": {
        "rate": {
          "type": "string",
          "description": "rate is the commission rate charged to delegators, as a fraction."
        },
        "max_rate": {
          "type": "string",
          "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
        },
        "max_change_rate": {
          "type": "string",
          "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
        }
      },
      "description": "CommissionRates defines the initial commission rates to be used for creating\na validator."
    },
    "cosmos.staking.v1beta1.Delegation": {
      "type": "object",
      "properties": {
        "delegator_address": {
          "type": "string",
          "description": "delegator_address is the bech32-encoded address of the delegator."
        },
        "validator_address": {
          "type": "string",
          "description": "validator_address is the bech32-encoded address of the validator."
        },
        "shares": {
          "type": "string",
          "description": "shares define the delegation shares received."
        }
      },
      "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
    },
    "cosmos.staking.v1beta1.DelegationResponse": {
      "type": "object",
      "properties": {
        "delegation": {
          "type": "object",
          "properties": {
            "delegator_address": {
              "type": "string",
              "description": "delegator_address is the bech32-encoded address of the delegator."
            },
            "validator_address": {
              "type": "string",
              "description": "validator_address is the bech32-encoded address of the validator."
            },
            "shares": {
              "type": "string",
              "description": "shares define the delegation shares received."
            }
          },
          "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
        },
        "balance": {
          "type": "object",
          "properties": {
            "denom": {
              "type": "string"
            },
            "amount": {
              "type": "string"
            }
          },
          "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
        }
      },
      "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses."
    },
    "cosmos.staking.v1beta1.Description": {
      "type": "object",
      "properties": {
        "moniker": {
          "type": "string",
          "description": "moniker defines a human-readable name for the validator."
        },
        "identity": {
          "type": "string",
          "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
        },
        "website": {
          "type": "string",
          "description": "website defines an optional website link."
        },
        "security_contact": {
          "type": "string",
          "description": "security_contact defines an optional email for security contact."
        },
        "details": {
          "type": "string",
          "description": "details define other optional details."
        }
      },
      "description": "Description defines a validator description."
    },
    "cosmos.staking.v1beta1.HistoricalInfo": {
      "type": "object",
      "properties": {
        "header": {
          "type": "object",
          "properties": {
            "version": {
              "title": "basic block info",
              "type": "object",
              "properties": {
                "block": {
                  "type": "string",
                  "format": "uint64"
                },
                "app": {
                  "type": "string",
                  "format": "uint64"
                }
              },
              "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
            },
            "chain_id": {
              "type": "string"
            },
            "height": {
              "type": "string",
              "format": "int64"
            },
            "time": {
              "type": "string",
              "format": "date-time"
            },
            "last_block_id": {
              "title": "prev block info",
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "format": "byte"
                },
                "part_set_header": {
                  "type": "object",
                  "properties": {
                    "total": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "title": "PartsetHeader"
                }
              }
            },
            "last_commit_hash": {
              "type": "string",
              "format": "byte",
              "title": "hashes of block data"
            },
            "data_hash": {
              "type": "string",
              "format": "byte"
            },
            "validators_hash": {
              "type": "string",
              "format": "byte",
              "title": "hashes from the app output from the prev block"
            },
            "next_validators_hash": {
              "type": "string",
              "format": "byte"
            },
            "consensus_hash": {
              "type": "string",
              "format": "byte"
            },
            "app_hash": {
              "type": "string",
              "format": "byte"
            },
            "last_results_hash": {
              "type": "string",
              "format": "byte"
            },
            "evidence_hash": {
              "type": "string",
              "format": "byte",
              "title": "consensus info"
            },
            "proposer_address": {
              "type": "string",
              "format": "byte"
            }
          },
          "description": "Header defines the structure of a Tendermint block header."
        },
        "valset": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "operator_address": {
                "type": "string",
                "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
              },
              "consensus_pubkey": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "jailed": {
                "type": "boolean",
                "format": "boolean",
                "description": "jailed defined whether the validator has been jailed from bonded status or not."
              },
              "status": {
                "description": "status is the validator status (bonded/unbonding/unbonded).",
                "type": "string",
                "enum": [
                  "BOND_STATUS_UNSPECIFIED",
                  "BOND_STATUS_UNBONDED",
                  "BOND_STATUS_UNBONDING",
                  "BOND_STATUS_BONDED"
                ],
                "default": "BOND_STATUS_UNSPECIFIED"
              },
              "tokens": {
                "type": "string",
                "description": "tokens define the delegated tokens (incl. self-delegation)."
              },
              "delegator_shares": {
                "type": "string",
                "description": "delegator_shares defines total shares issued to a validator's delegators."
              },
              "description": {
                "description": "description defines the description terms for the validator.",
                "type": "object",
                "properties": {
                  "moniker": {
                    "type": "string",
                    "description": "moniker defines a human-readable name for the validator."
                  },
                  "identity": {
                    "type": "string",
                    "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                  },
                  "website": {
                    "type": "string",
                    "description": "website defines an optional website link."
                  },
                  "security_contact": {
                    "type": "string",
                    "description": "security_contact defines an optional email for security contact."
                  },
                  "details": {
                    "type": "string",
                    "description": "details define other optional details."
                  }
                }
              },
              "unbonding_height": {
                "type": "string",
                "format": "int64",
                "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."
              },
              "unbonding_time": {
                "type": "string",
                "format": "date-time",
                "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."
              },
              "commission": {
                "description": "commission defines the commission parameters.",
                "type": "object",
                "properties": {
                  "commission_rates": {
                    "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                    "type": "object",
                    "properties": {
                      "rate": {
                        "type": "string",
                        "description": "rate is the commission rate charged to delegators, as a fraction."
                      },
                      "max_rate": {
                        "type": "string",
                        "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                      },
                      "max_change_rate": {
                        "type": "string",
                        "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                      }
                    }
                  },
                  "update_time": {
                    "type": "string",
                    "format": "date-time",
                    "description": "update_time is the last time the commission rate was changed."
                  }
                }
              },
              "min_self_delegation": {
                "type": "string",
                "description": "min_self_delegation is the validator's self declared minimum self delegation."
              }
            },
            "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
          }
        }
      },
      "description": "HistoricalInfo contains header and validator information for a given block.\nIt is stored as part of staking module's state, which persists the `n` most\nrecent HistoricalInfo\n(`n` is set by the staking module's `historical_entries` parameter)."
    },
    "cosmos.staking.v1beta1.Params": {
      "type": "object",
      "properties": {
        "unbonding_time": {
          "type": "string",
          "description": "unbonding_time is the time duration of unbonding."
        },
        "max_validators": {
          "type": "integer",
          "format": "int64",
          "description": "max_validators is the maximum number of validators."
        },
        "max_entries": {
          "type": "integer",
          "format": "int64",
          "description": "max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio)."
        },
        "historical_entries": {
          "type": "integer",
          "format": "int64",
          "description": "historical_entries is the number of historical entries to persist."
        },
        "bond_denom": {
          "type": "string",
          "description": "bond_denom defines the bondable coin denomination."
        }
      },
      "description": "Params defines the parameters for the staking module."
    },
    "cosmos.staking.v1beta1.Pool": {
      "type": "object",
      "properties": {
        "not_bonded_tokens": {
          "type": "string"
        },
        "bonded_tokens": {
          "type": "string"
        }
      },
      "description": "Pool is used for tracking bonded and not-bonded token supply of the bond\ndenomination."
    },
    "cosmos.staking.v1beta1.QueryDelegationResponse": {
      "type": "object",
      "properties": {
        "delegation_response": {
          "type": "object",
          "properties": {
            "delegation": {
              "type": "object",
              "properties": {
                "delegator_address": {
                  "type": "string",
                  "description": "delegator_address is the bech32-encoded address of the delegator."
                },
                "validator_address": {
                  "type": "string",
                  "description": "validator_address is the bech32-encoded address of the validator."
                },
                "shares": {
                  "type": "string",
                  "description": "shares define the delegation shares received."
                }
              },
              "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
            },
            "balance": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
            }
          },
          "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses."
        }
      },
      "description": "QueryDelegationResponse is response type for the Query/Delegation RPC method."
    },
    "cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse": {
      "type": "object",
      "properties": {
        "delegation_responses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "delegation": {
                "type": "object",
                "properties": {
                  "delegator_address": {
                    "type": "string",
                    "description": "delegator_address is the bech32-encoded address of the delegator."
                  },
                  "validator_address": {
                    "type": "string",
                    "description": "validator_address is the bech32-encoded address of the validator."
                  },
                  "shares": {
                    "type": "string",
                    "description": "shares define the delegation shares received."
                  }
                },
                "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
              },
              "balance": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              }
            },
            "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses."
          },
          "description": "delegation_responses defines all the delegations' info of a delegator."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryDelegatorDelegationsResponse is response type for the\nQuery/DelegatorDelegations RPC method."
    },
    "cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse": {
      "type": "object",
      "properties": {
        "unbonding_responses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "delegator_address": {
                "type": "string",
                "description": "delegator_address is the bech32-encoded address of the delegator."
              },
              "validator_address": {
                "type": "string",
                "description": "validator_address is the bech32-encoded address of the validator."
              },
              "entries": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "creation_height": {
                      "type": "string",
                      "format": "int64",
                      "description": "creation_height is the height which the unbonding took place."
                    },
                    "completion_time": {
                      "type": "string",
                      "format": "date-time",
                      "description": "completion_time is the unix time for unbonding completion."
                    },
                    "initial_balance": {
                      "type": "string",
                      "description": "initial_balance defines the tokens initially scheduled to receive at completion."
                    },
                    "balance": {
                      "type": "string",
                      "description": "balance defines the tokens to receive at completion."
                    }
                  },
                  "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
                },
                "description": "entries are the unbonding delegation entries."
              }
            },
            "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list."
          }
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryUnbondingDelegatorDelegationsResponse is response type for the\nQuery/UnbondingDelegatorDelegations RPC method."
    },
    "cosmos.staking.v1beta1.QueryDelegatorValidatorResponse": {
      "type": "object",
      "properties": {
        "validator": {
          "type": "object",
          "properties": {
            "operator_address": {
              "type": "string",
              "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
            },
            "consensus_pubkey": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "type": "string",
                  "format": "byte",
                  "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            },
            "jailed": {
              "type": "boolean",
              "format": "boolean",
              "description": "jailed defined whether the validator has been jailed from bonded status or not."
            },
            "status": {
              "description": "status is the validator status (bonded/unbonding/unbonded).",
              "type": "string",
              "enum": [
                "BOND_STATUS_UNSPECIFIED",
                "BOND_STATUS_UNBONDED",
                "BOND_STATUS_UNBONDING",
                "BOND_STATUS_BONDED"
              ],
              "default": "BOND_STATUS_UNSPECIFIED"
            },
            "tokens": {
              "type": "string",
              "description": "tokens define the delegated tokens (incl. self-delegation)."
            },
            "delegator_shares": {
              "type": "string",
              "description": "delegator_shares defines total shares issued to a validator's delegators."
            },
            "description": {
              "description": "description defines the description terms for the validator.",
              "type": "object",
              "properties": {
                "moniker": {
                  "type": "string",
                  "description": "moniker defines a human-readable name for the validator."
                },
                "identity": {
                  "type": "string",
                  "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                },
                "website": {
                  "type": "string",
                  "description": "website defines an optional website link."
                },
                "security_contact": {
                  "type": "string",
                  "description": "security_contact defines an optional email for security contact."
                },
                "details": {
                  "type": "string",
                  "description": "details define other optional details."
                }
              }
            },
            "unbonding_height": {
              "type": "string",
              "format": "int64",
              "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."
            },
            "unbonding_time": {
              "type": "string",
              "format": "date-time",
              "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."
            },
            "commission": {
              "description": "commission defines the commission parameters.",
              "type": "object",
              "properties": {
                "commission_rates": {
                  "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                  "type": "object",
                  "properties": {
                    "rate": {
                      "type": "string",
                      "description": "rate is the commission rate charged to delegators, as a fraction."
                    },
                    "max_rate": {
                      "type": "string",
                      "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                    },
                    "max_change_rate": {
                      "type": "string",
                      "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                    }
                  }
                },
                "update_time": {
                  "type": "string",
                  "format": "date-time",
                  "description": "update_time is the last time the commission rate was changed."
                }
              }
            },
            "min_self_delegation": {
              "type": "string",
              "description": "min_self_delegation is the validator's self declared minimum self delegation."
            }
          },
          "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
        }
      },
      "description": "QueryDelegatorValidatorResponse response type for the\nQuery/DelegatorValidator RPC method."
    },
    "cosmos.staking.v1beta1.QueryDelegatorValidatorsResponse": {
      "type": "object",
      "properties": {
        "validators": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "operator_address": {
                "type": "string",
                "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
              },
              "consensus_pubkey": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "jailed": {
                "type": "boolean",
                "format": "boolean",
                "description": "jailed defined whether the validator has been jailed from bonded status or not."
              },
              "status": {
                "description": "status is the validator status (bonded/unbonding/unbonded).",
                "type": "string",
                "enum": [
                  "BOND_STATUS_UNSPECIFIED",
                  "BOND_STATUS_UNBONDED",
                  "BOND_STATUS_UNBONDING",
                  "BOND_STATUS_BONDED"
                ],
                "default": "BOND_STATUS_UNSPECIFIED"
              },
              "tokens": {
                "type": "string",
                "description": "tokens define the delegated tokens (incl. self-delegation)."
              },
              "delegator_shares": {
                "type": "string",
                "description": "delegator_shares defines total shares issued to a validator's delegators."
              },
              "description": {
                "description": "description defines the description terms for the validator.",
                "type": "object",
                "properties": {
                  "moniker": {
                    "type": "string",
                    "description": "moniker defines a human-readable name for the validator."
                  },
                  "identity": {
                    "type": "string",
                    "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                  },
                  "website": {
                    "type": "string",
                    "description": "website defines an optional website link."
                  },
                  "security_contact": {
                    "type": "string",
                    "description": "security_contact defines an optional email for security contact."
                  },
                  "details": {
                    "type": "string",
                    "description": "details define other optional details."
                  }
                }
              },
              "unbonding_height": {
                "type": "string",
                "format": "int64",
                "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."
              },
              "unbonding_time": {
                "type": "string",
                "format": "date-time",
                "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."
              },
              "commission": {
                "description": "commission defines the commission parameters.",
                "type": "object",
                "properties": {
                  "commission_rates": {
                    "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                    "type": "object",
                    "properties": {
                      "rate": {
                        "type": "string",
                        "description": "rate is the commission rate charged to delegators, as a fraction."
                      },
                      "max_rate": {
                        "type": "string",
                        "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                      },
                      "max_change_rate": {
                        "type": "string",
                        "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                      }
                    }
                  },
                  "update_time": {
                    "type": "string",
                    "format": "date-time",
                    "description": "update_time is the last time the commission rate was changed."
                  }
                }
              },
              "min_self_delegation": {
                "type": "string",
                "description": "min_self_delegation is the validator's self declared minimum self delegation."
              }
            },
            "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
          },
          "description": "validators defines the the validators' info of a delegator."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryDelegatorValidatorsResponse is response type for the\nQuery/DelegatorValidators RPC method."
    },
    "cosmos.staking.v1beta1.QueryHistoricalInfoResponse": {
      "type": "object",
      "properties": {
        "hist": {
          "description": "hist defines the historical info at the given height.",
          "type": "object",
          "properties": {
            "header": {
              "type": "object",
              "properties": {
                "version": {
                  "title": "basic block info",
                  "type": "object",
                  "properties": {
                    "block": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "app": {
                      "type": "string",
                      "format": "uint64"
                    }
                  },
                  "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                },
                "chain_id": {
                  "type": "string"
                },
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "time": {
                  "type": "string",
                  "format": "date-time"
                },
                "last_block_id": {
                  "title": "prev block info",
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  }
                },
                "last_commit_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes of block data"
                },
                "data_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "validators_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes from the app output from the prev block"
                },
                "next_validators_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "consensus_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "app_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "last_results_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "evidence_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "consensus info"
                },
                "proposer_address": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "description": "Header defines the structure of a Tendermint block header."
            },
            "valset": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "operator_address": {
                    "type": "string",
                    "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
                  },
                  "consensus_pubkey": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  },
                  "jailed": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "jailed defined whether the validator has been jailed from bonded status or not."
                  },
                  "status": {
                    "description": "status is the validator status (bonded/unbonding/unbonded).",
                    "type": "string",
                    "enum": [
                      "BOND_STATUS_UNSPECIFIED",
                      "BOND_STATUS_UNBONDED",
                      "BOND_STATUS_UNBONDING",
                      "BOND_STATUS_BONDED"
                    ],
                    "default": "BOND_STATUS_UNSPECIFIED"
                  },
                  "tokens": {
                    "type": "string",
                    "description": "tokens define the delegated tokens (incl. self-delegation)."
                  },
                  "delegator_shares": {
                    "type": "string",
                    "description": "delegator_shares defines total shares issued to a validator's delegators."
                  },
                  "description": {
                    "description": "description defines the description terms for the validator.",
                    "type": "object",
                    "properties": {
                      "moniker": {
                        "type": "string",
                        "description": "moniker defines a human-readable name for the validator."
                      },
                      "identity": {
                        "type": "string",
                        "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                      },
                      "website": {
                        "type": "string",
                        "description": "website defines an optional website link."
                      },
                      "security_contact": {
                        "type": "string",
                        "description": "security_contact defines an optional email for security contact."
                      },
                      "details": {
                        "type": "string",
                        "description": "details define other optional details."
                      }
                    }
                  },
                  "unbonding_height": {
                    "type": "string",
                    "format": "int64",
                    "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."
                  },
                  "unbonding_time": {
                    "type": "string",
                    "format": "date-time",
                    "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."
                  },
                  "commission": {
                    "description": "commission defines the commission parameters.",
                    "type": "object",
                    "properties": {
                      "commission_rates": {
                        "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                        "type": "object",
                        "properties": {
                          "rate": {
                            "type": "string",
                            "description": "rate is the commission rate charged to delegators, as a fraction."
                          },
                          "max_rate": {
                            "type": "string",
                            "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                          },
                          "max_change_rate": {
                            "type": "string",
                            "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                          }
                        }
                      },
                      "update_time": {
                        "type": "string",
                        "format": "date-time",
                        "description": "update_time is the last time the commission rate was changed."
                      }
                    }
                  },
                  "min_self_delegation": {
                    "type": "string",
                    "description": "min_self_delegation is the validator's self declared minimum self delegation."
                  }
                },
                "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
              }
            }
          }
        }
      },
      "description": "QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC\nmethod."
    },
    "cosmos.staking.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params holds all the parameters of this module.",
          "type": "object",
          "properties": {
            "unbonding_time": {
              "type": "string",
              "description": "unbonding_time is the time duration of unbonding."
            },
            "max_validators": {
              "type": "integer",
              "format": "int64",
              "description": "max_validators is the maximum number of validators."
            },
            "max_entries": {
              "type": "integer",
              "format": "int64",
              "description": "max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio)."
            },
            "historical_entries": {
              "type": "integer",
              "format": "int64",
              "description": "historical_entries is the number of historical entries to persist."
            },
            "bond_denom": {
              "type": "string",
              "description": "bond_denom defines the bondable coin denomination."
            }
          }
        }
      },
      "description": "QueryParamsResponse is response type for the Query/Params RPC method."
    },
    "cosmos.staking.v1beta1.QueryPoolResponse": {
      "type": "object",
      "properties": {
        "pool": {
          "description": "pool defines the pool info.",
          "type": "object",
          "properties": {
            "not_bonded_tokens": {
              "type": "string"
            },
            "bonded_tokens": {
              "type": "string"
            }
          }
        }
      },
      "description": "QueryPoolResponse is response type for the Query/Pool RPC method."
    },
    "cosmos.staking.v1beta1.QueryRedelegationsResponse": {
      "type": "object",
      "properties": {
        "redelegation_responses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "redelegation": {
                "type": "object",
                "properties": {
                  "delegator_address": {
                    "type": "string",
                    "description": "delegator_address is the bech32-encoded address of the delegator."
                  },
                  "validator_src_address": {
                    "type": "string",
                    "description": "validator_src_address is the validator redelegation source operator address."
                  },
                  "validator_dst_address": {
                    "type": "string",
                    "description": "validator_dst_address is the validator redelegation destination operator address."
                  },
                  "entries": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "creation_height": {
                          "type": "string",
                          "format": "int64",
                          "description": "creation_height  defines the height which the redelegation took place."
                        },
                        "completion_time": {
                          "type": "string",
                          "format": "date-time",
                          "description": "completion_time defines the unix time for redelegation completion."
                        },
                        "initial_balance": {
                          "type": "string",
                          "description": "initial_balance defines the initial balance when redelegation started."
                        },
                        "shares_dst": {
                          "type": "string",
                          "description": "shares_dst is the amount of destination-validator shares created by redelegation."
                        }
                      },
                      "description": "RedelegationEntry defines a redelegation object with relevant metadata."
                    },
                    "description": "entries are the redelegation entries."
                  }
                },
                "description": "Redelegation contains the list of a particular delegator's redelegating bonds\nfrom a particular source validator to a particular destination validator."
              },
              "entries": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "redelegation_entry": {
                      "type": "object",
                      "properties": {
                        "creation_height": {
                          "type": "string",
                          "format": "int64",
                          "description": "creation_height  defines the height which the redelegation took place."
                        },
                        "completion_time": {
                          "type": "string",
                          "format": "date-time",
                          "description": "completion_time defines the unix time for redelegation completion."
                        },
                        "initial_balance": {
                          "type": "string",
                          "description": "initial_balance defines the initial balance when redelegation started."
                        },
                        "shares_dst": {
                          "type": "string",
                          "description": "shares_dst is the amount of destination-validator shares created by redelegation."
                        }
                      },
                      "description": "RedelegationEntry defines a redelegation object with relevant metadata."
                    },
                    "balance": {
                      "type": "string"
                    }
                  },
                  "description": "RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\ncontains a balance in addition to shares which is more suitable for client\nresponses."
                }
              }
            },
            "description": "RedelegationResponse is equivalent to a Redelegation except that its entries\ncontain a balance in addition to shares which is more suitable for client\nresponses."
          }
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryRedelegationsResponse is response type for the Query/Redelegations RPC\nmethod."
    },
    "cosmos.staking.v1beta1.QueryUnbondingDelegationResponse": {
      "type": "object",
      "properties": {
        "unbond": {
          "type": "object",
          "properties": {
            "delegator_address": {
              "type": "string",
              "description": "delegator_address is the bech32-encoded address of the delegator."
            },
            "validator_address": {
              "type": "string",
              "description": "validator_address is the bech32-encoded address of the validator."
            },
            "entries": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "creation_height": {
                    "type": "string",
                    "format": "int64",
                    "description": "creation_height is the height which the unbonding took place."
                  },
                  "completion_time": {
                    "type": "string",
                    "format": "date-time",
                    "description": "completion_time is the unix time for unbonding completion."
                  },
                  "initial_balance": {
                    "type": "string",
                    "description": "initial_balance defines the tokens initially scheduled to receive at completion."
                  },
                  "balance": {
                    "type": "string",
                    "description": "balance defines the tokens to receive at completion."
                  }
                },
                "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
              },
              "description": "entries are the unbonding delegation entries."
            }
          },
          "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list."
        }
      },
      "description": "QueryDelegationResponse is response type for the Query/UnbondingDelegation\nRPC method."
    },
    "cosmos.staking.v1beta1.QueryValidatorDelegationsResponse": {
      "type": "object",
      "properties": {
        "delegation_responses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "delegation": {
                "type": "object",
                "properties": {
                  "delegator_address": {
                    "type": "string",
                    "description": "delegator_address is the bech32-encoded address of the delegator."
                  },
                  "validator_address": {
                    "type": "string",
                    "description": "validator_address is the bech32-encoded address of the validator."
                  },
                  "shares": {
                    "type": "string",
                    "description": "shares define the delegation shares received."
                  }
                },
                "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
              },
              "balance": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              }
            },
            "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses."
          }
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "title": "QueryValidatorDelegationsResponse is response type for the\nQuery/ValidatorDelegations RPC method"
    },
    "cosmos.staking.v1beta1.QueryValidatorResponse": {
      "type": "object",
      "properties": {
        "validator": {
          "type": "object",
          "properties": {
            "operator_address": {
              "type": "string",
              "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
            },
            "consensus_pubkey": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "type": "string",
                  "format": "byte",
                  "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            },
            "jailed": {
              "type": "boolean",
              "format": "boolean",
              "description": "jailed defined whether the validator has been jailed from bonded status or not."
            },
            "status": {
              "description": "status is the validator status (bonded/unbonding/unbonded).",
              "type": "string",
              "enum": [
                "BOND_STATUS_UNSPECIFIED",
                "BOND_STATUS_UNBONDED",
                "BOND_STATUS_UNBONDING",
                "BOND_STATUS_BONDED"
              ],
              "default": "BOND_STATUS_UNSPECIFIED"
            },
            "tokens": {
              "type": "string",
              "description": "tokens define the delegated tokens (incl. self-delegation)."
            },
            "delegator_shares": {
              "type": "string",
              "description": "delegator_shares defines total shares issued to a validator's delegators."
            },
            "description": {
              "description": "description defines the description terms for the validator.",
              "type": "object",
              "properties": {
                "moniker": {
                  "type": "string",
                  "description": "moniker defines a human-readable name for the validator."
                },
                "identity": {
                  "type": "string",
                  "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                },
                "website": {
                  "type": "string",
                  "description": "website defines an optional website link."
                },
                "security_contact": {
                  "type": "string",
                  "description": "security_contact defines an optional email for security contact."
                },
                "details": {
                  "type": "string",
                  "description": "details define other optional details."
                }
              }
            },
            "unbonding_height": {
              "type": "string",
              "format": "int64",
              "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."
            },
            "unbonding_time": {
              "type": "string",
              "format": "date-time",
              "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."
            },
            "commission": {
              "description": "commission defines the commission parameters.",
              "type": "object",
              "properties": {
                "commission_rates": {
                  "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                  "type": "object",
                  "properties": {
                    "rate": {
                      "type": "string",
                      "description": "rate is the commission rate charged to delegators, as a fraction."
                    },
                    "max_rate": {
                      "type": "string",
                      "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                    },
                    "max_change_rate": {
                      "type": "string",
                      "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                    }
                  }
                },
                "update_time": {
                  "type": "string",
                  "format": "date-time",
                  "description": "update_time is the last time the commission rate was changed."
                }
              }
            },
            "min_self_delegation": {
              "type": "string",
              "description": "min_self_delegation is the validator's self declared minimum self delegation."
            }
          },
          "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
        }
      },
      "title": "QueryValidatorResponse is response type for the Query/Validator RPC method"
    },
    "cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsResponse": {
      "type": "object",
      "properties": {
        "unbonding_responses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "delegator_address": {
                "type": "string",
                "description": "delegator_address is the bech32-encoded address of the delegator."
              },
              "validator_address": {
                "type": "string",
                "description": "validator_address is the bech32-encoded address of the validator."
              },
              "entries": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "creation_height": {
                      "type": "string",
                      "format": "int64",
                      "description": "creation_height is the height which the unbonding took place."
                    },
                    "completion_time": {
                      "type": "string",
                      "format": "date-time",
                      "description": "completion_time is the unix time for unbonding completion."
                    },
                    "initial_balance": {
                      "type": "string",
                      "description": "initial_balance defines the tokens initially scheduled to receive at completion."
                    },
                    "balance": {
                      "type": "string",
                      "description": "balance defines the tokens to receive at completion."
                    }
                  },
                  "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
                },
                "description": "entries are the unbonding delegation entries."
              }
            },
            "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list."
          }
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryValidatorUnbondingDelegationsResponse is response type for the\nQuery/ValidatorUnbondingDelegations RPC method."
    },
    "cosmos.staking.v1beta1.QueryValidatorsResponse": {
      "type": "object",
      "properties": {
        "validators": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "operator_address": {
                "type": "string",
                "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
              },
              "consensus_pubkey": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "jailed": {
                "type": "boolean",
                "format": "boolean",
                "description": "jailed defined whether the validator has been jailed from bonded status or not."
              },
              "status": {
                "description": "status is the validator status (bonded/unbonding/unbonded).",
                "type": "string",
                "enum": [
                  "BOND_STATUS_UNSPECIFIED",
                  "BOND_STATUS_UNBONDED",
                  "BOND_STATUS_UNBONDING",
                  "BOND_STATUS_BONDED"
                ],
                "default": "BOND_STATUS_UNSPECIFIED"
              },
              "tokens": {
                "type": "string",
                "description": "tokens define the delegated tokens (incl. self-delegation)."
              },
              "delegator_shares": {
                "type": "string",
                "description": "delegator_shares defines total shares issued to a validator's delegators."
              },
              "description": {
                "description": "description defines the description terms for the validator.",
                "type": "object",
                "properties": {
                  "moniker": {
                    "type": "string",
                    "description": "moniker defines a human-readable name for the validator."
                  },
                  "identity": {
                    "type": "string",
                    "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                  },
                  "website": {
                    "type": "string",
                    "description": "website defines an optional website link."
                  },
                  "security_contact": {
                    "type": "string",
                    "description": "security_contact defines an optional email for security contact."
                  },
                  "details": {
                    "type": "string",
                    "description": "details define other optional details."
                  }
                }
              },
              "unbonding_height": {
                "type": "string",
                "format": "int64",
                "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."
              },
              "unbonding_time": {
                "type": "string",
                "format": "date-time",
                "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."
              },
              "commission": {
                "description": "commission defines the commission parameters.",
                "type": "object",
                "properties": {
                  "commission_rates": {
                    "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                    "type": "object",
                    "properties": {
                      "rate": {
                        "type": "string",
                        "description": "rate is the commission rate charged to delegators, as a fraction."
                      },
                      "max_rate": {
                        "type": "string",
                        "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                      },
                      "max_change_rate": {
                        "type": "string",
                        "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                      }
                    }
                  },
                  "update_time": {
                    "type": "string",
                    "format": "date-time",
                    "description": "update_time is the last time the commission rate was changed."
                  }
                }
              },
              "min_self_delegation": {
                "type": "string",
                "description": "min_self_delegation is the validator's self declared minimum self delegation."
              }
            },
            "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
          },
          "description": "validators contains all the queried validators."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "title": "QueryValidatorsResponse is response type for the Query/Validators RPC method"
    },
    "cosmos.staking.v1beta1.Redelegation": {
      "type": "object",
      "properties": {
        "delegator_address": {
          "type": "string",
          "description": "delegator_address is the bech32-encoded address of the delegator."
        },
        "validator_src_address": {
          "type": "string",
          "description": "validator_src_address is the validator redelegation source operator address."
        },
        "validator_dst_address": {
          "type": "string",
          "description": "validator_dst_address is the validator redelegation destination operator address."
        },
        "entries": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "creation_height": {
                "type": "string",
                "format": "int64",
                "description": "creation_height  defines the height which the redelegation took place."
              },
              "completion_time": {
                "type": "string",
                "format": "date-time",
                "description": "completion_time defines the unix time for redelegation completion."
              },
              "initial_balance": {
                "type": "string",
                "description": "initial_balance defines the initial balance when redelegation started."
              },
              "shares_dst": {
                "type": "string",
                "description": "shares_dst is the amount of destination-validator shares created by redelegation."
              }
            },
            "description": "RedelegationEntry defines a redelegation object with relevant metadata."
          },
          "description": "entries are the redelegation entries."
        }
      },
      "description": "Redelegation contains the list of a particular delegator's redelegating bonds\nfrom a particular source validator to a particular destination validator."
    },
    "cosmos.staking.v1beta1.RedelegationEntry": {
      "type": "object",
      "properties": {
        "creation_height": {
          "type": "string",
          "format": "int64",
          "description": "creation_height  defines the height which the redelegation took place."
        },
        "completion_time": {
          "type": "string",
          "format": "date-time",
          "description": "completion_time defines the unix time for redelegation completion."
        },
        "initial_balance": {
          "type": "string",
          "description": "initial_balance defines the initial balance when redelegation started."
        },
        "shares_dst": {
          "type": "string",
          "description": "shares_dst is the amount of destination-validator shares created by redelegation."
        }
      },
      "description": "RedelegationEntry defines a redelegation object with relevant metadata."
    },
    "cosmos.staking.v1beta1.RedelegationEntryResponse": {
      "type": "object",
      "properties": {
        "redelegation_entry": {
          "type": "object",
          "properties": {
            "creation_height": {
              "type": "string",
              "format": "int64",
              "description": "creation_height  defines the height which the redelegation took place."
            },
            "completion_time": {
              "type": "string",
              "format": "date-time",
              "description": "completion_time defines the unix time for redelegation completion."
            },
            "initial_balance": {
              "type": "string",
              "description": "initial_balance defines the initial balance when redelegation started."
            },
            "shares_dst": {
              "type": "string",
              "description": "shares_dst is the amount of destination-validator shares created by redelegation."
            }
          },
          "description": "RedelegationEntry defines a redelegation object with relevant metadata."
        },
        "balance": {
          "type": "string"
        }
      },
      "description": "RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\ncontains a balance in addition to shares which is more suitable for client\nresponses."
    },
    "cosmos.staking.v1beta1.RedelegationResponse": {
      "type": "object",
      "properties": {
        "redelegation": {
          "type": "object",
          "properties": {
            "delegator_address": {
              "type": "string",
              "description": "delegator_address is the bech32-encoded address of the delegator."
            },
            "validator_src_address": {
              "type": "string",
              "description": "validator_src_address is the validator redelegation source operator address."
            },
            "validator_dst_address": {
              "type": "string",
              "description": "validator_dst_address is the validator redelegation destination operator address."
            },
            "entries": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "creation_height": {
                    "type": "string",
                    "format": "int64",
                    "description": "creation_height  defines the height which the redelegation took place."
                  },
                  "completion_time": {
                    "type": "string",
                    "format": "date-time",
                    "description": "completion_time defines the unix time for redelegation completion."
                  },
                  "initial_balance": {
                    "type": "string",
                    "description": "initial_balance defines the initial balance when redelegation started."
                  },
                  "shares_dst": {
                    "type": "string",
                    "description": "shares_dst is the amount of destination-validator shares created by redelegation."
                  }
                },
                "description": "RedelegationEntry defines a redelegation object with relevant metadata."
              },
              "description": "entries are the redelegation entries."
            }
          },
          "description": "Redelegation contains the list of a particular delegator's redelegating bonds\nfrom a particular source validator to a particular destination validator."
        },
        "entries": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "redelegation_entry": {
                "type": "object",
                "properties": {
                  "creation_height": {
                    "type": "string",
                    "format": "int64",
                    "description": "creation_height  defines the height which the redelegation took place."
                  },
                  "completion_time": {
                    "type": "string",
                    "format": "date-time",
                    "description": "completion_time defines the unix time for redelegation completion."
                  },
                  "initial_balance": {
                    "type": "string",
                    "description": "initial_balance defines the initial balance when redelegation started."
                  },
                  "shares_dst": {
                    "type": "string",
                    "description": "shares_dst is the amount of destination-validator shares created by redelegation."
                  }
                },
                "description": "RedelegationEntry defines a redelegation object with relevant metadata."
              },
              "balance": {
                "type": "string"
              }
            },
            "description": "RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\ncontains a balance in addition to shares which is more suitable for client\nresponses."
          }
        }
      },
      "description": "RedelegationResponse is equivalent to a Redelegation except that its entries\ncontain a balance in addition to shares which is more suitable for client\nresponses."
    },
    "cosmos.staking.v1beta1.UnbondingDelegation": {
      "type": "object",
      "properties": {
        "delegator_address": {
          "type": "string",
          "description": "delegator_address is the bech32-encoded address of the delegator."
        },
        "validator_address": {
          "type": "string",
          "description": "validator_address is the bech32-encoded address of the validator."
        },
        "entries": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "creation_height": {
                "type": "string",
                "format": "int64",
                "description": "creation_height is the height which the unbonding took place."
              },
              "completion_time": {
                "type": "string",
                "format": "date-time",
                "description": "completion_time is the unix time for unbonding completion."
              },
              "initial_balance": {
                "type": "string",
                "description": "initial_balance defines the tokens initially scheduled to receive at completion."
              },
              "balance": {
                "type": "string",
                "description": "balance defines the tokens to receive at completion."
              }
            },
            "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
          },
          "description": "entries are the unbonding delegation entries."
        }
      },
      "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list."
    },
    "cosmos.staking.v1beta1.UnbondingDelegationEntry": {
      "type": "object",
      "properties": {
        "creation_height": {
          "type": "string",
          "format": "int64",
          "description": "creation_height is the height which the unbonding took place."
        },
        "completion_time": {
          "type": "string",
          "format": "date-time",
          "description": "completion_time is the unix time for unbonding completion."
        },
        "initial_balance": {
          "type": "string",
          "description": "initial_balance defines the tokens initially scheduled to receive at completion."
        },
        "balance": {
          "type": "string",
          "description": "balance defines the tokens to receive at completion."
        }
      },
      "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
    },
    "cosmos.staking.v1beta1.Validator": {
      "type": "object",
      "properties": {
        "operator_address": {
          "type": "string",
          "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
        },
        "consensus_pubkey": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        },
        "jailed": {
          "type": "boolean",
          "format": "boolean",
          "description": "jailed defined whether the validator has been jailed from bonded status or not."
        },
        "status": {
          "description": "status is the validator status (bonded/unbonding/unbonded).",
          "type": "string",
          "enum": [
            "BOND_STATUS_UNSPECIFIED",
            "BOND_STATUS_UNBONDED",
            "BOND_STATUS_UNBONDING",
            "BOND_STATUS_BONDED"
          ],
          "default": "BOND_STATUS_UNSPECIFIED"
        },
        "tokens": {
          "type": "string",
          "description": "tokens define the delegated tokens (incl. self-delegation)."
        },
        "delegator_shares": {
          "type": "string",
          "description": "delegator_shares defines total shares issued to a validator's delegators."
        },
        "description": {
          "description": "description defines the description terms for the validator.",
          "type": "object",
          "properties": {
            "moniker": {
              "type": "string",
              "description": "moniker defines a human-readable name for the validator."
            },
            "identity": {
              "type": "string",
              "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
            },
            "website": {
              "type": "string",
              "description": "website defines an optional website link."
            },
            "security_contact": {
              "type": "string",
              "description": "security_contact defines an optional email for security contact."
            },
            "details": {
              "type": "string",
              "description": "details define other optional details."
            }
          }
        },
        "unbonding_height": {
          "type": "string",
          "format": "int64",
          "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."
        },
        "unbonding_time": {
          "type": "string",
          "format": "date-time",
          "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."
        },
        "commission": {
          "description": "commission defines the commission parameters.",
          "type": "object",
          "properties": {
            "commission_rates": {
              "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
              "type": "object",
              "properties": {
                "rate": {
                  "type": "string",
                  "description": "rate is the commission rate charged to delegators, as a fraction."
                },
                "max_rate": {
                  "type": "string",
                  "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                },
                "max_change_rate": {
                  "type": "string",
                  "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                }
              }
            },
            "update_time": {
              "type": "string",
              "format": "date-time",
              "description": "update_time is the last time the commission rate was changed."
            }
          }
        },
        "min_self_delegation": {
          "type": "string",
          "description": "min_self_delegation is the validator's self declared minimum self delegation."
        }
      },
      "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
    },
    "cosmos.base.abci.v1beta1.ABCIMessageLog": {
      "type": "object",
      "properties": {
        "msg_index": {
          "type": "integer",
          "format": "int64"
        },
        "log": {
          "type": "string"
        },
        "events": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string"
              },
              "attributes": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "key": {
                      "type": "string"
                    },
                    "value": {
                      "type": "string"
                    }
                  },
                  "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
                }
              }
            },
            "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
          },
          "description": "Events contains a slice of Event objects that were emitted during some\nexecution."
        }
      },
      "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log."
    },
    "cosmos.base.abci.v1beta1.Attribute": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      },
      "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
    },
    "cosmos.base.abci.v1beta1.GasInfo": {
      "type": "object",
      "properties": {
        "gas_wanted": {
          "type": "string",
          "format": "uint64",
          "description": "GasWanted is the maximum units of work we allow this tx to perform."
        },
        "gas_used": {
          "type": "string",
          "format": "uint64",
          "description": "GasUsed is the amount of gas actually consumed."
        }
      },
      "description": "GasInfo defines tx execution gas context."
    },
    "cosmos.base.abci.v1beta1.Result": {
      "type": "object",
      "properties": {
        "data": {
          "type": "string",
          "format": "byte",
          "description": "Data is any data returned from message or handler execution. It MUST be\nlength prefixed in order to separate data from multiple message executions."
        },
        "log": {
          "type": "string",
          "description": "Log contains the log information from message or handler execution."
        },
        "events": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string"
              },
              "attributes": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "key": {
                      "type": "string",
                      "format": "byte"
                    },
                    "value": {
                      "type": "string",
                      "format": "byte"
                    },
                    "index": {
                      "type": "boolean",
                      "format": "boolean"
                    }
                  },
                  "description": "EventAttribute is a single key-value pair, associated with an event."
                }
              }
            },
            "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events."
          },
          "description": "Events contains a slice of Event objects that were emitted during message\nor handler execution."
        }
      },
      "description": "Result is the union of ResponseFormat and ResponseCheckTx."
    },
    "cosmos.base.abci.v1beta1.StringEvent": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "attributes": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "key": {
                "type": "string"
              },
              "value": {
                "type": "string"
              }
            },
            "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
          }
        }
      },
      "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
    },
    "cosmos.base.abci.v1beta1.TxResponse": {
      "type": "object",
      "properties": {
        "height": {
          "type": "string",
          "format": "int64",
          "title": "The block height"
        },
        "txhash": {
          "type": "string",
          "description": "The transaction hash."
        },
        "codespace": {
          "type": "string",
          "title": "Namespace for the Code"
        },
        "code": {
          "type": "integer",
          "format": "int64",
          "description": "Response code."
        },
        "data": {
          "type": "string",
          "description": "Result bytes, if any."
        },
        "raw_log": {
          "type": "string",
          "description": "The output of the application's logger (raw string). May be\nnon-deterministic."
        },
        "logs": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "msg_index": {
                "type": "integer",
                "format": "int64"
              },
              "log": {
                "type": "string"
              },
              "events": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string"
                    },
                    "attributes": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "key": {
                            "type": "string"
                          },
                          "value": {
                            "type": "string"
                          }
                        },
                        "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
                      }
                    }
                  },
                  "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
                },
                "description": "Events contains a slice of Event objects that were emitted during some\nexecution."
              }
            },
            "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log."
          },
          "description": "The output of the application's logger (typed). May be non-deterministic."
        },
        "info": {
          "type": "string",
          "description": "Additional information. May be non-deterministic."
        },
        "gas_wanted": {
          "type": "string",
          "format": "int64",
          "description": "Amount of gas requested for transaction."
        },
        "gas_used": {
          "type": "string",
          "format": "int64",
          "description": "Amount of gas consumed by transaction."
        },
        "tx": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        },
        "timestamp": {
          "type": "string",
          "description": "Time of the previous block. For heights > 1, it's the weighted median of\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\nit's genesis time."
        },
        "events": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string"
              },
              "attributes": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "key": {
                      "type": "string",
                      "format": "byte"
                    },
                    "value": {
                      "type": "string",
                      "format": "byte"
                    },
                    "index": {
                      "type": "boolean",
                      "format": "boolean"
                    }
                  },
                  "description": "EventAttribute is a single key-value pair, associated with an event."
                }
              }
            },
            "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events."
          },
          "description": "Events defines all the events emitted by processing a transaction. Note,\nthese events include those emitted by processing all the messages and those\nemitted from the ante handler. Whereas Logs contains the events, with\nadditional metadata, emitted only by processing the messages.\n\nSince: cosmos-sdk 0.42.11, 0.44.5, 0.45"
        }
      },
      "description": "TxResponse defines a structure containing relevant tx data and metadata. The\ntags are stringified and the log is JSON decoded."
    },
    "cosmos.crypto.multisig.v1beta1.CompactBitArray": {
      "type": "object",
      "properties": {
        "extra_bits_stored": {
          "type": "integer",
          "format": "int64"
        },
        "elems": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "CompactBitArray is an implementation of a space efficient bit array.\nThis is used to ensure that the encoded data takes up a minimal amount of\nspace after proto encoding.\nThis is not thread safe, and is not intended for concurrent usage."
    },
    "cosmos.tx.signing.v1beta1.SignMode": {
      "type": "string",
      "enum": [
        "SIGN_MODE_UNSPECIFIED",
        "SIGN_MODE_DIRECT",
        "SIGN_MODE_TEXTUAL",
        "SIGN_MODE_LEGACY_AMINO_JSON"
      ],
      "default": "SIGN_MODE_UNSPECIFIED",
      "description": "SignMode represents a signing mode with its own security guarantees.\n\n - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\nrejected\n - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\nverified with raw bytes from Tx\n - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some\nhuman-readable textual representation on top of the binary representation\nfrom SIGN_MODE_DIRECT\n - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\nAmino JSON and will be removed in the future"
    },
    "cosmos.tx.v1beta1.AuthInfo": {
      "type": "object",
      "properties": {
        "signer_infos": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/cosmos.tx.v1beta1.SignerInfo"
          },
          "description": "signer_infos defines the signing modes for the required signers. The number\nand order of elements must match the required signers from TxBody's\nmessages. The first element is the primary signer and the one which pays\nthe fee."
        },
        "fee": {
          "description": "Fee is the fee and gas limit for the transaction. The first signer is the\nprimary signer and the one which pays the fee. The fee can be calculated\nbased on the cost of evaluating the body and doing signature verification\nof the signers. This can be estimated via simulation.",
          "type": "object",
          "properties": {
            "amount": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              },
              "title": "amount is the amount of coins to be paid as a fee"
            },
            "gas_limit": {
              "type": "string",
              "format": "uint64",
              "title": "gas_limit is the maximum gas that can be used in transaction processing\nbefore an out of gas error occurs"
            },
            "payer": {
              "type": "string",
              "description": "if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.\nthe payer must be a tx signer (and thus have signed this field in AuthInfo).\nsetting this field does *not* change the ordering of required signers for the transaction."
            },
            "granter": {
              "type": "string",
              "title": "if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used\nto pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does\nnot support fee grants, this will fail"
            }
          }
        }
      },
      "description": "AuthInfo describes the fee and signer modes that are used to sign a\ntransaction."
    },
    "cosmos.tx.v1beta1.BroadcastMode": {
      "type": "string",
      "enum": [
        "BROADCAST_MODE_UNSPECIFIED",
        "BROADCAST_MODE_BLOCK",
        "BROADCAST_MODE_SYNC",
        "BROADCAST_MODE_ASYNC"
      ],
      "default": "BROADCAST_MODE_UNSPECIFIED",
      "description": "BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.\n\n - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering\n - BROADCAST_MODE_BLOCK: BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for\nthe tx to be committed in a block.\n - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for\na CheckTx execution response only.\n - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns\nimmediately."
    },
    "cosmos.tx.v1beta1.BroadcastTxRequest": {
      "type": "object",
      "properties": {
        "tx_bytes": {
          "type": "string",
          "format": "byte",
          "description": "tx_bytes is the raw transaction."
        },
        "mode": {
          "type": "string",
          "enum": [
            "BROADCAST_MODE_UNSPECIFIED",
            "BROADCAST_MODE_BLOCK",
            "BROADCAST_MODE_SYNC",
            "BROADCAST_MODE_ASYNC"
          ],
          "default": "BROADCAST_MODE_UNSPECIFIED",
          "description": "BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.\n\n - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering\n - BROADCAST_MODE_BLOCK: BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for\nthe tx to be committed in a block.\n - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for\na CheckTx execution response only.\n - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns\nimmediately."
        }
      },
      "description": "BroadcastTxRequest is the request type for the Service.BroadcastTxRequest\nRPC method."
    },
    "cosmos.tx.v1beta1.BroadcastTxResponse": {
      "type": "object",
      "properties": {
        "tx_response": {
          "type": "object",
          "properties": {
            "height": {
              "type": "string",
              "format": "int64",
              "title": "The block height"
            },
            "txhash": {
              "type": "string",
              "description": "The transaction hash."
            },
            "codespace": {
              "type": "string",
              "title": "Namespace for the Code"
            },
            "code": {
              "type": "integer",
              "format": "int64",
              "description": "Response code."
            },
            "data": {
              "type": "string",
              "description": "Result bytes, if any."
            },
            "raw_log": {
              "type": "string",
              "description": "The output of the application's logger (raw string). May be\nnon-deterministic."
            },
            "logs": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "msg_index": {
                    "type": "integer",
                    "format": "int64"
                  },
                  "log": {
                    "type": "string"
                  },
                  "events": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string"
                        },
                        "attributes": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "key": {
                                "type": "string"
                              },
                              "value": {
                                "type": "string"
                              }
                            },
                            "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
                          }
                        }
                      },
                      "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
                    },
                    "description": "Events contains a slice of Event objects that were emitted during some\nexecution."
                  }
                },
                "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log."
              },
              "description": "The output of the application's logger (typed). May be non-deterministic."
            },
            "info": {
              "type": "string",
              "description": "Additional information. May be non-deterministic."
            },
            "gas_wanted": {
              "type": "string",
              "format": "int64",
              "description": "Amount of gas requested for transaction."
            },
            "gas_used": {
              "type": "string",
              "format": "int64",
              "description": "Amount of gas consumed by transaction."
            },
            "tx": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "type": "string",
                  "format": "byte",
                  "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            },
            "timestamp": {
              "type": "string",
              "description": "Time of the previous block. For heights > 1, it's the weighted median of\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\nit's genesis time."
            },
            "events": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type": {
                    "type": "string"
                  },
                  "attributes": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "key": {
                          "type": "string",
                          "format": "byte"
                        },
                        "value": {
                          "type": "string",
                          "format": "byte"
                        },
                        "index": {
                          "type": "boolean",
                          "format": "boolean"
                        }
                      },
                      "description": "EventAttribute is a single key-value pair, associated with an event."
                    }
                  }
                },
                "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events."
              },
              "description": "Events defines all the events emitted by processing a transaction. Note,\nthese events include those emitted by processing all the messages and those\nemitted from the ante handler. Whereas Logs contains the events, with\nadditional metadata, emitted only by processing the messages.\n\nSince: cosmos-sdk 0.42.11, 0.44.5, 0.45"
            }
          },
          "description": "TxResponse defines a structure containing relevant tx data and metadata. The\ntags are stringified and the log is JSON decoded."
        }
      },
      "description": "BroadcastTxResponse is the response type for the\nService.BroadcastTx method."
    },
    "cosmos.tx.v1beta1.Fee": {
      "type": "object",
      "properties": {
        "amount": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          },
          "title": "amount is the amount of coins to be paid as a fee"
        },
        "gas_limit": {
          "type": "string",
          "format": "uint64",
          "title": "gas_limit is the maximum gas that can be used in transaction processing\nbefore an out of gas error occurs"
        },
        "payer": {
          "type": "string",
          "description": "if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.\nthe payer must be a tx signer (and thus have signed this field in AuthInfo).\nsetting this field does *not* change the ordering of required signers for the transaction."
        },
        "granter": {
          "type": "string",
          "title": "if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used\nto pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does\nnot support fee grants, this will fail"
        }
      },
      "description": "Fee includes the amount of coins paid in fees and the maximum\ngas to be used by the transaction. The ratio yields an effective \"gasprice\",\nwhich must be above some miminum to be accepted into the mempool."
    },
    "cosmos.tx.v1beta1.GetTxResponse": {
      "type": "object",
      "properties": {
        "tx": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.Tx",
          "description": "tx is the queried transaction."
        },
        "tx_response": {
          "type": "object",
          "properties": {
            "height": {
              "type": "string",
              "format": "int64",
              "title": "The block height"
            },
            "txhash": {
              "type": "string",
              "description": "The transaction hash."
            },
            "codespace": {
              "type": "string",
              "title": "Namespace for the Code"
            },
            "code": {
              "type": "integer",
              "format": "int64",
              "description": "Response code."
            },
            "data": {
              "type": "string",
              "description": "Result bytes, if any."
            },
            "raw_log": {
              "type": "string",
              "description": "The output of the application's logger (raw string). May be\nnon-deterministic."
            },
            "logs": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "msg_index": {
                    "type": "integer",
                    "format": "int64"
                  },
                  "log": {
                    "type": "string"
                  },
                  "events": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string"
                        },
                        "attributes": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "key": {
                                "type": "string"
                              },
                              "value": {
                                "type": "string"
                              }
                            },
                            "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
                          }
                        }
                      },
                      "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
                    },
                    "description": "Events contains a slice of Event objects that were emitted during some\nexecution."
                  }
                },
                "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log."
              },
              "description": "The output of the application's logger (typed). May be non-deterministic."
            },
            "info": {
              "type": "string",
              "description": "Additional information. May be non-deterministic."
            },
            "gas_wanted": {
              "type": "string",
              "format": "int64",
              "description": "Amount of gas requested for transaction."
            },
            "gas_used": {
              "type": "string",
              "format": "int64",
              "description": "Amount of gas consumed by transaction."
            },
            "tx": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "type": "string",
                  "format": "byte",
                  "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            },
            "timestamp": {
              "type": "string",
              "description": "Time of the previous block. For heights > 1, it's the weighted median of\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\nit's genesis time."
            },
            "events": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type": {
                    "type": "string"
                  },
                  "attributes": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "key": {
                          "type": "string",
                          "format": "byte"
                        },
                        "value": {
                          "type": "string",
                          "format": "byte"
                        },
                        "index": {
                          "type": "boolean",
                          "format": "boolean"
                        }
                      },
                      "description": "EventAttribute is a single key-value pair, associated with an event."
                    }
                  }
                },
                "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events."
              },
              "description": "Events defines all the events emitted by processing a transaction. Note,\nthese events include those emitted by processing all the messages and those\nemitted from the ante handler. Whereas Logs contains the events, with\nadditional metadata, emitted only by processing the messages.\n\nSince: cosmos-sdk 0.42.11, 0.44.5, 0.45"
            }
          },
          "description": "TxResponse defines a structure containing relevant tx data and metadata. The\ntags are stringified and the log is JSON decoded."
        }
      },
      "description": "GetTxResponse is the response type for the Service.GetTx method."
    },
    "cosmos.tx.v1beta1.GetTxsEventResponse": {
      "type": "object",
      "properties": {
        "txs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/cosmos.tx.v1beta1.Tx"
          },
          "description": "txs is the list of queried transactions."
        },
        "tx_responses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "height": {
                "type": "string",
                "format": "int64",
                "title": "The block height"
              },
              "txhash": {
                "type": "string",
                "description": "The transaction hash."
              },
              "codespace": {
                "type": "string",
                "title": "Namespace for the Code"
              },
              "code": {
                "type": "integer",
                "format": "int64",
                "description": "Response code."
              },
              "data": {
                "type": "string",
                "description": "Result bytes, if any."
              },
              "raw_log": {
                "type": "string",
                "description": "The output of the application's logger (raw string). May be\nnon-deterministic."
              },
              "logs": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "msg_index": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "log": {
                      "type": "string"
                    },
                    "events": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string"
                          },
                          "attributes": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "key": {
                                  "type": "string"
                                },
                                "value": {
                                  "type": "string"
                                }
                              },
                              "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
                            }
                          }
                        },
                        "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
                      },
                      "description": "Events contains a slice of Event objects that were emitted during some\nexecution."
                    }
                  },
                  "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log."
                },
                "description": "The output of the application's logger (typed). May be non-deterministic."
              },
              "info": {
                "type": "string",
                "description": "Additional information. May be non-deterministic."
              },
              "gas_wanted": {
                "type": "string",
                "format": "int64",
                "description": "Amount of gas requested for transaction."
              },
              "gas_used": {
                "type": "string",
                "format": "int64",
                "description": "Amount of gas consumed by transaction."
              },
              "tx": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "timestamp": {
                "type": "string",
                "description": "Time of the previous block. For heights > 1, it's the weighted median of\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\nit's genesis time."
              },
              "events": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string"
                    },
                    "attributes": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "key": {
                            "type": "string",
                            "format": "byte"
                          },
                          "value": {
                            "type": "string",
                            "format": "byte"
                          },
                          "index": {
                            "type": "boolean",
                            "format": "boolean"
                          }
                        },
                        "description": "EventAttribute is a single key-value pair, associated with an event."
                      }
                    }
                  },
                  "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events."
                },
                "description": "Events defines all the events emitted by processing a transaction. Note,\nthese events include those emitted by processing all the messages and those\nemitted from the ante handler. Whereas Logs contains the events, with\nadditional metadata, emitted only by processing the messages.\n\nSince: cosmos-sdk 0.42.11, 0.44.5, 0.45"
              }
            },
            "description": "TxResponse defines a structure containing relevant tx data and metadata. The\ntags are stringified and the log is JSON decoded."
          },
          "description": "tx_responses is the list of queried TxResponses."
        },
        "pagination": {
          "description": "pagination defines an pagination for the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "GetTxsEventResponse is the response type for the Service.TxsByEvents\nRPC method."
    },
    "cosmos.tx.v1beta1.ModeInfo": {
      "type": "object",
      "properties": {
        "single": {
          "title": "single represents a single signer",
          "type": "object",
          "properties": {
            "mode": {
              "title": "mode is the signing mode of the single signer",
              "type": "string",
              "enum": [
                "SIGN_MODE_UNSPECIFIED",
                "SIGN_MODE_DIRECT",
                "SIGN_MODE_TEXTUAL",
                "SIGN_MODE_LEGACY_AMINO_JSON"
              ],
              "default": "SIGN_MODE_UNSPECIFIED",
              "description": "SignMode represents a signing mode with its own security guarantees.\n\n - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\nrejected\n - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\nverified with raw bytes from Tx\n - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some\nhuman-readable textual representation on top of the binary representation\nfrom SIGN_MODE_DIRECT\n - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\nAmino JSON and will be removed in the future"
            }
          }
        },
        "multi": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.ModeInfo.Multi",
          "title": "multi represents a nested multisig signer"
        }
      },
      "description": "ModeInfo describes the signing mode of a single or nested multisig signer."
    },
    "cosmos.tx.v1beta1.ModeInfo.Multi": {
      "type": "object",
      "properties": {
        "bitarray": {
          "title": "bitarray specifies which keys within the multisig are signing",
          "type": "object",
          "properties": {
            "extra_bits_stored": {
              "type": "integer",
              "format": "int64"
            },
            "elems": {
              "type": "string",
              "format": "byte"
            }
          },
          "description": "CompactBitArray is an implementation of a space efficient bit array.\nThis is used to ensure that the encoded data takes up a minimal amount of\nspace after proto encoding.\nThis is not thread safe, and is not intended for concurrent usage."
        },
        "mode_infos": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/cosmos.tx.v1beta1.ModeInfo"
          },
          "title": "mode_infos is the corresponding modes of the signers of the multisig\nwhich could include nested multisig public keys"
        }
      },
      "title": "Multi is the mode info for a multisig public key"
    },
    "cosmos.tx.v1beta1.ModeInfo.Single": {
      "type": "object",
      "properties": {
        "mode": {
          "title": "mode is the signing mode of the single signer",
          "type": "string",
          "enum": [
            "SIGN_MODE_UNSPECIFIED",
            "SIGN_MODE_DIRECT",
            "SIGN_MODE_TEXTUAL",
            "SIGN_MODE_LEGACY_AMINO_JSON"
          ],
          "default": "SIGN_MODE_UNSPECIFIED",
          "description": "SignMode represents a signing mode with its own security guarantees.\n\n - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\nrejected\n - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\nverified with raw bytes from Tx\n - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some\nhuman-readable textual representation on top of the binary representation\nfrom SIGN_MODE_DIRECT\n - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\nAmino JSON and will be removed in the future"
        }
      },
      "title": "Single is the mode info for a single signer. It is structured as a message\nto allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the\nfuture"
    },
    "cosmos.tx.v1beta1.OrderBy": {
      "type": "string",
      "enum": [
        "ORDER_BY_UNSPECIFIED",
        "ORDER_BY_ASC",
        "ORDER_BY_DESC"
      ],
      "default": "ORDER_BY_UNSPECIFIED",
      "description": "- ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.\n - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order\n - ORDER_BY_DESC: ORDER_BY_DESC defines descending order",
      "title": "OrderBy defines the sorting order"
    },
    "cosmos.tx.v1beta1.SignerInfo": {
      "type": "object",
      "properties": {
        "public_key": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        },
        "mode_info": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.ModeInfo",
          "title": "mode_info describes the signing mode of the signer and is a nested\nstructure to support nested multisig pubkey's"
        },
        "sequence": {
          "type": "string",
          "format": "uint64",
          "description": "sequence is the sequence of the account, which describes the\nnumber of committed transactions signed by a given address. It is used to\nprevent replay attacks."
        }
      },
      "description": "SignerInfo describes the public key and signing mode of a single top-level\nsigner."
    },
    "cosmos.tx.v1beta1.SimulateRequest": {
      "type": "object",
      "properties": {
        "tx": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.Tx",
          "description": "tx is the transaction to simulate.\nDeprecated. Send raw tx bytes instead."
        },
        "tx_bytes": {
          "type": "string",
          "format": "byte",
          "description": "tx_bytes is the raw transaction.\n\nSince: cosmos-sdk 0.43"
        }
      },
      "description": "SimulateRequest is the request type for the Service.Simulate\nRPC method."
    },
    "cosmos.tx.v1beta1.SimulateResponse": {
      "type": "object",
      "properties": {
        "gas_info": {
          "description": "gas_info is the information about gas used in the simulation.",
          "type": "object",
          "properties": {
            "gas_wanted": {
              "type": "string",
              "format": "uint64",
              "description": "GasWanted is the maximum units of work we allow this tx to perform."
            },
            "gas_used": {
              "type": "string",
              "format": "uint64",
              "description": "GasUsed is the amount of gas actually consumed."
            }
          }
        },
        "result": {
          "description": "result is the result of the simulation.",
          "type": "object",
          "properties": {
            "data": {
              "type": "string",
              "format": "byte",
              "description": "Data is any data returned from message or handler execution. It MUST be\nlength prefixed in order to separate data from multiple message executions."
            },
            "log": {
              "type": "string",
              "description": "Log contains the log information from message or handler execution."
            },
            "events": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type": {
                    "type": "string"
                  },
                  "attributes": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "key": {
                          "type": "string",
                          "format": "byte"
                        },
                        "value": {
                          "type": "string",
                          "format": "byte"
                        },
                        "index": {
                          "type": "boolean",
                          "format": "boolean"
                        }
                      },
                      "description": "EventAttribute is a single key-value pair, associated with an event."
                    }
                  }
                },
                "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events."
              },
              "description": "Events contains a slice of Event objects that were emitted during message\nor handler execution."
            }
          }
        }
      },
      "description": "SimulateResponse is the response type for the\nService.SimulateRPC method."
    },
    "cosmos.tx.v1beta1.Tx": {
      "type": "object",
      "properties": {
        "body": {
          "title": "body is the processable content of the transaction",
          "type": "object",
          "properties": {
            "messages": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "description": "messages is a list of messages to be executed. The required signers of\nthose messages define the number and order of elements in AuthInfo's\nsigner_infos and Tx's signatures. Each required signer address is added to\nthe list only the first time it occurs.\nBy convention, the first required signer (usually from the first message)\nis referred to as the primary signer and pays the fee for the whole\ntransaction."
            },
            "memo": {
              "type": "string",
              "description": "memo is any arbitrary note/comment to be added to the transaction.\nWARNING: in clients, any publicly exposed text should not be called memo,\nbut should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122)."
            },
            "timeout_height": {
              "type": "string",
              "format": "uint64",
              "title": "timeout is the block height after which this transaction will not\nbe processed by the chain"
            },
            "extension_options": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "title": "extension_options are arbitrary options that can be added by chains\nwhen the default options are not sufficient. If any of these are present\nand can't be handled, the transaction will be rejected"
            },
            "non_critical_extension_options": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "title": "extension_options are arbitrary options that can be added by chains\nwhen the default options are not sufficient. If any of these are present\nand can't be handled, they will be ignored"
            }
          },
          "description": "TxBody is the body of a transaction that all signers sign over."
        },
        "auth_info": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.AuthInfo",
          "title": "auth_info is the authorization related content of the transaction,\nspecifically signers, signer modes and fee"
        },
        "signatures": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          },
          "description": "signatures is a list of signatures that matches the length and order of\nAuthInfo's signer_infos to allow connecting signature meta information like\npublic key and signing mode by position."
        }
      },
      "description": "Tx is the standard type used for broadcasting transactions."
    },
    "cosmos.tx.v1beta1.TxBody": {
      "type": "object",
      "properties": {
        "messages": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "type": "string",
                "format": "byte",
                "description": "Must be a valid serialized protocol buffer of the above specified type."
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "description": "messages is a list of messages to be executed. The required signers of\nthose messages define the number and order of elements in AuthInfo's\nsigner_infos and Tx's signatures. Each required signer address is added to\nthe list only the first time it occurs.\nBy convention, the first required signer (usually from the first message)\nis referred to as the primary signer and pays the fee for the whole\ntransaction."
        },
        "memo": {
          "type": "string",
          "description": "memo is any arbitrary note/comment to be added to the transaction.\nWARNING: in clients, any publicly exposed text should not be called memo,\nbut should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122)."
        },
        "timeout_height": {
          "type": "string",
          "format": "uint64",
          "title": "timeout is the block height after which this transaction will not\nbe processed by the chain"
        },
        "extension_options": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "type": "string",
                "format": "byte",
                "description": "Must be a valid serialized protocol buffer of the above specified type."
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "title": "extension_options are arbitrary options that can be added by chains\nwhen the default options are not sufficient. If any of these are present\nand can't be handled, the transaction will be rejected"
        },
        "non_critical_extension_options": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "type": "string",
                "format": "byte",
                "description": "Must be a valid serialized protocol buffer of the above specified type."
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "title": "extension_options are arbitrary options that can be added by chains\nwhen the default options are not sufficient. If any of these are present\nand can't be handled, they will be ignored"
        }
      },
      "description": "TxBody is the body of a transaction that all signers sign over."
    },
    "tendermint.abci.Event": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "attributes": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "key": {
                "type": "string",
                "format": "byte"
              },
              "value": {
                "type": "string",
                "format": "byte"
              },
              "index": {
                "type": "boolean",
                "format": "boolean"
              }
            },
            "description": "EventAttribute is a single key-value pair, associated with an event."
          }
        }
      },
      "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events."
    },
    "tendermint.abci.EventAttribute": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "format": "byte"
        },
        "value": {
          "type": "string",
          "format": "byte"
        },
        "index": {
          "type": "boolean",
          "format": "boolean"
        }
      },
      "description": "EventAttribute is a single key-value pair, associated with an event."
    },
    "cosmos.upgrade.v1beta1.ModuleVersion": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "name of the app module"
        },
        "version": {
          "type": "string",
          "format": "uint64",
          "title": "consensus version of the app module"
        }
      },
      "description": "ModuleVersion specifies a module and its consensus version.\n\nSince: cosmos-sdk 0.43"
    },
    "cosmos.upgrade.v1beta1.Plan": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Sets the name for the upgrade. This name will be used by the upgraded\nversion of the software to apply any special \"on-upgrade\" commands during\nthe first BeginBlock method after the upgrade is applied. It is also used\nto detect whether a software version can handle a given upgrade. If no\nupgrade handler with this name has been set in the software, it will be\nassumed that the software is out-of-date when the upgrade Time or Height is\nreached and the software will exit."
        },
        "time": {
          "type": "string",
          "format": "date-time",
          "description": "Deprecated: Time based upgrades have been deprecated. Time based upgrade logic\nhas been removed from the SDK.\nIf this field is not empty, an error will be thrown."
        },
        "height": {
          "type": "string",
          "format": "int64",
          "description": "The height at which the upgrade must be performed.\nOnly used if Time is not set."
        },
        "info": {
          "type": "string",
          "title": "Any application specific upgrade info to be included on-chain\nsuch as a git commit that validators could automatically upgrade to"
        },
        "upgraded_client_state": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        }
      },
      "description": "Plan specifies information about a planned upgrade and when it should occur."
    },
    "cosmos.upgrade.v1beta1.QueryAppliedPlanResponse": {
      "type": "object",
      "properties": {
        "height": {
          "type": "string",
          "format": "int64",
          "description": "height is the block height at which the plan was applied."
        }
      },
      "description": "QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC\nmethod."
    },
    "cosmos.upgrade.v1beta1.QueryCurrentPlanResponse": {
      "type": "object",
      "properties": {
        "plan": {
          "description": "plan is the current upgrade plan.",
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Sets the name for the upgrade. This name will be used by the upgraded\nversion of the software to apply any special \"on-upgrade\" commands during\nthe first BeginBlock method after the upgrade is applied. It is also used\nto detect whether a software version can handle a given upgrade. If no\nupgrade handler with this name has been set in the software, it will be\nassumed that the software is out-of-date when the upgrade Time or Height is\nreached and the software will exit."
            },
            "time": {
              "type": "string",
              "format": "date-time",
              "description": "Deprecated: Time based upgrades have been deprecated. Time based upgrade logic\nhas been removed from the SDK.\nIf this field is not empty, an error will be thrown."
            },
            "height": {
              "type": "string",
              "format": "int64",
              "description": "The height at which the upgrade must be performed.\nOnly used if Time is not set."
            },
            "info": {
              "type": "string",
              "title": "Any application specific upgrade info to be included on-chain\nsuch as a git commit that validators could automatically upgrade to"
            },
            "upgraded_client_state": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "type": "string",
                  "format": "byte",
                  "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            }
          }
        }
      },
      "description": "QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC\nmethod."
    },
    "cosmos.upgrade.v1beta1.QueryModuleVersionsResponse": {
      "type": "object",
      "properties": {
        "module_versions": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "name of the app module"
              },
              "version": {
                "type": "string",
                "format": "uint64",
                "title": "consensus version of the app module"
              }
            },
            "description": "ModuleVersion specifies a module and its consensus version.\n\nSince: cosmos-sdk 0.43"
          },
          "description": "module_versions is a list of module names with their consensus versions."
        }
      },
      "description": "QueryModuleVersionsResponse is the response type for the Query/ModuleVersions\nRPC method.\n\nSince: cosmos-sdk 0.43"
    },
    "cosmos.upgrade.v1beta1.QueryUpgradedConsensusStateResponse": {
      "type": "object",
      "properties": {
        "upgraded_consensus_state": {
          "type": "string",
          "format": "byte",
          "title": "Since: cosmos-sdk 0.43"
        }
      },
      "description": "QueryUpgradedConsensusStateResponse is the response type for the Query/UpgradedConsensusState\nRPC method."
    },
    "terra.tx.v1beta1.ComputeTaxRequest": {
      "type": "object",
      "properties": {
        "tx": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.Tx",
          "description": "tx is the transaction to simulate.\nDeprecated. Send raw tx bytes instead."
        },
        "tx_bytes": {
          "type": "string",
          "format": "byte",
          "description": "tx_bytes is the raw transaction."
        }
      },
      "description": "ComputeTaxRequest is the request type for the Service.ComputeTax\nRPC method."
    },
    "terra.tx.v1beta1.ComputeTaxResponse": {
      "type": "object",
      "properties": {
        "tax_amount": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          },
          "title": "amount is the amount of coins to be paid as a fee"
        }
      },
      "description": "ComputeTaxResponse is the response type for the Service.ComputeTax\nRPC method."
    },
    "terra.market.v1beta1.Params": {
      "type": "object",
      "properties": {
        "base_pool": {
          "type": "string",
          "format": "byte"
        },
        "pool_recovery_period": {
          "type": "string",
          "format": "uint64"
        },
        "min_stability_spread": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "Params defines the parameters for the market module."
    },
    "terra.market.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params defines the parameters of the module.",
          "type": "object",
          "properties": {
            "base_pool": {
              "type": "string",
              "format": "byte"
            },
            "pool_recovery_period": {
              "type": "string",
              "format": "uint64"
            },
            "min_stability_spread": {
              "type": "string",
              "format": "byte"
            }
          }
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "terra.market.v1beta1.QuerySwapResponse": {
      "type": "object",
      "properties": {
        "return_coin": {
          "description": "return_coin defines the coin returned as a result of the swap simulation.",
          "type": "object",
          "properties": {
            "denom": {
              "type": "string"
            },
            "amount": {
              "type": "string"
            }
          }
        }
      },
      "description": "QuerySwapResponse is the response type for the Query/Swap RPC method."
    },
    "terra.market.v1beta1.QueryTerraPoolDeltaResponse": {
      "type": "object",
      "properties": {
        "terra_pool_delta": {
          "type": "string",
          "format": "byte",
          "title": "terra_pool_delta defines the gap between the TerraPool and the TerraBasePool"
        }
      },
      "description": "QueryTerraPoolDeltaResponse is the response type for the Query/TerraPoolDelta RPC method."
    },
    "terra.oracle.v1beta1.AggregateExchangeRatePrevote": {
      "type": "object",
      "properties": {
        "hash": {
          "type": "string"
        },
        "voter": {
          "type": "string"
        },
        "submit_block": {
          "type": "string",
          "format": "uint64"
        }
      },
      "title": "struct for aggregate prevoting on the ExchangeRateVote.\nThe purpose of aggregate prevote is to hide vote exchange rates with hash\nwhich is formatted as hex string in SHA256(\"{salt}:{exchange rate}{denom},...,{exchange rate}{denom}:{voter}\")"
    },
    "terra.oracle.v1beta1.AggregateExchangeRateVote": {
      "type": "object",
      "properties": {
        "exchange_rate_tuples": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "exchange_rate": {
                "type": "string"
              }
            },
            "title": "ExchangeRateTuple - struct to store interpreted exchange rates data to store"
          }
        },
        "voter": {
          "type": "string"
        }
      },
      "description": "MsgAggregateExchangeRateVote - struct for voting on\nthe exchange rates of Luna denominated in various Terra assets."
    },
    "terra.oracle.v1beta1.Denom": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "tobin_tax": {
          "type": "string"
        }
      },
      "title": "Denom - the object to hold configurations of each denom"
    },
    "terra.oracle.v1beta1.ExchangeRateTuple": {
      "type": "object",
      "properties": {
        "denom": {
          "type": "string"
        },
        "exchange_rate": {
          "type": "string"
        }
      },
      "title": "ExchangeRateTuple - struct to store interpreted exchange rates data to store"
    },
    "terra.oracle.v1beta1.Params": {
      "type": "object",
      "properties": {
        "vote_period": {
          "type": "string",
          "format": "uint64"
        },
        "vote_threshold": {
          "type": "string"
        },
        "reward_band": {
          "type": "string"
        },
        "reward_distribution_window": {
          "type": "string",
          "format": "uint64"
        },
        "whitelist": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string"
              },
              "tobin_tax": {
                "type": "string"
              }
            },
            "title": "Denom - the object to hold configurations of each denom"
          }
        },
        "slash_fraction": {
          "type": "string"
        },
        "slash_window": {
          "type": "string",
          "format": "uint64"
        },
        "min_valid_per_window": {
          "type": "string"
        }
      },
      "description": "Params defines the parameters for the oracle module."
    },
    "terra.oracle.v1beta1.QueryActivesResponse": {
      "type": "object",
      "properties": {
        "actives": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "actives defines a list of the denomination which oracle prices aggreed upon."
        }
      },
      "description": "QueryActivesResponse is response type for the\nQuery/Actives RPC method."
    },
    "terra.oracle.v1beta1.QueryAggregatePrevoteResponse": {
      "type": "object",
      "properties": {
        "aggregate_prevote": {
          "type": "object",
          "properties": {
            "hash": {
              "type": "string"
            },
            "voter": {
              "type": "string"
            },
            "submit_block": {
              "type": "string",
              "format": "uint64"
            }
          },
          "title": "struct for aggregate prevoting on the ExchangeRateVote.\nThe purpose of aggregate prevote is to hide vote exchange rates with hash\nwhich is formatted as hex string in SHA256(\"{salt}:{exchange rate}{denom},...,{exchange rate}{denom}:{voter}\")"
        }
      },
      "description": "QueryAggregatePrevoteResponse is response type for the\nQuery/AggregatePrevote RPC method."
    },
    "terra.oracle.v1beta1.QueryAggregatePrevotesResponse": {
      "type": "object",
      "properties": {
        "aggregate_prevotes": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "hash": {
                "type": "string"
              },
              "voter": {
                "type": "string"
              },
              "submit_block": {
                "type": "string",
                "format": "uint64"
              }
            },
            "title": "struct for aggregate prevoting on the ExchangeRateVote.\nThe purpose of aggregate prevote is to hide vote exchange rates with hash\nwhich is formatted as hex string in SHA256(\"{salt}:{exchange rate}{denom},...,{exchange rate}{denom}:{voter}\")"
          },
          "title": "aggregate_prevotes defines all oracle aggregate prevotes submitted in the current vote period"
        }
      },
      "description": "QueryAggregatePrevotesResponse is response type for the\nQuery/AggregatePrevotes RPC method."
    },
    "terra.oracle.v1beta1.QueryAggregateVoteResponse": {
      "type": "object",
      "properties": {
        "aggregate_vote": {
          "title": "aggregate_vote defines oracle aggregate vote submitted by a validator in the current vote period",
          "type": "object",
          "properties": {
            "exchange_rate_tuples": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "exchange_rate": {
                    "type": "string"
                  }
                },
                "title": "ExchangeRateTuple - struct to store interpreted exchange rates data to store"
              }
            },
            "voter": {
              "type": "string"
            }
          },
          "description": "MsgAggregateExchangeRateVote - struct for voting on\nthe exchange rates of Luna denominated in various Terra assets."
        }
      },
      "description": "QueryAggregateVoteResponse is response type for the\nQuery/AggregateVote RPC method."
    },
    "terra.oracle.v1beta1.QueryAggregateVotesResponse": {
      "type": "object",
      "properties": {
        "aggregate_votes": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "exchange_rate_tuples": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "exchange_rate": {
                      "type": "string"
                    }
                  },
                  "title": "ExchangeRateTuple - struct to store interpreted exchange rates data to store"
                }
              },
              "voter": {
                "type": "string"
              }
            },
            "description": "MsgAggregateExchangeRateVote - struct for voting on\nthe exchange rates of Luna denominated in various Terra assets."
          },
          "title": "aggregate_votes defines all oracle aggregate votes submitted in the current vote period"
        }
      },
      "description": "QueryAggregateVotesResponse is response type for the\nQuery/AggregateVotes RPC method."
    },
    "terra.oracle.v1beta1.QueryExchangeRateResponse": {
      "type": "object",
      "properties": {
        "exchange_rate": {
          "type": "string",
          "title": "exchange_rate defines the exchange rate of Luna denominated in various Terra"
        }
      },
      "description": "QueryExchangeRateResponse is response type for the\nQuery/ExchangeRate RPC method."
    },
    "terra.oracle.v1beta1.QueryExchangeRatesResponse": {
      "type": "object",
      "properties": {
        "exchange_rates": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
          },
          "description": "exchange_rates defines a list of the exchange rate for all whitelisted denoms."
        }
      },
      "description": "QueryExchangeRatesResponse is response type for the\nQuery/ExchangeRates RPC method."
    },
    "terra.oracle.v1beta1.QueryFeederDelegationResponse": {
      "type": "object",
      "properties": {
        "feeder_addr": {
          "type": "string",
          "title": "feeder_addr defines the feeder delegation of a validator"
        }
      },
      "description": "QueryFeederDelegationResponse is response type for the\nQuery/FeederDelegation RPC method."
    },
    "terra.oracle.v1beta1.QueryMissCounterResponse": {
      "type": "object",
      "properties": {
        "miss_counter": {
          "type": "string",
          "format": "uint64",
          "title": "miss_counter defines the oracle miss counter of a validator"
        }
      },
      "description": "QueryMissCounterResponse is response type for the\nQuery/MissCounter RPC method."
    },
    "terra.oracle.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params defines the parameters of the module.",
          "type": "object",
          "properties": {
            "vote_period": {
              "type": "string",
              "format": "uint64"
            },
            "vote_threshold": {
              "type": "string"
            },
            "reward_band": {
              "type": "string"
            },
            "reward_distribution_window": {
              "type": "string",
              "format": "uint64"
            },
            "whitelist": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string"
                  },
                  "tobin_tax": {
                    "type": "string"
                  }
                },
                "title": "Denom - the object to hold configurations of each denom"
              }
            },
            "slash_fraction": {
              "type": "string"
            },
            "slash_window": {
              "type": "string",
              "format": "uint64"
            },
            "min_valid_per_window": {
              "type": "string"
            }
          }
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "terra.oracle.v1beta1.QueryTobinTaxResponse": {
      "type": "object",
      "properties": {
        "tobin_tax": {
          "type": "string",
          "title": "tobin_taxe defines the tobin tax of a denom"
        }
      },
      "description": "QueryTobinTaxResponse is response type for the\nQuery/TobinTax RPC method."
    },
    "terra.oracle.v1beta1.QueryTobinTaxesResponse": {
      "type": "object",
      "properties": {
        "tobin_taxes": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string"
              },
              "tobin_tax": {
                "type": "string"
              }
            },
            "title": "Denom - the object to hold configurations of each denom"
          },
          "title": "tobin_taxes defines a list of the tobin tax of all whitelisted denoms"
        }
      },
      "description": "QueryTobinTaxesResponse is response type for the\nQuery/TobinTaxes RPC method."
    },
    "terra.oracle.v1beta1.QueryVoteTargetsResponse": {
      "type": "object",
      "properties": {
        "vote_targets": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "vote_targets defines a list of the denomination in which everyone\nshould vote in the current vote period."
        }
      },
      "description": "QueryVoteTargetsResponse is response type for the\nQuery/VoteTargets RPC method."
    },
    "terra.treasury.v1beta1.Params": {
      "type": "object",
      "properties": {
        "tax_policy": {
          "type": "object",
          "properties": {
            "rate_min": {
              "type": "string"
            },
            "rate_max": {
              "type": "string"
            },
            "cap": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
            },
            "change_rate_max": {
              "type": "string"
            }
          },
          "title": "PolicyConstraints - defines policy constraints can be applied in tax & reward policies"
        },
        "reward_policy": {
          "type": "object",
          "properties": {
            "rate_min": {
              "type": "string"
            },
            "rate_max": {
              "type": "string"
            },
            "cap": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
            },
            "change_rate_max": {
              "type": "string"
            }
          },
          "title": "PolicyConstraints - defines policy constraints can be applied in tax & reward policies"
        },
        "seigniorage_burden_target": {
          "type": "string"
        },
        "mining_increment": {
          "type": "string"
        },
        "window_short": {
          "type": "string",
          "format": "uint64"
        },
        "window_long": {
          "type": "string",
          "format": "uint64"
        },
        "window_probation": {
          "type": "string",
          "format": "uint64"
        }
      },
      "description": "Params defines the parameters for the oracle module."
    },
    "terra.treasury.v1beta1.PolicyConstraints": {
      "type": "object",
      "properties": {
        "rate_min": {
          "type": "string"
        },
        "rate_max": {
          "type": "string"
        },
        "cap": {
          "type": "object",
          "properties": {
            "denom": {
              "type": "string"
            },
            "amount": {
              "type": "string"
            }
          },
          "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
        },
        "change_rate_max": {
          "type": "string"
        }
      },
      "title": "PolicyConstraints - defines policy constraints can be applied in tax & reward policies"
    },
    "terra.treasury.v1beta1.QueryIndicatorsResponse": {
      "type": "object",
      "properties": {
        "trl_year": {
          "type": "string"
        },
        "trl_month": {
          "type": "string"
        }
      },
      "description": "QueryIndicatorsResponse is response type for the\nQuery/Indicators RPC method."
    },
    "terra.treasury.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params defines the parameters of the module.",
          "type": "object",
          "properties": {
            "tax_policy": {
              "type": "object",
              "properties": {
                "rate_min": {
                  "type": "string"
                },
                "rate_max": {
                  "type": "string"
                },
                "cap": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                },
                "change_rate_max": {
                  "type": "string"
                }
              },
              "title": "PolicyConstraints - defines policy constraints can be applied in tax & reward policies"
            },
            "reward_policy": {
              "type": "object",
              "properties": {
                "rate_min": {
                  "type": "string"
                },
                "rate_max": {
                  "type": "string"
                },
                "cap": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                },
                "change_rate_max": {
                  "type": "string"
                }
              },
              "title": "PolicyConstraints - defines policy constraints can be applied in tax & reward policies"
            },
            "seigniorage_burden_target": {
              "type": "string"
            },
            "mining_increment": {
              "type": "string"
            },
            "window_short": {
              "type": "string",
              "format": "uint64"
            },
            "window_long": {
              "type": "string",
              "format": "uint64"
            },
            "window_probation": {
              "type": "string",
              "format": "uint64"
            }
          }
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "terra.treasury.v1beta1.QueryRewardWeightResponse": {
      "type": "object",
      "properties": {
        "reward_weight": {
          "type": "string"
        }
      },
      "description": "QueryRewardWeightResponse is response type for the\nQuery/RewardWeight RPC method."
    },
    "terra.treasury.v1beta1.QuerySeigniorageProceedsResponse": {
      "type": "object",
      "properties": {
        "seigniorage_proceeds": {
          "type": "string"
        }
      },
      "description": "QuerySeigniorageProceedsResponse is response type for the\nQuery/SeigniorageProceeds RPC method."
    },
    "terra.treasury.v1beta1.QueryTaxCapResponse": {
      "type": "object",
      "properties": {
        "tax_cap": {
          "type": "string"
        }
      },
      "description": "QueryTaxCapResponse is response type for the\nQuery/TaxCap RPC method."
    },
    "terra.treasury.v1beta1.QueryTaxCapsResponse": {
      "type": "object",
      "properties": {
        "tax_caps": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "tax_cap": {
                "type": "string"
              }
            },
            "description": "QueryTaxCapsResponseItem is response item type for the\nQuery/TaxCaps RPC method."
          }
        }
      },
      "description": "QueryTaxCapsResponse is response type for the\nQuery/TaxCaps RPC method."
    },
    "terra.treasury.v1beta1.QueryTaxCapsResponseItem": {
      "type": "object",
      "properties": {
        "denom": {
          "type": "string"
        },
        "tax_cap": {
          "type": "string"
        }
      },
      "description": "QueryTaxCapsResponseItem is response item type for the\nQuery/TaxCaps RPC method."
    },
    "terra.treasury.v1beta1.QueryTaxProceedsResponse": {
      "type": "object",
      "properties": {
        "tax_proceeds": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          }
        }
      },
      "description": "QueryTaxProceedsResponse is response type for the\nQuery/TaxProceeds RPC method."
    },
    "terra.treasury.v1beta1.QueryTaxRateResponse": {
      "type": "object",
      "properties": {
        "tax_rate": {
          "type": "string"
        }
      },
      "description": "QueryTaxRateResponse is response type for the\nQuery/TaxRate RPC method."
    },
    "terra.wasm.v1beta1.CodeInfo": {
      "type": "object",
      "properties": {
        "code_id": {
          "type": "string",
          "format": "uint64",
          "title": "CodeID is the sequentially increasing unique identifier"
        },
        "code_hash": {
          "type": "string",
          "format": "byte",
          "title": "CodeHash is the unique identifier created by wasmvm"
        },
        "creator": {
          "type": "string",
          "title": "Creator address who initially stored the code"
        }
      },
      "title": "CodeInfo is data for the uploaded contract WASM code"
    },
    "terra.wasm.v1beta1.ContractInfo": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "title": "Address is the address of the contract"
        },
        "creator": {
          "type": "string",
          "title": "Creator is the contract creator address"
        },
        "admin": {
          "type": "string",
          "title": "Admin is who can execute the contract migration"
        },
        "code_id": {
          "type": "string",
          "format": "uint64",
          "title": "CodeID is the reference to the stored Wasm code"
        },
        "init_msg": {
          "type": "string",
          "format": "byte",
          "title": "InitMsg is the raw message used when instantiating a contract"
        }
      },
      "title": "ContractInfo stores a WASM contract instance"
    },
    "terra.wasm.v1beta1.Params": {
      "type": "object",
      "properties": {
        "max_contract_size": {
          "type": "string",
          "format": "uint64"
        },
        "max_contract_gas": {
          "type": "string",
          "format": "uint64"
        },
        "max_contract_msg_size": {
          "type": "string",
          "format": "uint64"
        }
      },
      "description": "Params defines the parameters for the wasm module."
    },
    "terra.wasm.v1beta1.QueryByteCodeResponse": {
      "type": "object",
      "properties": {
        "byte_code": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "QueryByteCodeResponse is response type for the\nQueryyByteCode RPC method."
    },
    "terra.wasm.v1beta1.QueryCodeInfoResponse": {
      "type": "object",
      "properties": {
        "code_info": {
          "type": "object",
          "properties": {
            "code_id": {
              "type": "string",
              "format": "uint64",
              "title": "CodeID is the sequentially increasing unique identifier"
            },
            "code_hash": {
              "type": "string",
              "format": "byte",
              "title": "CodeHash is the unique identifier created by wasmvm"
            },
            "creator": {
              "type": "string",
              "title": "Creator address who initially stored the code"
            }
          },
          "title": "CodeInfo is data for the uploaded contract WASM code"
        }
      },
      "description": "QueryCodeInfoResponse is response type for the\nQueryyCodeInfo RPC method."
    },
    "terra.wasm.v1beta1.QueryContractInfoResponse": {
      "type": "object",
      "properties": {
        "contract_info": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "title": "Address is the address of the contract"
            },
            "creator": {
              "type": "string",
              "title": "Creator is the contract creator address"
            },
            "admin": {
              "type": "string",
              "title": "Admin is who can execute the contract migration"
            },
            "code_id": {
              "type": "string",
              "format": "uint64",
              "title": "CodeID is the reference to the stored Wasm code"
            },
            "init_msg": {
              "type": "string",
              "format": "byte",
              "title": "InitMsg is the raw message used when instantiating a contract"
            }
          },
          "title": "ContractInfo stores a WASM contract instance"
        }
      },
      "description": "QueryContractInfoResponse is response type for the\nQuery/ContractInfo RPC method."
    },
    "terra.wasm.v1beta1.QueryContractStoreResponse": {
      "type": "object",
      "properties": {
        "query_result": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "QueryContractStoreResponse is response type for the\nQuery/ContractStore RPC method."
    },
    "terra.wasm.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params defines the parameters of the module.",
          "type": "object",
          "properties": {
            "max_contract_size": {
              "type": "string",
              "format": "uint64"
            },
            "max_contract_gas": {
              "type": "string",
              "format": "uint64"
            },
            "max_contract_msg_size": {
              "type": "string",
              "format": "uint64"
            }
          }
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "terra.wasm.v1beta1.QueryRawStoreResponse": {
      "type": "object",
      "properties": {
        "data": {
          "type": "string",
          "format": "byte",
          "title": "Data contains the raw store data"
        }
      },
      "description": "QueryRawStoreResponse is response type for the\nQuery/RawStore RPC method."
    },
    "ibc.core.channel.v1.Channel": {
      "type": "object",
      "properties": {
        "state": {
          "title": "current state of the channel end",
          "type": "string",
          "enum": [
            "STATE_UNINITIALIZED_UNSPECIFIED",
            "STATE_INIT",
            "STATE_TRYOPEN",
            "STATE_OPEN",
            "STATE_CLOSED"
          ],
          "default": "STATE_UNINITIALIZED_UNSPECIFIED",
          "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
        },
        "ordering": {
          "title": "whether the channel is ordered or unordered",
          "type": "string",
          "enum": [
            "ORDER_NONE_UNSPECIFIED",
            "ORDER_UNORDERED",
            "ORDER_ORDERED"
          ],
          "default": "ORDER_NONE_UNSPECIFIED",
          "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
        },
        "counterparty": {
          "title": "counterparty channel end",
          "type": "object",
          "properties": {
            "port_id": {
              "type": "string",
              "description": "port on the counterparty chain which owns the other end of the channel."
            },
            "channel_id": {
              "type": "string",
              "title": "channel end on the counterparty chain"
            }
          }
        },
        "connection_hops": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel"
        },
        "version": {
          "type": "string",
          "title": "opaque channel version, which is agreed upon during the handshake"
        }
      },
      "description": "Channel defines pipeline for exactly-once packet delivery between specific\nmodules on separate blockchains, which has at least one end capable of\nsending packets and one end capable of receiving packets."
    },
    "ibc.core.channel.v1.Counterparty": {
      "type": "object",
      "properties": {
        "port_id": {
          "type": "string",
          "description": "port on the counterparty chain which owns the other end of the channel."
        },
        "channel_id": {
          "type": "string",
          "title": "channel end on the counterparty chain"
        }
      },
      "title": "Counterparty defines a channel end counterparty"
    },
    "ibc.core.channel.v1.IdentifiedChannel": {
      "type": "object",
      "properties": {
        "state": {
          "title": "current state of the channel end",
          "type": "string",
          "enum": [
            "STATE_UNINITIALIZED_UNSPECIFIED",
            "STATE_INIT",
            "STATE_TRYOPEN",
            "STATE_OPEN",
            "STATE_CLOSED"
          ],
          "default": "STATE_UNINITIALIZED_UNSPECIFIED",
          "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
        },
        "ordering": {
          "title": "whether the channel is ordered or unordered",
          "type": "string",
          "enum": [
            "ORDER_NONE_UNSPECIFIED",
            "ORDER_UNORDERED",
            "ORDER_ORDERED"
          ],
          "default": "ORDER_NONE_UNSPECIFIED",
          "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
        },
        "counterparty": {
          "title": "counterparty channel end",
          "type": "object",
          "properties": {
            "port_id": {
              "type": "string",
              "description": "port on the counterparty chain which owns the other end of the channel."
            },
            "channel_id": {
              "type": "string",
              "title": "channel end on the counterparty chain"
            }
          }
        },
        "connection_hops": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel"
        },
        "version": {
          "type": "string",
          "title": "opaque channel version, which is agreed upon during the handshake"
        },
        "port_id": {
          "type": "string",
          "title": "port identifier"
        },
        "channel_id": {
          "type": "string",
          "title": "channel identifier"
        }
      },
      "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields."
    },
    "ibc.core.channel.v1.Order": {
      "type": "string",
      "enum": [
        "ORDER_NONE_UNSPECIFIED",
        "ORDER_UNORDERED",
        "ORDER_ORDERED"
      ],
      "default": "ORDER_NONE_UNSPECIFIED",
      "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent",
      "title": "Order defines if a channel is ORDERED or UNORDERED"
    },
    "ibc.core.channel.v1.PacketState": {
      "type": "object",
      "properties": {
        "port_id": {
          "type": "string",
          "description": "channel port identifier."
        },
        "channel_id": {
          "type": "string",
          "description": "channel unique identifier."
        },
        "sequence": {
          "type": "string",
          "format": "uint64",
          "description": "packet sequence."
        },
        "data": {
          "type": "string",
          "format": "byte",
          "description": "embedded data that represents packet state."
        }
      },
      "description": "PacketState defines the generic type necessary to retrieve and store\npacket commitments, acknowledgements, and receipts.\nCaller is responsible for knowing the context necessary to interpret this\nstate as a commitment, acknowledgement, or a receipt."
    },
    "ibc.core.channel.v1.QueryChannelClientStateResponse": {
      "type": "object",
      "properties": {
        "identified_client_state": {
          "title": "client state associated with the channel",
          "type": "object",
          "properties": {
            "client_id": {
              "type": "string",
              "title": "client identifier"
            },
            "client_state": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "type": "string",
                  "format": "byte",
                  "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
              "title": "client state"
            }
          },
          "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field."
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryChannelClientStateResponse is the Response type for the\nQuery/QueryChannelClientState RPC method"
    },
    "ibc.core.channel.v1.QueryChannelConsensusStateResponse": {
      "type": "object",
      "properties": {
        "consensus_state": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
          "title": "consensus state associated with the channel"
        },
        "client_id": {
          "type": "string",
          "title": "client ID associated with the consensus state"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryChannelClientStateResponse is the Response type for the\nQuery/QueryChannelClientState RPC method"
    },
    "ibc.core.channel.v1.QueryChannelResponse": {
      "type": "object",
      "properties": {
        "channel": {
          "title": "channel associated with the request identifiers",
          "type": "object",
          "properties": {
            "state": {
              "title": "current state of the channel end",
              "type": "string",
              "enum": [
                "STATE_UNINITIALIZED_UNSPECIFIED",
                "STATE_INIT",
                "STATE_TRYOPEN",
                "STATE_OPEN",
                "STATE_CLOSED"
              ],
              "default": "STATE_UNINITIALIZED_UNSPECIFIED",
              "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
            },
            "ordering": {
              "title": "whether the channel is ordered or unordered",
              "type": "string",
              "enum": [
                "ORDER_NONE_UNSPECIFIED",
                "ORDER_UNORDERED",
                "ORDER_ORDERED"
              ],
              "default": "ORDER_NONE_UNSPECIFIED",
              "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
            },
            "counterparty": {
              "title": "counterparty channel end",
              "type": "object",
              "properties": {
                "port_id": {
                  "type": "string",
                  "description": "port on the counterparty chain which owns the other end of the channel."
                },
                "channel_id": {
                  "type": "string",
                  "title": "channel end on the counterparty chain"
                }
              }
            },
            "connection_hops": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel"
            },
            "version": {
              "type": "string",
              "title": "opaque channel version, which is agreed upon during the handshake"
            }
          },
          "description": "Channel defines pipeline for exactly-once packet delivery between specific\nmodules on separate blockchains, which has at least one end capable of\nsending packets and one end capable of receiving packets."
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "description": "QueryChannelResponse is the response type for the Query/Channel RPC method.\nBesides the Channel end, it includes a proof and the height from which the\nproof was retrieved."
    },
    "ibc.core.channel.v1.QueryChannelsResponse": {
      "type": "object",
      "properties": {
        "channels": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "state": {
                "title": "current state of the channel end",
                "type": "string",
                "enum": [
                  "STATE_UNINITIALIZED_UNSPECIFIED",
                  "STATE_INIT",
                  "STATE_TRYOPEN",
                  "STATE_OPEN",
                  "STATE_CLOSED"
                ],
                "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
              },
              "ordering": {
                "title": "whether the channel is ordered or unordered",
                "type": "string",
                "enum": [
                  "ORDER_NONE_UNSPECIFIED",
                  "ORDER_UNORDERED",
                  "ORDER_ORDERED"
                ],
                "default": "ORDER_NONE_UNSPECIFIED",
                "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
              },
              "counterparty": {
                "title": "counterparty channel end",
                "type": "object",
                "properties": {
                  "port_id": {
                    "type": "string",
                    "description": "port on the counterparty chain which owns the other end of the channel."
                  },
                  "channel_id": {
                    "type": "string",
                    "title": "channel end on the counterparty chain"
                  }
                }
              },
              "connection_hops": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel"
              },
              "version": {
                "type": "string",
                "title": "opaque channel version, which is agreed upon during the handshake"
              },
              "port_id": {
                "type": "string",
                "title": "port identifier"
              },
              "channel_id": {
                "type": "string",
                "title": "channel identifier"
              }
            },
            "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields."
          },
          "description": "list of stored channels of the chain."
        },
        "pagination": {
          "title": "pagination response",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        },
        "height": {
          "title": "query block height",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "description": "QueryChannelsResponse is the response type for the Query/Channels RPC method."
    },
    "ibc.core.channel.v1.QueryConnectionChannelsResponse": {
      "type": "object",
      "properties": {
        "channels": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "state": {
                "title": "current state of the channel end",
                "type": "string",
                "enum": [
                  "STATE_UNINITIALIZED_UNSPECIFIED",
                  "STATE_INIT",
                  "STATE_TRYOPEN",
                  "STATE_OPEN",
                  "STATE_CLOSED"
                ],
                "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
              },
              "ordering": {
                "title": "whether the channel is ordered or unordered",
                "type": "string",
                "enum": [
                  "ORDER_NONE_UNSPECIFIED",
                  "ORDER_UNORDERED",
                  "ORDER_ORDERED"
                ],
                "default": "ORDER_NONE_UNSPECIFIED",
                "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
              },
              "counterparty": {
                "title": "counterparty channel end",
                "type": "object",
                "properties": {
                  "port_id": {
                    "type": "string",
                    "description": "port on the counterparty chain which owns the other end of the channel."
                  },
                  "channel_id": {
                    "type": "string",
                    "title": "channel end on the counterparty chain"
                  }
                }
              },
              "connection_hops": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel"
              },
              "version": {
                "type": "string",
                "title": "opaque channel version, which is agreed upon during the handshake"
              },
              "port_id": {
                "type": "string",
                "title": "port identifier"
              },
              "channel_id": {
                "type": "string",
                "title": "channel identifier"
              }
            },
            "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields."
          },
          "description": "list of channels associated with a connection."
        },
        "pagination": {
          "title": "pagination response",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        },
        "height": {
          "title": "query block height",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryConnectionChannelsResponse is the Response type for the\nQuery/QueryConnectionChannels RPC method"
    },
    "ibc.core.channel.v1.QueryNextSequenceReceiveResponse": {
      "type": "object",
      "properties": {
        "next_sequence_receive": {
          "type": "string",
          "format": "uint64",
          "title": "next sequence receive number"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QuerySequenceResponse is the request type for the\nQuery/QueryNextSequenceReceiveResponse RPC method"
    },
    "ibc.core.channel.v1.QueryPacketAcknowledgementResponse": {
      "type": "object",
      "properties": {
        "acknowledgement": {
          "type": "string",
          "format": "byte",
          "title": "packet associated with the request fields"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryPacketAcknowledgementResponse defines the client query response for a\npacket which also includes a proof and the height from which the\nproof was retrieved"
    },
    "ibc.core.channel.v1.QueryPacketAcknowledgementsResponse": {
      "type": "object",
      "properties": {
        "acknowledgements": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "port_id": {
                "type": "string",
                "description": "channel port identifier."
              },
              "channel_id": {
                "type": "string",
                "description": "channel unique identifier."
              },
              "sequence": {
                "type": "string",
                "format": "uint64",
                "description": "packet sequence."
              },
              "data": {
                "type": "string",
                "format": "byte",
                "description": "embedded data that represents packet state."
              }
            },
            "description": "PacketState defines the generic type necessary to retrieve and store\npacket commitments, acknowledgements, and receipts.\nCaller is responsible for knowing the context necessary to interpret this\nstate as a commitment, acknowledgement, or a receipt."
          }
        },
        "pagination": {
          "title": "pagination response",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        },
        "height": {
          "title": "query block height",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryPacketAcknowledgemetsResponse is the request type for the\nQuery/QueryPacketAcknowledgements RPC method"
    },
    "ibc.core.channel.v1.QueryPacketCommitmentResponse": {
      "type": "object",
      "properties": {
        "commitment": {
          "type": "string",
          "format": "byte",
          "title": "packet associated with the request fields"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryPacketCommitmentResponse defines the client query response for a packet\nwhich also includes a proof and the height from which the proof was\nretrieved"
    },
    "ibc.core.channel.v1.QueryPacketCommitmentsResponse": {
      "type": "object",
      "properties": {
        "commitments": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "port_id": {
                "type": "string",
                "description": "channel port identifier."
              },
              "channel_id": {
                "type": "string",
                "description": "channel unique identifier."
              },
              "sequence": {
                "type": "string",
                "format": "uint64",
                "description": "packet sequence."
              },
              "data": {
                "type": "string",
                "format": "byte",
                "description": "embedded data that represents packet state."
              }
            },
            "description": "PacketState defines the generic type necessary to retrieve and store\npacket commitments, acknowledgements, and receipts.\nCaller is responsible for knowing the context necessary to interpret this\nstate as a commitment, acknowledgement, or a receipt."
          }
        },
        "pagination": {
          "title": "pagination response",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        },
        "height": {
          "title": "query block height",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryPacketCommitmentsResponse is the request type for the\nQuery/QueryPacketCommitments RPC method"
    },
    "ibc.core.channel.v1.QueryPacketReceiptResponse": {
      "type": "object",
      "properties": {
        "received": {
          "type": "boolean",
          "format": "boolean",
          "title": "success flag for if receipt exists"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryPacketReceiptResponse defines the client query response for a packet\nreceipt which also includes a proof, and the height from which the proof was\nretrieved"
    },
    "ibc.core.channel.v1.QueryUnreceivedAcksResponse": {
      "type": "object",
      "properties": {
        "sequences": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uint64"
          },
          "title": "list of unreceived acknowledgement sequences"
        },
        "height": {
          "title": "query block height",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryUnreceivedAcksResponse is the response type for the\nQuery/UnreceivedAcks RPC method"
    },
    "ibc.core.channel.v1.QueryUnreceivedPacketsResponse": {
      "type": "object",
      "properties": {
        "sequences": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uint64"
          },
          "title": "list of unreceived packet sequences"
        },
        "height": {
          "title": "query block height",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryUnreceivedPacketsResponse is the response type for the\nQuery/UnreceivedPacketCommitments RPC method"
    },
    "ibc.core.channel.v1.State": {
      "type": "string",
      "enum": [
        "STATE_UNINITIALIZED_UNSPECIFIED",
        "STATE_INIT",
        "STATE_TRYOPEN",
        "STATE_OPEN",
        "STATE_CLOSED"
      ],
      "default": "STATE_UNINITIALIZED_UNSPECIFIED",
      "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
    },
    "ibc.core.client.v1.Height": {
      "type": "object",
      "properties": {
        "revision_number": {
          "type": "string",
          "format": "uint64",
          "title": "the revision that the client is currently on"
        },
        "revision_height": {
          "type": "string",
          "format": "uint64",
          "title": "the height within the given revision"
        }
      },
      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset",
      "title": "Height is a monotonically increasing data type\nthat can be compared against another Height for the purposes of updating and\nfreezing clients"
    },
    "ibc.core.client.v1.IdentifiedClientState": {
      "type": "object",
      "properties": {
        "client_id": {
          "type": "string",
          "title": "client identifier"
        },
        "client_state": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
          "title": "client state"
        }
      },
      "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field."
    },
    "ibc.core.client.v1.ConsensusStateWithHeight": {
      "type": "object",
      "properties": {
        "height": {
          "title": "consensus state height",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        },
        "consensus_state": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
          "title": "consensus state"
        }
      },
      "description": "ConsensusStateWithHeight defines a consensus state with an additional height\nfield."
    },
    "ibc.core.client.v1.Params": {
      "type": "object",
      "properties": {
        "allowed_clients": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "allowed_clients defines the list of allowed client state types."
        }
      },
      "description": "Params defines the set of IBC light client parameters."
    },
    "ibc.core.client.v1.QueryClientParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params defines the parameters of the module.",
          "type": "object",
          "properties": {
            "allowed_clients": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "allowed_clients defines the list of allowed client state types."
            }
          }
        }
      },
      "description": "QueryClientParamsResponse is the response type for the Query/ClientParams RPC\nmethod."
    },
    "ibc.core.client.v1.QueryClientStateResponse": {
      "type": "object",
      "properties": {
        "client_state": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
          "title": "client state associated with the request identifier"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "description": "QueryClientStateResponse is the response type for the Query/ClientState RPC\nmethod. Besides the client state, it includes a proof and the height from\nwhich the proof was retrieved."
    },
    "ibc.core.client.v1.QueryClientStatesResponse": {
      "type": "object",
      "properties": {
        "client_states": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "client_id": {
                "type": "string",
                "title": "client identifier"
              },
              "client_state": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                "title": "client state"
              }
            },
            "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field."
          },
          "description": "list of stored ClientStates of the chain."
        },
        "pagination": {
          "title": "pagination response",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        }
      },
      "description": "QueryClientStatesResponse is the response type for the Query/ClientStates RPC\nmethod."
    },
    "ibc.core.client.v1.QueryClientStatusResponse": {
      "type": "object",
      "properties": {
        "status": {
          "type": "string"
        }
      },
      "description": "QueryClientStatusResponse is the response type for the Query/ClientStatus RPC\nmethod. It returns the current status of the IBC client."
    },
    "ibc.core.client.v1.QueryConsensusStateResponse": {
      "type": "object",
      "properties": {
        "consensus_state": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
          "title": "consensus state associated with the client identifier at the given height"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryConsensusStateResponse is the response type for the Query/ConsensusState\nRPC method"
    },
    "ibc.core.client.v1.QueryConsensusStatesResponse": {
      "type": "object",
      "properties": {
        "consensus_states": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "height": {
                "title": "consensus state height",
                "type": "object",
                "properties": {
                  "revision_number": {
                    "type": "string",
                    "format": "uint64",
                    "title": "the revision that the client is currently on"
                  },
                  "revision_height": {
                    "type": "string",
                    "format": "uint64",
                    "title": "the height within the given revision"
                  }
                },
                "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
              },
              "consensus_state": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                "title": "consensus state"
              }
            },
            "description": "ConsensusStateWithHeight defines a consensus state with an additional height\nfield."
          },
          "title": "consensus states associated with the identifier"
        },
        "pagination": {
          "title": "pagination response",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        }
      },
      "title": "QueryConsensusStatesResponse is the response type for the\nQuery/ConsensusStates RPC method"
    },
    "ibc.core.client.v1.QueryUpgradedClientStateResponse": {
      "type": "object",
      "properties": {
        "upgraded_client_state": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
          "title": "client state associated with the request identifier"
        }
      },
      "description": "QueryUpgradedClientStateResponse is the response type for the\nQuery/UpgradedClientState RPC method."
    },
    "ibc.core.client.v1.QueryUpgradedConsensusStateResponse": {
      "type": "object",
      "properties": {
        "upgraded_consensus_state": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
          "title": "Consensus state associated with the request identifier"
        }
      },
      "description": "QueryUpgradedConsensusStateResponse is the response type for the\nQuery/UpgradedConsensusState RPC method."
    },
    "ibc.core.commitment.v1.MerklePrefix": {
      "type": "object",
      "properties": {
        "key_prefix": {
          "type": "string",
          "format": "byte"
        }
      },
      "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))"
    },
    "ibc.core.connection.v1.ConnectionEnd": {
      "type": "object",
      "properties": {
        "client_id": {
          "type": "string",
          "description": "client associated with this connection."
        },
        "versions": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "identifier": {
                "type": "string",
                "title": "unique version identifier"
              },
              "features": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "list of features compatible with the specified identifier"
              }
            },
            "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake."
          },
          "description": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection."
        },
        "state": {
          "description": "current state of the connection end.",
          "type": "string",
          "enum": [
            "STATE_UNINITIALIZED_UNSPECIFIED",
            "STATE_INIT",
            "STATE_TRYOPEN",
            "STATE_OPEN"
          ],
          "default": "STATE_UNINITIALIZED_UNSPECIFIED"
        },
        "counterparty": {
          "description": "counterparty chain associated with this connection.",
          "type": "object",
          "properties": {
            "client_id": {
              "type": "string",
              "description": "identifies the client on the counterparty chain associated with a given\nconnection."
            },
            "connection_id": {
              "type": "string",
              "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
            },
            "prefix": {
              "description": "commitment merkle prefix of the counterparty chain.",
              "type": "object",
              "properties": {
                "key_prefix": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))"
            }
          }
        },
        "delay_period": {
          "type": "string",
          "format": "uint64",
          "description": "delay period that must pass before a consensus state can be used for\npacket-verification NOTE: delay period logic is only implemented by some\nclients."
        }
      },
      "description": "ConnectionEnd defines a stateful object on a chain connected to another\nseparate one.\nNOTE: there must only be 2 defined ConnectionEnds to establish\na connection between two chains."
    },
    "ibc.core.connection.v1.Counterparty": {
      "type": "object",
      "properties": {
        "client_id": {
          "type": "string",
          "description": "identifies the client on the counterparty chain associated with a given\nconnection."
        },
        "connection_id": {
          "type": "string",
          "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
        },
        "prefix": {
          "description": "commitment merkle prefix of the counterparty chain.",
          "type": "object",
          "properties": {
            "key_prefix": {
              "type": "string",
              "format": "byte"
            }
          },
          "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))"
        }
      },
      "description": "Counterparty defines the counterparty chain associated with a connection end."
    },
    "ibc.core.connection.v1.IdentifiedConnection": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "connection identifier."
        },
        "client_id": {
          "type": "string",
          "description": "client associated with this connection."
        },
        "versions": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "identifier": {
                "type": "string",
                "title": "unique version identifier"
              },
              "features": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "list of features compatible with the specified identifier"
              }
            },
            "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake."
          },
          "title": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection"
        },
        "state": {
          "description": "current state of the connection end.",
          "type": "string",
          "enum": [
            "STATE_UNINITIALIZED_UNSPECIFIED",
            "STATE_INIT",
            "STATE_TRYOPEN",
            "STATE_OPEN"
          ],
          "default": "STATE_UNINITIALIZED_UNSPECIFIED"
        },
        "counterparty": {
          "description": "counterparty chain associated with this connection.",
          "type": "object",
          "properties": {
            "client_id": {
              "type": "string",
              "description": "identifies the client on the counterparty chain associated with a given\nconnection."
            },
            "connection_id": {
              "type": "string",
              "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
            },
            "prefix": {
              "description": "commitment merkle prefix of the counterparty chain.",
              "type": "object",
              "properties": {
                "key_prefix": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))"
            }
          }
        },
        "delay_period": {
          "type": "string",
          "format": "uint64",
          "description": "delay period associated with this connection."
        }
      },
      "description": "IdentifiedConnection defines a connection with additional connection\nidentifier field."
    },
    "ibc.core.connection.v1.QueryClientConnectionsResponse": {
      "type": "object",
      "properties": {
        "connection_paths": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "slice of all the connection paths associated with a client."
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was generated",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryClientConnectionsResponse is the response type for the\nQuery/ClientConnections RPC method"
    },
    "ibc.core.connection.v1.QueryConnectionClientStateResponse": {
      "type": "object",
      "properties": {
        "identified_client_state": {
          "title": "client state associated with the channel",
          "type": "object",
          "properties": {
            "client_id": {
              "type": "string",
              "title": "client identifier"
            },
            "client_state": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "type": "string",
                  "format": "byte",
                  "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
              "title": "client state"
            }
          },
          "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field."
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryConnectionClientStateResponse is the response type for the\nQuery/ConnectionClientState RPC method"
    },
    "ibc.core.connection.v1.QueryConnectionConsensusStateResponse": {
      "type": "object",
      "properties": {
        "consensus_state": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
          "title": "consensus state associated with the channel"
        },
        "client_id": {
          "type": "string",
          "title": "client ID associated with the consensus state"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryConnectionConsensusStateResponse is the response type for the\nQuery/ConnectionConsensusState RPC method"
    },
    "ibc.core.connection.v1.QueryConnectionResponse": {
      "type": "object",
      "properties": {
        "connection": {
          "title": "connection associated with the request identifier",
          "type": "object",
          "properties": {
            "client_id": {
              "type": "string",
              "description": "client associated with this connection."
            },
            "versions": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "identifier": {
                    "type": "string",
                    "title": "unique version identifier"
                  },
                  "features": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "title": "list of features compatible with the specified identifier"
                  }
                },
                "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake."
              },
              "description": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection."
            },
            "state": {
              "description": "current state of the connection end.",
              "type": "string",
              "enum": [
                "STATE_UNINITIALIZED_UNSPECIFIED",
                "STATE_INIT",
                "STATE_TRYOPEN",
                "STATE_OPEN"
              ],
              "default": "STATE_UNINITIALIZED_UNSPECIFIED"
            },
            "counterparty": {
              "description": "counterparty chain associated with this connection.",
              "type": "object",
              "properties": {
                "client_id": {
                  "type": "string",
                  "description": "identifies the client on the counterparty chain associated with a given\nconnection."
                },
                "connection_id": {
                  "type": "string",
                  "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
                },
                "prefix": {
                  "description": "commitment merkle prefix of the counterparty chain.",
                  "type": "object",
                  "properties": {
                    "key_prefix": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))"
                }
              }
            },
            "delay_period": {
              "type": "string",
              "format": "uint64",
              "description": "delay period that must pass before a consensus state can be used for\npacket-verification NOTE: delay period logic is only implemented by some\nclients."
            }
          },
          "description": "ConnectionEnd defines a stateful object on a chain connected to another\nseparate one.\nNOTE: there must only be 2 defined ConnectionEnds to establish\na connection between two chains."
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "description": "QueryConnectionResponse is the response type for the Query/Connection RPC\nmethod. Besides the connection end, it includes a proof and the height from\nwhich the proof was retrieved."
    },
    "ibc.core.connection.v1.QueryConnectionsResponse": {
      "type": "object",
      "properties": {
        "connections": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "description": "connection identifier."
              },
              "client_id": {
                "type": "string",
                "description": "client associated with this connection."
              },
              "versions": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "identifier": {
                      "type": "string",
                      "title": "unique version identifier"
                    },
                    "features": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "title": "list of features compatible with the specified identifier"
                    }
                  },
                  "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake."
                },
                "title": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection"
              },
              "state": {
                "description": "current state of the connection end.",
                "type": "string",
                "enum": [
                  "STATE_UNINITIALIZED_UNSPECIFIED",
                  "STATE_INIT",
                  "STATE_TRYOPEN",
                  "STATE_OPEN"
                ],
                "default": "STATE_UNINITIALIZED_UNSPECIFIED"
              },
              "counterparty": {
                "description": "counterparty chain associated with this connection.",
                "type": "object",
                "properties": {
                  "client_id": {
                    "type": "string",
                    "description": "identifies the client on the counterparty chain associated with a given\nconnection."
                  },
                  "connection_id": {
                    "type": "string",
                    "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
                  },
                  "prefix": {
                    "description": "commitment merkle prefix of the counterparty chain.",
                    "type": "object",
                    "properties": {
                      "key_prefix": {
                        "type": "string",
                        "format": "byte"
                      }
                    },
                    "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))"
                  }
                }
              },
              "delay_period": {
                "type": "string",
                "format": "uint64",
                "description": "delay period associated with this connection."
              }
            },
            "description": "IdentifiedConnection defines a connection with additional connection\nidentifier field."
          },
          "description": "list of stored connections of the chain."
        },
        "pagination": {
          "title": "pagination response",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        },
        "height": {
          "title": "query block height",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "description": "QueryConnectionsResponse is the response type for the Query/Connections RPC\nmethod."
    },
    "ibc.core.connection.v1.State": {
      "type": "string",
      "enum": [
        "STATE_UNINITIALIZED_UNSPECIFIED",
        "STATE_INIT",
        "STATE_TRYOPEN",
        "STATE_OPEN"
      ],
      "default": "STATE_UNINITIALIZED_UNSPECIFIED",
      "description": "State defines if a connection is in one of the following states:\nINIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A connection end has just started the opening handshake.\n - STATE_TRYOPEN: A connection end has acknowledged the handshake step on the counterparty\nchain.\n - STATE_OPEN: A connection end has completed the handshake."
    },
    "ibc.core.connection.v1.Version": {
      "type": "object",
      "properties": {
        "identifier": {
          "type": "string",
          "title": "unique version identifier"
        },
        "features": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "list of features compatible with the specified identifier"
        }
      },
      "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake."
    },
    "ibc.applications.transfer.v1.DenomTrace": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "path defines the chain of port/channel identifiers used for tracing the\nsource of the fungible token."
        },
        "base_denom": {
          "type": "string",
          "description": "base denomination of the relayed fungible token."
        }
      },
      "description": "DenomTrace contains the base denomination for ICS20 fungible tokens and the\nsource tracing information path."
    },
    "ibc.applications.transfer.v1.Params": {
      "type": "object",
      "properties": {
        "send_enabled": {
          "type": "boolean",
          "format": "boolean",
          "description": "send_enabled enables or disables all cross-chain token transfers from this\nchain."
        },
        "receive_enabled": {
          "type": "boolean",
          "format": "boolean",
          "description": "receive_enabled enables or disables all cross-chain token transfers to this\nchain."
        }
      },
      "description": "Params defines the set of IBC transfer parameters.\nNOTE: To prevent a single token from being transferred, set the\nTransfersEnabled parameter to true and then set the bank module's SendEnabled\nparameter for the denomination to false."
    },
    "ibc.applications.transfer.v1.QueryDenomTraceResponse": {
      "type": "object",
      "properties": {
        "denom_trace": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "path defines the chain of port/channel identifiers used for tracing the\nsource of the fungible token."
            },
            "base_denom": {
              "type": "string",
              "description": "base denomination of the relayed fungible token."
            }
          },
          "description": "DenomTrace contains the base denomination for ICS20 fungible tokens and the\nsource tracing information path."
        }
      },
      "description": "QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC\nmethod."
    },
    "ibc.applications.transfer.v1.QueryDenomTracesResponse": {
      "type": "object",
      "properties": {
        "denom_traces": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "path": {
                "type": "string",
                "description": "path defines the chain of port/channel identifiers used for tracing the\nsource of the fungible token."
              },
              "base_denom": {
                "type": "string",
                "description": "base denomination of the relayed fungible token."
              }
            },
            "description": "DenomTrace contains the base denomination for ICS20 fungible tokens and the\nsource tracing information path."
          },
          "description": "denom_traces returns all denominations trace information."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryConnectionsResponse is the response type for the Query/DenomTraces RPC\nmethod."
    },
    "ibc.applications.transfer.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params defines the parameters of the module.",
          "type": "object",
          "properties": {
            "send_enabled": {
              "type": "boolean",
              "format": "boolean",
              "description": "send_enabled enables or disables all cross-chain token transfers from this\nchain."
            },
            "receive_enabled": {
              "type": "boolean",
              "format": "boolean",
              "description": "receive_enabled enables or disables all cross-chain token transfers to this\nchain."
            }
          }
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "getBankResult": {
      "properties": {
        "balance": {
          "type": "array",
          "description": "Available balance of the User",
          "items": {
            "$ref": "#/definitions/getBankResult.balance"
          }
        },
        "vesting": {
          "type": "array",
          "description": "Vesting schedule of the User",
          "items": {
            "$ref": "#/definitions/getBankResult.vesting"
          }
        },
        "delegations": {
          "type": "array",
          "description": "Delegation informations of the User",
          "items": {
            "$ref": "#/definitions/getBankResult.delegations"
          }
        },
        "unbondings": {
          "type": "array",
          "description": "User unbonding details",
          "items": {
            "$ref": "#/definitions/getBankResult.unbondings"
          }
        }
      },
      "required": [
        "balance",
        "vesting",
        "delegations",
        "unbondings"
      ]
    },
    "getBankResult.balance": {
      "properties": {
        "denom": {
          "type": "string",
          "description": "Coin denomination"
        },
        "amount": {
          "type": "string",
          "description": "Available amount"
        },
        "delegatedVesting": {
          "type": "string",
          "description": "Delegated amount of the vesting amount"
        },
        "delegatable": {
          "type": "string",
          "description": "Delegatable amount"
        },
        "freedVesting": {
          "type": "string",
          "description": "Freed amount of the vesting amount"
        },
        "unbonding": {
          "type": "string",
          "description": "Amount in unbonding state"
        },
        "remainingVesting": {
          "type": "string",
          "description": "Amount not yet freed"
        }
      },
      "required": [
        "denom",
        "amount",
        "delegatedVesting",
        "delegatable",
        "freedVesting",
        "unbonding",
        "remainingVesting"
      ]
    },
    "getBankResult.vesting": {
      "properties": {
        "denom": {
          "type": "string",
          "description": "denom name"
        },
        "total": {
          "type": "string",
          "description": "vesting amount"
        },
        "schedules": {
          "type": "array",
          "description": "vesting schedules of user",
          "items": {
            "$ref": "#/definitions/getBankResult.vesting.schedules"
          }
        }
      },
      "required": [
        "denom",
        "total",
        "schedules"
      ]
    },
    "getBankResult.vesting.schedules": {
      "properties": {
        "amount": {
          "type": "string",
          "description": "vesting amount"
        },
        "startTime": {
          "type": "string",
          "description": "vestring start time"
        },
        "endTime": {
          "type": "string",
          "description": "vesting end time"
        },
        "ratio": {
          "type": "string",
          "description": "vesting ratio"
        }
      },
      "required": [
        "amount",
        "startTime",
        "endTime",
        "ratio"
      ]
    },
    "getBankResult.delegations": {
      "properties": {
        "delegator_address": {
          "type": "string",
          "description": "delegator address"
        },
        "validator_address": {
          "type": "string",
          "description": "validator address"
        },
        "shares": {
          "type": "string",
          "description": "delegation share"
        },
        "amount": {
          "type": "string",
          "description": "delegation amount"
        }
      },
      "required": [
        "delegator_address",
        "validator_address",
        "shares",
        "amount"
      ]
    },
    "getBankResult.unbondings": {
      "properties": {
        "delegator_address": {
          "type": "string",
          "description": "delegator address"
        },
        "validator_address": {
          "type": "string",
          "description": "validator address"
        },
        "entries": {
          "type": "array",
          "description": "details of unbondings",
          "items": {
            "$ref": "#/definitions/getBankResult.unbondings.entries"
          }
        }
      },
      "required": [
        "delegator_address",
        "validator_address",
        "entries"
      ]
    },
    "getBankResult.unbondings.entries": {
      "properties": {
        "creating_height": {
          "type": "string",
          "description": "block height"
        },
        "completion_time": {
          "type": "string",
          "description": "unbonding completion time"
        },
        "initial_balance": {
          "type": "string",
          "description": "initial balancd"
        },
        "balance": {
          "type": "string",
          "description": "current balance"
        }
      },
      "required": [
        "creating_height",
        "completion_time",
        "initial_balance",
        "balance"
      ]
    },
    "getAccountGrowthResult": {
      "properties": {
        "cumulative": {
          "type": "array",
          "description": "cumulative history data",
          "items": {
            "$ref": "#/definitions/getAccountGrowthResult.cumulative"
          }
        },
        "periodic": {
          "type": "array",
          "description": "periodic history",
          "items": {
            "$ref": "#/definitions/getAccountGrowthResult.periodic"
          }
        }
      },
      "required": [
        "cumulative",
        "periodic"
      ]
    },
    "getAccountGrowthResult.cumulative": {
      "properties": {
        "datetime": {
          "type": "number",
          "description": "unix timestamp"
        },
        "totalAccount": {
          "type": "number",
          "description": "total account"
        },
        "activeAccount": {
          "type": "number",
          "description": "active account count"
        }
      },
      "required": [
        "datetime",
        "totalAccount",
        "activeAccount"
      ]
    },
    "getAccountGrowthResult.periodic": {
      "properties": {
        "datetime": {
          "type": "number",
          "description": "unix timestamp"
        },
        "totalAccount": {
          "type": "number",
          "description": "total account on datetime"
        },
        "activeAccount": {
          "type": "number",
          "description": "active account on datetime"
        }
      },
      "required": [
        "datetime",
        "totalAccount",
        "activeAccount"
      ]
    },
    "getActiveAccountsResult": {
      "properties": {
        "total": {
          "type": "number",
          "description": "total active accounts in the time period"
        },
        "periodic": {
          "type": "array",
          "description": "daily active account info's",
          "items": {
            "$ref": "#/definitions/getActiveAccountsResult.periodic"
          }
        }
      },
      "required": [
        "total",
        "periodic"
      ]
    },
    "getActiveAccountsResult.periodic": {
      "properties": {
        "datetime": {
          "type": "number",
          "description": "unix timestamp"
        },
        "value": {
          "type": "number",
          "description": "active account count"
        }
      },
      "required": [
        "datetime",
        "value"
      ]
    },
    "getBlockRewardResult": {
      "properties": {
        "cumulative": {
          "type": "array",
          "description": "cumulative history",
          "items": {
            "$ref": "#/definitions/getBlockRewardResult.cumulative"
          }
        },
        "periodic": {
          "type": "array",
          "description": "periodic history",
          "items": {
            "$ref": "#/definitions/getBlockRewardResult.periodic"
          }
        }
      },
      "required": [
        "cumulative",
        "periodic"
      ]
    },
    "getBlockRewardResult.cumulative": {
      "properties": {
        "datetime": {
          "type": "number",
          "description": "unix timestamp"
        },
        "blockReward": {
          "type": "number",
          "description": "cumulative reward"
        }
      },
      "required": [
        "datetime",
        "blockReward"
      ]
    },
    "getBlockRewardResult.periodic": {
      "properties": {
        "datetime": {
          "type": "number",
          "description": "unix timestamp"
        },
        "blockReward": {
          "type": "number",
          "description": "periodic reward on that timestamp"
        }
      },
      "required": [
        "datetime",
        "blockReward"
      ]
    },
    "getDashboardResult": {
      "properties": {
        "prices": {
          "type": "object",
          "description": "Current oracle price",
          "$ref": "#/definitions/getDashboardResult.prices"
        },
        "taxRate": {
          "type": "string",
          "description": "Current tax rate"
        },
        "taxCaps": {
          "type": "array",
          "description": "Current tax cap",
          "items": {
            "$ref": "#/definitions/getDashboardResult.taxCaps"
          }
        },
        "issuances": {
          "type": "object",
          "description": "Total issuances of coins",
          "$ref": "#/definitions/getDashboardResult.issuances"
        },
        "stakingPool": {
          "type": "object",
          "description": "Current state of the staking pool",
          "$ref": "#/definitions/getDashboardResult.stakingPool"
        },
        "communityPool": {
          "type": "object",
          "description": "Current state of the community pool",
          "$ref": "#/definitions/getDashboardResult.communityPool"
        }
      },
      "required": [
        "prices",
        "taxRate",
        "taxCaps",
        "issuances",
        "stakingPool",
        "communityPool"
      ]
    },
    "getDashboardResult.prices": {
      "properties": {
        "ukrw": {
          "type": "string",
          "description": "ukrw amount"
        },
        "uluna": {
          "type": "string",
          "description": "uluna amount"
        },
        "umnt": {
          "type": "string",
          "description": "umnt amount"
        },
        "usdr": {
          "type": "string",
          "description": "usdr amount"
        },
        "uusd": {
          "type": "string",
          "description": "uusd amount"
        }
      },
      "required": [
        "ukrw",
        "uluna",
        "umnt",
        "usdr",
        "uusd"
      ]
    },
    "getDashboardResult.taxCaps": {
      "properties": {
        "denom": {
          "type": "string",
          "description": "denom name"
        },
        "taxCap": {
          "type": "string",
          "description": "tax cap amount"
        }
      },
      "required": [
        "denom",
        "taxCap"
      ]
    },
    "getDashboardResult.issuances": {
      "properties": {
        "ukrw": {
          "type": "string",
          "description": "ukrw amount"
        },
        "uluna": {
          "type": "string",
          "description": "uluna amount"
        },
        "umnt": {
          "type": "string",
          "description": "umnt amount"
        },
        "usdr": {
          "type": "string",
          "description": "usdr amount"
        },
        "uusd": {
          "type": "string",
          "description": "uusd amount"
        }
      },
      "required": [
        "ukrw",
        "uluna",
        "umnt",
        "usdr",
        "uusd"
      ]
    },
    "getDashboardResult.stakingPool": {
      "properties": {
        "bondedTokens": {
          "type": "string",
          "description": "bonded token amount"
        },
        "notBondedTokens": {
          "type": "string",
          "description": "not bonded token amount"
        },
        "stakingRatio": {
          "type": "string",
          "description": "staking ratio"
        }
      },
      "required": [
        "bondedTokens",
        "notBondedTokens",
        "stakingRatio"
      ]
    },
    "getDashboardResult.communityPool": {
      "properties": {
        "ukrw": {
          "type": "string",
          "description": "ukrw amount"
        },
        "uluna": {
          "type": "string",
          "description": "uluna amount"
        },
        "umnt": {
          "type": "string",
          "description": "umnt amount"
        },
        "usdr": {
          "type": "string",
          "description": "usdr amount"
        },
        "uusd": {
          "type": "string",
          "description": "uusd amount"
        }
      },
      "required": [
        "ukrw",
        "uluna",
        "umnt",
        "usdr",
        "uusd"
      ]
    },
    "getLastHourTxAndOpsCountResult": {
      "properties": {
        "last_1h_op": {
          "type": "number",
          "description": "total ops count in last hour"
        },
        "last_1h_tx": {
          "type": "number",
          "description": "total txs count in last hour"
        }
      },
      "required": [
        "last_1h_op",
        "last_1h_tx"
      ]
    },
    "getRegisteredAccountsResult": {
      "properties": {
        "total": {
          "type": "number",
          "description": "total registered accounts in the time period"
        },
        "periodic": {
          "type": "array",
          "description": "daily periodic account info's",
          "items": {
            "$ref": "#/definitions/getRegisteredAccountsResult.periodic"
          }
        },
        "cumulative": {
          "type": "array",
          "description": "cumulative registered account count info's",
          "items": {
            "$ref": "#/definitions/getRegisteredAccountsResult.cumulative"
          }
        }
      },
      "required": [
        "total",
        "periodic",
        "cumulative"
      ]
    },
    "getRegisteredAccountsResult.periodic": {
      "properties": {
        "datetime": {
          "type": "number",
          "description": "unix timestamp"
        },
        "value": {
          "type": "number",
          "description": "daily registered account count"
        }
      },
      "required": [
        "datetime",
        "value"
      ]
    },
    "getRegisteredAccountsResult.cumulative": {
      "properties": {
        "datetime": {
          "type": "number",
          "description": "unix timestamp"
        },
        "value": {
          "type": "number",
          "description": "daily cumulative account count from genesis"
        }
      },
      "required": [
        "datetime",
        "value"
      ]
    },
    "seigniorage": {
      "properties": {
        "datetime": {
          "type": "number",
          "description": "unix timestamp"
        },
        "seigniorageProceeds": {
          "type": "string",
          "description": "amount of seigniorage on datetime"
        },
        "dailyReturn": {
          "type": "number",
          "description": "daily return"
        },
        "annualizedReturn": {
          "type": "number",
          "description": "annualized return"
        }
      },
      "required": [
        "datetime",
        "seigniorageProceeds",
        "dailyReturn",
        "annualizedReturn"
      ]
    },
    "stakingHistory": {
      "properties": {
        "datetime": {
          "type": "number",
          "description": "unix timestamp"
        },
        "stakingRatio": {
          "type": "string",
          "description": "staking ratio"
        }
      },
      "required": [
        "datetime",
        "stakingRatio"
      ]
    },
    "getTxVolumeResult": {
      "properties": {
        "cumulative": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxVolumeResult.cumulative"
          }
        },
        "periodic": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxVolumeResult.periodic"
          }
        }
      },
      "required": [
        "cumulative",
        "periodic"
      ]
    },
    "getTxVolumeResult.cumulative": {
      "properties": {
        "denom": {
          "type": "string",
          "description": "denom name"
        },
        "data": {
          "type": "array",
          "description": "history data",
          "items": {
            "$ref": "#/definitions/getTxVolumeResult.cumulative.data"
          }
        }
      },
      "required": [
        "denom",
        "data"
      ]
    },
    "getTxVolumeResult.cumulative.data": {
      "properties": {
        "datetime": {
          "type": "number",
          "description": "unix time"
        },
        "txVolume": {
          "type": "string",
          "description": "time wise cumulative tx volume"
        }
      },
      "required": [
        "datetime",
        "txVolume"
      ]
    },
    "getTxVolumeResult.periodic": {
      "properties": {
        "denom": {
          "type": "string",
          "description": "denom name"
        },
        "data": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxVolumeResult.periodic.data"
          }
        }
      },
      "required": [
        "denom",
        "data"
      ]
    },
    "getTxVolumeResult.periodic.data": {
      "properties": {
        "datetime": {
          "type": "number",
          "description": "unix time"
        },
        "txVolume": {
          "type": "string",
          "description": "periodic tx volume"
        }
      },
      "required": [
        "datetime",
        "txVolume"
      ]
    },
    "getProposalResult": {
      "properties": {
        "id": {
          "type": "string",
          "description": ""
        },
        "proposer": {
          "type": "object",
          "description": "Proposer information",
          "$ref": "#/definitions/getProposalResult.proposer"
        },
        "type": {
          "type": "string",
          "description": "Proposal type"
        },
        "status": {
          "type": "string",
          "description": "Proposal status"
        },
        "submitTime": {
          "type": "string",
          "description": ""
        },
        "title": {
          "type": "string",
          "description": ""
        },
        "description": {
          "type": "string",
          "description": ""
        },
        "deposit": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getProposalResult.deposit"
        },
        "vote": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getProposalResult.vote"
        },
        "validatorsNotVoted": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getProposalResult.validatorsNotVoted"
          }
        }
      },
      "required": [
        "id",
        "proposer",
        "type",
        "status",
        "submitTime",
        "title",
        "description",
        "deposit",
        "vote",
        "validatorsNotVoted"
      ]
    },
    "getProposalResult.proposer": {
      "properties": {
        "accountAddress": {
          "type": "string",
          "description": "Proposer information"
        },
        "moniker": {
          "type": "string",
          "description": "Proposer information"
        },
        "operatorAddress": {
          "type": "string",
          "description": "Proposer information"
        }
      },
      "required": [
        "accountAddress"
      ]
    },
    "getProposalResult.deposit": {
      "properties": {
        "depositEndTime": {
          "type": "string",
          "description": ""
        },
        "totalDeposit": {
          "type": "array",
          "description": "total deposit info",
          "items": {
            "$ref": "#/definitions/getProposalResult.deposit.totalDeposit"
          }
        },
        "minDeposit": {
          "type": "array",
          "description": "Minimum deposit",
          "items": {
            "$ref": "#/definitions/getProposalResult.deposit.minDeposit"
          }
        }
      },
      "required": [
        "depositEndTime",
        "totalDeposit",
        "minDeposit"
      ]
    },
    "getProposalResult.deposit.totalDeposit": {
      "properties": {
        "denom": {
          "type": "string",
          "description": "denom name"
        },
        "amount": {
          "type": "string",
          "description": "denom amount"
        }
      },
      "required": [
        "denom",
        "amount"
      ]
    },
    "getProposalResult.deposit.minDeposit": {
      "properties": {
        "denom": {
          "type": "string",
          "description": "Minimum deposit demon"
        },
        "amount": {
          "type": "string",
          "description": "Minimum deposit amount"
        }
      },
      "required": [
        "denom",
        "amount"
      ]
    },
    "getProposalResult.vote": {
      "properties": {
        "id": {
          "type": "string",
          "description": ""
        },
        "distribution": {
          "type": "object",
          "description": "Distribution of vote",
          "$ref": "#/definitions/getProposalResult.vote.distribution"
        },
        "count": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getProposalResult.vote.count"
        },
        "total": {
          "type": "string",
          "description": "Total voted luna"
        },
        "votingEndTime": {
          "type": "string",
          "description": ""
        },
        "stakedLuna": {
          "type": "string",
          "description": "Total staked luna"
        }
      },
      "required": [
        "id",
        "distribution",
        "count",
        "total",
        "votingEndTime",
        "stakedLuna"
      ]
    },
    "getProposalResult.vote.distribution": {
      "properties": {
        "Yes": {
          "type": "string",
          "description": "vote amount"
        },
        "No": {
          "type": "string",
          "description": "vote amount"
        },
        "NoWithVeto": {
          "type": "string",
          "description": "vote amount"
        },
        "Abstain": {
          "type": "string",
          "description": "vote amount"
        }
      },
      "required": [
        "Yes",
        "No",
        "NoWithVeto",
        "Abstain"
      ]
    },
    "getProposalResult.vote.count": {
      "properties": {
        "Yes": {
          "type": "string",
          "description": "vote count"
        },
        "No": {
          "type": "string",
          "description": "vote count"
        },
        "NoWithVeto": {
          "type": "string",
          "description": "vote count"
        },
        "Abstain": {
          "type": "string",
          "description": "vote count"
        }
      },
      "required": [
        "Yes",
        "No",
        "NoWithVeto",
        "Abstain"
      ]
    },
    "getProposalResult.validatorsNotVoted": {
      "properties": {
        "operatorAddress": {
          "type": "string",
          "description": ""
        },
        "consensusPubKey": {
          "type": "string",
          "description": ""
        },
        "description": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getProposalResult.validatorsNotVoted.description"
        }
      },
      "required": [
        "operatorAddress",
        "consensusPubKey",
        "description"
      ]
    },
    "getProposalResult.validatorsNotVoted.description": {
      "properties": {
        "moniker": {
          "type": "string",
          "description": ""
        },
        "identity": {
          "type": "string",
          "description": ""
        },
        "website": {
          "type": "string",
          "description": ""
        },
        "details": {
          "type": "string",
          "description": ""
        },
        "profileIcon": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "moniker",
        "identity",
        "website",
        "details",
        "profileIcon"
      ]
    },
    "getProposalDepositsResult": {
      "properties": {
        "limit": {
          "type": "number",
          "description": ""
        },
        "deposits": {
          "type": "array",
          "description": "Deposit list",
          "items": {
            "$ref": "#/definitions/getProposalDepositsResult.deposits"
          }
        }
      },
      "required": [
        "limit",
        "deposits"
      ]
    },
    "getProposalDepositsResult.deposits": {
      "properties": {
        "txhash": {
          "type": "string",
          "description": "Txhash of the deposit transaction"
        },
        "deposit": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getProposalDepositsResult.deposits.deposit"
          }
        },
        "depositor": {
          "type": "array",
          "description": "Depositor information",
          "items": {
            "$ref": "#/definitions/getProposalDepositsResult.deposits.depositor"
          }
        }
      },
      "required": [
        "txhash",
        "deposit",
        "depositor"
      ]
    },
    "getProposalDepositsResult.deposits.deposit": {
      "properties": {
        "amount": {
          "type": "string",
          "description": "Deposit amount"
        },
        "denom": {
          "type": "string",
          "description": "Deposit denomination"
        }
      },
      "required": [
        "amount",
        "denom"
      ]
    },
    "getProposalDepositsResult.deposits.depositor": {
      "properties": {
        "accountAddress": {
          "type": "string",
          "description": ""
        },
        "operatorAddress": {
          "type": "string",
          "description": ""
        },
        "moniker": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "accountAddress",
        "operatorAddress",
        "moniker"
      ]
    },
    "getProposalListResult": {
      "properties": {
        "minDeposit": {
          "type": "array",
          "description": "Minimum deposit minimum proposal deposit",
          "items": {
            "$ref": "#/definitions/getProposalListResult.minDeposit"
          }
        },
        "maxDepositPeriod": {
          "type": "string",
          "description": "Deposit period"
        },
        "votingPeriod": {
          "type": "string",
          "description": ""
        },
        "proposals": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getProposalListResult.proposals"
          }
        }
      },
      "required": [
        "minDeposit",
        "maxDepositPeriod",
        "votingPeriod",
        "proposals"
      ]
    },
    "getProposalListResult.minDeposit": {
      "properties": {
        "denom": {
          "type": "string",
          "description": "denom name"
        },
        "amount": {
          "type": "string",
          "description": "amount"
        }
      },
      "required": [
        "denom",
        "amount"
      ]
    },
    "getProposalListResult.proposals": {
      "properties": {
        "id": {
          "type": "string",
          "description": ""
        },
        "proposer": {
          "type": "object",
          "description": "Proposer information",
          "$ref": "#/definitions/getProposalListResult.proposals.proposer"
        },
        "type": {
          "type": "string",
          "description": "Proposal type"
        },
        "status": {
          "type": "string",
          "description": "Proposal status"
        },
        "submitTime": {
          "type": "string",
          "description": ""
        },
        "title": {
          "type": "string",
          "description": ""
        },
        "description": {
          "type": "string",
          "description": ""
        },
        "deposit": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getProposalListResult.proposals.deposit"
        },
        "vote": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getProposalListResult.proposals.vote"
        }
      },
      "required": [
        "id",
        "proposer",
        "type",
        "status",
        "submitTime",
        "title",
        "description",
        "deposit",
        "vote"
      ]
    },
    "getProposalListResult.proposals.proposer": {
      "properties": {
        "accountAddress": {
          "type": "string",
          "description": "Proposer address"
        },
        "moniker": {
          "type": "string",
          "description": "Proposer moniker"
        }
      },
      "required": [
        "accountAddress",
        "moniker"
      ]
    },
    "getProposalListResult.proposals.deposit": {
      "properties": {
        "depositEndTime": {
          "type": "string",
          "description": ""
        },
        "totalDeposit": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getProposalListResult.proposals.deposit.totalDeposit"
          }
        }
      },
      "required": [
        "depositEndTime",
        "totalDeposit"
      ]
    },
    "getProposalListResult.proposals.deposit.totalDeposit": {
      "properties": {
        "depositEndTime": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "depositEndTime"
      ]
    },
    "getProposalListResult.proposals.vote": {
      "properties": {
        "id": {
          "type": "string",
          "description": ""
        },
        "distribution": {
          "type": "object",
          "description": "Distribution of vote",
          "$ref": "#/definitions/getProposalListResult.proposals.vote.distribution"
        },
        "count": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getProposalListResult.proposals.vote.count"
        },
        "total": {
          "type": "string",
          "description": "Total voted luna"
        },
        "votingEndTime": {
          "type": "string",
          "description": ""
        },
        "stakedLuna": {
          "type": "string",
          "description": "Total staked luna"
        }
      },
      "required": [
        "id",
        "distribution",
        "count",
        "total",
        "votingEndTime",
        "stakedLuna"
      ]
    },
    "getProposalListResult.proposals.vote.distribution": {
      "properties": {
        "Yes": {
          "type": "string",
          "description": "vote amount"
        },
        "No": {
          "type": "string",
          "description": "vote amount"
        },
        "NoWithVeto": {
          "type": "string",
          "description": "vote amount"
        },
        "Abstain": {
          "type": "string",
          "description": "vote amount"
        }
      },
      "required": [
        "Yes",
        "No",
        "NoWithVeto",
        "Abstain"
      ]
    },
    "getProposalListResult.proposals.vote.count": {
      "properties": {
        "Yes": {
          "type": "string",
          "description": "vote count"
        },
        "No": {
          "type": "string",
          "description": "vote count"
        },
        "NoWithVeto": {
          "type": "string",
          "description": "vote count"
        },
        "Abstain": {
          "type": "string",
          "description": "vote count"
        }
      },
      "required": [
        "Yes",
        "No",
        "NoWithVeto",
        "Abstain"
      ]
    },
    "getProposalVotesResult": {
      "properties": {
        "limit": {
          "type": "number",
          "description": ""
        },
        "votes": {
          "type": "array",
          "description": "Vote list",
          "items": {
            "$ref": "#/definitions/getProposalVotesResult.votes"
          }
        }
      },
      "required": [
        "limit",
        "votes"
      ]
    },
    "getProposalVotesResult.votes": {
      "properties": {
        "txhash": {
          "type": "string",
          "description": "Txhash of the vote transaction"
        },
        "answer": {
          "type": "string",
          "description": "'Yes', 'No', 'NoWithVeto', 'Abstain'"
        },
        "voter": {
          "type": "array",
          "description": "Voter information",
          "items": {
            "$ref": "#/definitions/getProposalVotesResult.votes.voter"
          }
        }
      },
      "required": [
        "txhash",
        "answer",
        "voter"
      ]
    },
    "getProposalVotesResult.votes.voter": {
      "properties": {
        "accountAddress": {
          "type": "string",
          "description": ""
        },
        "operatorAddress": {
          "type": "string",
          "description": ""
        },
        "moniker": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "accountAddress",
        "operatorAddress",
        "moniker"
      ]
    },
    "getMarketPriceResult": {
      "properties": {
        "lastPrice": {
          "type": "number",
          "description": ""
        },
        "oneDayVariation": {
          "type": "string",
          "description": ""
        },
        "oneDayVariationRate": {
          "type": "string",
          "description": ""
        },
        "prices": {
          "type": "array",
          "description": "Price history",
          "items": {
            "$ref": "#/definitions/getMarketPriceResult.prices"
          }
        }
      },
      "required": [
        "lastPrice",
        "oneDayVariation",
        "oneDayVariationRate",
        "prices"
      ]
    },
    "getMarketPriceResult.prices": {
      "properties": {
        "denom": {
          "type": "string",
          "description": "Coin denomination"
        },
        "datetime": {
          "type": "number",
          "description": ""
        },
        "price": {
          "type": "number",
          "description": ""
        }
      },
      "required": [
        "denom",
        "datetime",
        "price"
      ]
    },
    "rates": {
      "properties": {
        "denom": {
          "type": "string",
          "description": "Coin denomination"
        },
        "swaprate": {
          "type": "string",
          "description": "Current swap rate"
        },
        "oneDayVariation": {
          "type": "string",
          "description": ""
        },
        "oneDayVariationRate": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "denom",
        "swaprate",
        "oneDayVariation",
        "oneDayVariationRate"
      ]
    },
    "validators": {
      "properties": {
        "operatorAddress": {
          "type": "string",
          "description": ""
        },
        "consensusPubkey": {
          "type": "string",
          "description": ""
        },
        "description": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/validators.description"
        },
        "tokens": {
          "type": "string",
          "description": ""
        },
        "delegatorShares": {
          "type": "string",
          "description": ""
        },
        "votingPower": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/validators.votingPower"
        },
        "commissionInfo": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/validators.commissionInfo"
        },
        "upTime": {
          "type": "number",
          "description": ""
        },
        "status": {
          "type": "string",
          "description": ""
        },
        "rewardsPool": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/validators.rewardsPool"
        },
        "stakingReturn": {
          "type": "string",
          "description": ""
        },
        "myDelegation": {
          "type": "string",
          "description": "The amount of user delegation to this validator"
        },
        "myUndelegation": {
          "type": "string",
          "description": "Undelegation information of user in progress in this validator"
        }
      },
      "required": [
        "operatorAddress",
        "consensusPubkey",
        "description",
        "tokens",
        "delegatorShares",
        "votingPower",
        "commissionInfo",
        "upTime",
        "status",
        "rewardsPool",
        "stakingReturn",
        "myDelegation",
        "myUndelegation"
      ]
    },
    "validators.description": {
      "properties": {
        "moniker": {
          "type": "string",
          "description": ""
        },
        "identity": {
          "type": "string",
          "description": ""
        },
        "website": {
          "type": "string",
          "description": ""
        },
        "details": {
          "type": "string",
          "description": ""
        },
        "profileIcon": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "moniker",
        "identity",
        "website",
        "details",
        "profileIcon"
      ]
    },
    "validators.votingPower": {
      "properties": {
        "amount": {
          "type": "string",
          "description": ""
        },
        "weight": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "amount",
        "weight"
      ]
    },
    "validators.commissionInfo": {
      "properties": {
        "rate": {
          "type": "string",
          "description": ""
        },
        "maxRate": {
          "type": "string",
          "description": ""
        },
        "maxChangeRate": {
          "type": "string",
          "description": ""
        },
        "updateTime": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "rate",
        "maxRate",
        "maxChangeRate",
        "updateTime"
      ]
    },
    "validators.rewardsPool": {
      "properties": {
        "total": {
          "type": "string",
          "description": ""
        },
        "denoms": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/validators.rewardsPool.denoms"
          }
        }
      },
      "required": [
        "total",
        "denoms"
      ]
    },
    "validators.rewardsPool.denoms": {
      "properties": {
        "denom": {
          "type": "string",
          "description": ""
        },
        "amount": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "denom",
        "amount"
      ]
    },
    "getStakingForAccountResult": {
      "properties": {
        "delegationTotal": {
          "type": "string",
          "description": "Amount staked by user"
        },
        "availableLuna": {
          "type": "string",
          "description": "Users total luna amount"
        },
        "undelegations": {
          "type": "array",
          "description": "Undelegation information in progress by user",
          "items": {
            "$ref": "#/definitions/getStakingForAccountResult.undelegations"
          }
        },
        "myDelegations": {
          "type": "array",
          "description": "Users delegations list",
          "items": {
            "$ref": "#/definitions/getStakingForAccountResult.myDelegations"
          }
        },
        "rewards": {
          "type": "object",
          "description": "User's reward info",
          "$ref": "#/definitions/getStakingForAccountResult.rewards"
        },
        "validators": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getStakingForAccountResult.validators"
          }
        }
      },
      "required": [
        "delegationTotal",
        "availableLuna",
        "undelegations",
        "myDelegations",
        "rewards",
        "validators"
      ]
    },
    "getStakingForAccountResult.undelegations": {
      "properties": {
        "amount": {
          "type": "string",
          "description": "Undelegation amount"
        },
        "creationHeight": {
          "type": "string",
          "description": "Undelegation creation block height"
        },
        "releaseTime": {
          "type": "string",
          "description": "Amount release time"
        },
        "validatorAddress": {
          "type": "string",
          "description": "Validator address"
        },
        "validatorName": {
          "type": "string",
          "description": "Validators name"
        },
        "validatorStatus": {
          "type": "string",
          "description": "Validator status"
        }
      },
      "required": [
        "amount",
        "creationHeight",
        "releaseTime",
        "validatorAddress",
        "validatorName",
        "validatorStatus"
      ]
    },
    "getStakingForAccountResult.myDelegations": {
      "properties": {
        "amountDelegated": {
          "type": "string",
          "description": "Users delegations list"
        },
        "totalReward": {
          "type": "string",
          "description": "Users delegations list"
        },
        "validatorAddress": {
          "type": "string",
          "description": "Users delegations list"
        },
        "validatorName": {
          "type": "string",
          "description": "Users delegations list"
        }
      },
      "required": [
        "amountDelegated",
        "totalReward",
        "validatorAddress",
        "validatorName"
      ]
    },
    "getStakingForAccountResult.rewards": {
      "properties": {
        "total": {
          "type": "string",
          "description": "User's total reward"
        },
        "denoms": {
          "type": "array",
          "description": "User's reward by denoms",
          "items": {
            "$ref": "#/definitions/getStakingForAccountResult.rewards.denoms"
          }
        }
      },
      "required": [
        "total",
        "denoms"
      ]
    },
    "getStakingForAccountResult.rewards.denoms": {
      "properties": {
        "denom": {
          "type": "string",
          "description": "reward denom"
        },
        "amount": {
          "type": "string",
          "description": "reward amount"
        }
      },
      "required": [
        "denom",
        "amount"
      ]
    },
    "getStakingForAccountResult.validators": {
      "properties": {
        "operatorAddress": {
          "type": "string",
          "description": ""
        },
        "consensusPubkey": {
          "type": "string",
          "description": ""
        },
        "description": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getStakingForAccountResult.validators.description"
        },
        "tokens": {
          "type": "string",
          "description": ""
        },
        "delegatorShares": {
          "type": "string",
          "description": ""
        },
        "votingPower": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getStakingForAccountResult.validators.votingPower"
        },
        "commissionInfo": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getStakingForAccountResult.validators.commissionInfo"
        },
        "upTime": {
          "type": "number",
          "description": ""
        },
        "status": {
          "type": "string",
          "description": ""
        },
        "rewardsPool": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getStakingForAccountResult.validators.rewardsPool"
        },
        "stakingReturn": {
          "type": "string",
          "description": ""
        },
        "myDelegation": {
          "type": "string",
          "description": "The amount of user delegation to this validator"
        },
        "myUndelegation": {
          "type": "string",
          "description": "Undelegation information of user in progress in this validator"
        }
      },
      "required": [
        "operatorAddress",
        "consensusPubkey",
        "description",
        "tokens",
        "delegatorShares",
        "votingPower",
        "commissionInfo",
        "upTime",
        "status",
        "rewardsPool",
        "stakingReturn",
        "myDelegation",
        "myUndelegation"
      ]
    },
    "getStakingForAccountResult.validators.description": {
      "properties": {
        "moniker": {
          "type": "string",
          "description": ""
        },
        "identity": {
          "type": "string",
          "description": ""
        },
        "website": {
          "type": "string",
          "description": ""
        },
        "details": {
          "type": "string",
          "description": ""
        },
        "profileIcon": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "moniker",
        "identity",
        "website",
        "details",
        "profileIcon"
      ]
    },
    "getStakingForAccountResult.validators.votingPower": {
      "properties": {
        "amount": {
          "type": "string",
          "description": ""
        },
        "weight": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "amount",
        "weight"
      ]
    },
    "getStakingForAccountResult.validators.commissionInfo": {
      "properties": {
        "rate": {
          "type": "string",
          "description": ""
        },
        "maxRate": {
          "type": "string",
          "description": ""
        },
        "maxChangeRate": {
          "type": "string",
          "description": ""
        },
        "updateTime": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "rate",
        "maxRate",
        "maxChangeRate",
        "updateTime"
      ]
    },
    "getStakingForAccountResult.validators.rewardsPool": {
      "properties": {
        "total": {
          "type": "string",
          "description": ""
        },
        "denoms": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getStakingForAccountResult.validators.rewardsPool.denoms"
          }
        }
      },
      "required": [
        "total",
        "denoms"
      ]
    },
    "getStakingForAccountResult.validators.rewardsPool.denoms": {
      "properties": {
        "denom": {
          "type": "string",
          "description": ""
        },
        "amount": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "denom",
        "amount"
      ]
    },
    "getValidatorClaimsResult": {
      "properties": {
        "page": {
          "type": "number",
          "description": ""
        },
        "limit": {
          "type": "number",
          "description": ""
        },
        "claims": {
          "type": "array",
          "description": "Claim list",
          "items": {
            "$ref": "#/definitions/getValidatorClaimsResult.claims"
          }
        }
      },
      "required": [
        "page",
        "limit",
        "claims"
      ]
    },
    "getValidatorClaimsResult.claims": {
      "properties": {
        "chainId": {
          "type": "string",
          "description": ""
        },
        "txhash": {
          "type": "string",
          "description": "Tx hash"
        },
        "type": {
          "type": "string",
          "description": "Claim type"
        },
        "amount": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getValidatorClaimsResult.claims.amount"
          }
        },
        "timestamp": {
          "type": "string",
          "description": "Tx timestamp"
        }
      },
      "required": [
        "chainId",
        "txhash",
        "type",
        "amount",
        "timestamp"
      ]
    },
    "getValidatorClaimsResult.claims.amount": {
      "properties": {
        "denom": {
          "type": "string",
          "description": ""
        },
        "amount": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "denom",
        "amount"
      ]
    },
    "getValidatorDelegationsResult": {
      "properties": {
        "page": {
          "type": "number",
          "description": ""
        },
        "limit": {
          "type": "number",
          "description": ""
        },
        "events": {
          "type": "array",
          "description": "Delegation event list",
          "items": {
            "$ref": "#/definitions/getValidatorDelegationsResult.events"
          }
        }
      },
      "required": [
        "page",
        "limit",
        "events"
      ]
    },
    "getValidatorDelegationsResult.events": {
      "properties": {
        "chainId": {
          "type": "string",
          "description": ""
        },
        "txhash": {
          "type": "string",
          "description": ""
        },
        "type": {
          "type": "string",
          "description": "Event type"
        },
        "amount": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getValidatorDelegationsResult.events.amount"
          }
        },
        "timestamp": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "chainId",
        "txhash",
        "type",
        "amount",
        "timestamp"
      ]
    },
    "getValidatorDelegationsResult.events.amount": {
      "properties": {
        "denom": {
          "type": "string",
          "description": ""
        },
        "amount": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "denom",
        "amount"
      ]
    },
    "getValidatorDelegatorsResult": {
      "properties": {
        "page": {
          "type": "number",
          "description": ""
        },
        "limit": {
          "type": "number",
          "description": ""
        },
        "delegator": {
          "type": "array",
          "description": "Delegator list",
          "items": {
            "$ref": "#/definitions/getValidatorDelegatorsResult.delegator"
          }
        }
      },
      "required": [
        "page",
        "limit",
        "delegator"
      ]
    },
    "getValidatorDelegatorsResult.delegator": {
      "properties": {
        "address": {
          "type": "string",
          "description": "Delegator address"
        },
        "amount": {
          "type": "string",
          "description": "Amount of luna delegated"
        },
        "weight": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "address",
        "amount",
        "weight"
      ]
    },
    "getValidatorDetailResult": {
      "properties": {
        "operatorAddress": {
          "type": "string",
          "description": ""
        },
        "consensusPubkey": {
          "type": "string",
          "description": ""
        },
        "description": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getValidatorDetailResult.description"
        },
        "tokens": {
          "type": "string",
          "description": ""
        },
        "delegatorShares": {
          "type": "string",
          "description": ""
        },
        "votingPower": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getValidatorDetailResult.votingPower"
        },
        "commissionInfo": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getValidatorDetailResult.commissionInfo"
        },
        "upTime": {
          "type": "number",
          "description": ""
        },
        "status": {
          "type": "string",
          "description": ""
        },
        "rewardsPool": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getValidatorDetailResult.rewardsPool"
        },
        "stakingReturn": {
          "type": "string",
          "description": ""
        },
        "accountAddress": {
          "type": "string",
          "description": ""
        },
        "selfDelegation": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getValidatorDetailResult.selfDelegation"
        },
        "myDelegation": {
          "type": "string",
          "description": "total delegation amount"
        },
        "myUndelegation": {
          "type": "array",
          "description": "user undelegations",
          "items": {
            "$ref": "#/definitions/getValidatorDetailResult.myUndelegation"
          }
        },
        "myDelegatable": {
          "type": "string",
          "description": "delegateable amount"
        },
        "myRewards": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getValidatorDetailResult.myRewards"
        }
      },
      "required": [
        "operatorAddress",
        "consensusPubkey",
        "description",
        "tokens",
        "delegatorShares",
        "votingPower",
        "commissionInfo",
        "upTime",
        "status",
        "rewardsPool",
        "stakingReturn",
        "accountAddress",
        "selfDelegation",
        "myDelegation",
        "myUndelegation",
        "myDelegatable",
        "myRewards"
      ]
    },
    "getValidatorDetailResult.description": {
      "properties": {
        "moniker": {
          "type": "string",
          "description": ""
        },
        "identity": {
          "type": "string",
          "description": ""
        },
        "website": {
          "type": "string",
          "description": ""
        },
        "details": {
          "type": "string",
          "description": ""
        },
        "profileIcon": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "moniker",
        "identity",
        "website",
        "details",
        "profileIcon"
      ]
    },
    "getValidatorDetailResult.votingPower": {
      "properties": {
        "amount": {
          "type": "string",
          "description": "string int format"
        },
        "weight": {
          "type": "string",
          "description": "bit int"
        }
      },
      "required": [
        "amount",
        "weight"
      ]
    },
    "getValidatorDetailResult.commissionInfo": {
      "properties": {
        "rate": {
          "type": "string",
          "description": ""
        },
        "maxRate": {
          "type": "string",
          "description": ""
        },
        "maxChangeRate": {
          "type": "string",
          "description": ""
        },
        "updateTime": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "rate",
        "maxRate",
        "maxChangeRate",
        "updateTime"
      ]
    },
    "getValidatorDetailResult.rewardsPool": {
      "properties": {
        "total": {
          "type": "string",
          "description": ""
        },
        "denoms": {
          "type": "array",
          "description": "{denom: string, amount: string} format",
          "items": {
            "$ref": "#/definitions/getValidatorDetailResult.rewardsPool.denoms"
          }
        }
      },
      "required": [
        "total",
        "denoms"
      ]
    },
    "getValidatorDetailResult.rewardsPool.denoms": {
      "properties": {
        "denom": {
          "type": "string",
          "description": ""
        },
        "amount": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "denom",
        "amount"
      ]
    },
    "getValidatorDetailResult.selfDelegation": {
      "properties": {
        "amount": {
          "type": "string",
          "description": ""
        },
        "weight": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "amount",
        "weight"
      ]
    },
    "getValidatorDetailResult.myUndelegation": {
      "properties": {
        "releaseTime": {
          "type": "string",
          "description": "undelegation release date time"
        },
        "amount": {
          "type": "string",
          "description": "undelegation amount"
        },
        "validatorName": {
          "type": "string",
          "description": "validator name"
        },
        "validatorAddress": {
          "type": "string",
          "description": "validator address"
        },
        "creationHeight": {
          "type": "string",
          "description": "block height"
        }
      },
      "required": [
        "releaseTime",
        "amount",
        "validatorName",
        "validatorAddress",
        "creationHeight"
      ]
    },
    "getValidatorDetailResult.myRewards": {
      "properties": {
        "total": {
          "type": "string",
          "description": "total reward"
        },
        "denoms": {
          "type": "array",
          "description": "reward by denoms list",
          "items": {
            "$ref": "#/definitions/getValidatorDetailResult.myRewards.denoms"
          }
        }
      },
      "required": [
        "total",
        "denoms"
      ]
    },
    "getValidatorDetailResult.myRewards.denoms": {
      "properties": {
        "denom": {
          "type": "string",
          "description": "denom name"
        },
        "amount": {
          "type": "string",
          "description": "reward amount"
        },
        "adjustedAmount": {
          "type": "string",
          "description": "reward amount adjusted by luna price"
        }
      },
      "required": [
        "denom",
        "amount",
        "adjustedAmount"
      ]
    },
    "validator": {
      "properties": {
        "operatorAddress": {
          "type": "string",
          "description": ""
        },
        "consensusPubkey": {
          "type": "string",
          "description": ""
        },
        "description": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/validator.description"
        },
        "tokens": {
          "type": "string",
          "description": ""
        },
        "delegatorShares": {
          "type": "string",
          "description": ""
        },
        "votingPower": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/validator.votingPower"
        },
        "commissionInfo": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/validator.commissionInfo"
        },
        "upTime": {
          "type": "number",
          "description": ""
        },
        "status": {
          "type": "string",
          "description": ""
        },
        "rewardsPool": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/validator.rewardsPool"
        },
        "stakingReturn": {
          "type": "string",
          "description": ""
        },
        "accountAddress": {
          "type": "string",
          "description": ""
        },
        "selfDelegation": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/validator.selfDelegation"
        }
      },
      "required": [
        "operatorAddress",
        "consensusPubkey",
        "description",
        "tokens",
        "delegatorShares",
        "votingPower",
        "commissionInfo",
        "upTime",
        "status",
        "rewardsPool",
        "stakingReturn",
        "accountAddress",
        "selfDelegation"
      ]
    },
    "validator.description": {
      "properties": {
        "moniker": {
          "type": "string",
          "description": ""
        },
        "identity": {
          "type": "string",
          "description": ""
        },
        "website": {
          "type": "string",
          "description": ""
        },
        "details": {
          "type": "string",
          "description": ""
        },
        "profileIcon": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "moniker",
        "identity",
        "website",
        "details",
        "profileIcon"
      ]
    },
    "validator.votingPower": {
      "properties": {
        "amount": {
          "type": "string",
          "description": ""
        },
        "weight": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "amount",
        "weight"
      ]
    },
    "validator.commissionInfo": {
      "properties": {
        "rate": {
          "type": "string",
          "description": ""
        },
        "maxRate": {
          "type": "string",
          "description": ""
        },
        "maxChangeRate": {
          "type": "string",
          "description": ""
        },
        "updateTime": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "rate",
        "maxRate",
        "maxChangeRate",
        "updateTime"
      ]
    },
    "validator.rewardsPool": {
      "properties": {
        "total": {
          "type": "string",
          "description": ""
        },
        "denoms": {
          "type": "array",
          "description": "{denom: string, amount: string} format",
          "items": {
            "$ref": "#/definitions/validator.rewardsPool.denoms"
          }
        }
      },
      "required": [
        "total",
        "denoms"
      ]
    },
    "validator.rewardsPool.denoms": {
      "properties": {
        "denom": {
          "type": "string",
          "description": ""
        },
        "amount": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "denom",
        "amount"
      ]
    },
    "validator.selfDelegation": {
      "properties": {
        "amount": {
          "type": "string",
          "description": ""
        },
        "weight": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "amount",
        "weight"
      ]
    },
    "getGasPricesResult": {
      "properties": {
        "uluna": {
          "type": "string",
          "description": "gas price in uluna"
        },
        "usdr": {
          "type": "string",
          "description": "gas price in usdr"
        },
        "uusd": {
          "type": "string",
          "description": "gas price in uusd"
        },
        "ukrw": {
          "type": "string",
          "description": "gas price in ukrw"
        },
        "umnt": {
          "type": "string",
          "description": "gas price in umnt"
        }
      },
      "required": [
        "uluna",
        "usdr",
        "uusd",
        "ukrw",
        "umnt"
      ]
    },
    "txs": {
      "properties": {
        "timestamp": {
          "type": "string",
          "description": "Last seen"
        },
        "txhash": {
          "type": "string",
          "description": ""
        },
        "tx": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/txs.tx"
        }
      },
      "required": [
        "timestamp",
        "txhash",
        "tx"
      ]
    },
    "txs.tx": {
      "properties": {
        "type": {
          "type": "string",
          "description": ""
        },
        "value": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/txs.tx.value"
        }
      },
      "required": [
        "type",
        "value"
      ]
    },
    "txs.tx.value": {
      "properties": {
        "fee": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/txs.tx.value.fee"
        },
        "memo": {
          "type": "string",
          "description": ""
        },
        "msg": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/txs.tx.value.msg"
          }
        },
        "signatures": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/txs.tx.value.signatures"
          }
        }
      },
      "required": [
        "fee",
        "memo",
        "msg",
        "signatures"
      ]
    },
    "txs.tx.value.fee": {
      "properties": {
        "gas": {
          "type": "string",
          "description": ""
        },
        "amount": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/txs.tx.value.fee.amount"
          }
        }
      },
      "required": [
        "gas",
        "amount"
      ]
    },
    "txs.tx.value.fee.amount": {
      "properties": {
        "denom": {
          "type": "string",
          "description": ""
        },
        "amount": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "denom",
        "amount"
      ]
    },
    "txs.tx.value.msg": {
      "properties": {
        "type": {
          "type": "string",
          "description": ""
        },
        "value": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/txs.tx.value.msg.value"
        }
      },
      "required": [
        "type",
        "value"
      ]
    },
    "txs.tx.value.msg.value": {
      "properties": {
        "inputs": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/txs.tx.value.msg.value.inputs"
          }
        },
        "outputs": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/txs.tx.value.msg.value.outputs"
          }
        }
      },
      "required": [
        "inputs",
        "outputs"
      ]
    },
    "txs.tx.value.msg.value.inputs": {
      "properties": {
        "address": {
          "type": "string",
          "description": ""
        },
        "coins": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/txs.tx.value.msg.value.inputs.coins"
          }
        }
      },
      "required": [
        "address",
        "coins"
      ]
    },
    "txs.tx.value.msg.value.inputs.coins": {
      "properties": {
        "deonm": {
          "type": "string",
          "description": ""
        },
        "amount": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "deonm",
        "amount"
      ]
    },
    "txs.tx.value.msg.value.outputs": {
      "properties": {
        "address": {
          "type": "string",
          "description": ""
        },
        "coins": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/txs.tx.value.msg.value.outputs.coins"
          }
        }
      },
      "required": [
        "address",
        "coins"
      ]
    },
    "txs.tx.value.msg.value.outputs.coins": {
      "properties": {
        "deonm": {
          "type": "string",
          "description": ""
        },
        "amount": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "deonm",
        "amount"
      ]
    },
    "txs.tx.value.signatures": {
      "properties": {
        "signature": {
          "type": "string",
          "description": ""
        },
        "pub_key": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/txs.tx.value.signatures.pub_key"
        }
      },
      "required": [
        "signature",
        "pub_key"
      ]
    },
    "txs.tx.value.signatures.pub_key": {
      "properties": {
        "type": {
          "type": "string",
          "description": ""
        },
        "value": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "type",
        "value"
      ]
    },
    "getMempoolByHashResult": {
      "properties": {
        "timestamp": {
          "type": "string",
          "description": "Last seen"
        },
        "txhash": {
          "type": "string",
          "description": ""
        },
        "tx": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getMempoolByHashResult.tx"
        }
      },
      "required": [
        "timestamp",
        "txhash",
        "tx"
      ]
    },
    "getMempoolByHashResult.tx": {
      "properties": {
        "type": {
          "type": "string",
          "description": ""
        },
        "value": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getMempoolByHashResult.tx.value"
        }
      },
      "required": [
        "type",
        "value"
      ]
    },
    "getMempoolByHashResult.tx.value": {
      "properties": {
        "fee": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getMempoolByHashResult.tx.value.fee"
        },
        "memo": {
          "type": "string",
          "description": ""
        },
        "msg": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getMempoolByHashResult.tx.value.msg"
          }
        },
        "signatures": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getMempoolByHashResult.tx.value.signatures"
          }
        }
      },
      "required": [
        "fee",
        "memo",
        "msg",
        "signatures"
      ]
    },
    "getMempoolByHashResult.tx.value.fee": {
      "properties": {
        "amount": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getMempoolByHashResult.tx.value.fee.amount"
          }
        },
        "gas": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "amount",
        "gas"
      ]
    },
    "getMempoolByHashResult.tx.value.fee.amount": {
      "properties": {
        "denom": {
          "type": "string",
          "description": ""
        },
        "amount": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "denom",
        "amount"
      ]
    },
    "getMempoolByHashResult.tx.value.msg": {
      "properties": {
        "type": {
          "type": "string",
          "description": ""
        },
        "value": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getMempoolByHashResult.tx.value.msg.value"
        }
      },
      "required": [
        "type",
        "value"
      ]
    },
    "getMempoolByHashResult.tx.value.msg.value": {
      "properties": {
        "amount": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getMempoolByHashResult.tx.value.msg.value.amount"
          }
        }
      },
      "required": [
        "amount"
      ]
    },
    "getMempoolByHashResult.tx.value.msg.value.amount": {
      "properties": {
        "denom": {
          "type": "string",
          "description": ""
        },
        "amount": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "denom",
        "amount"
      ]
    },
    "getMempoolByHashResult.tx.value.signatures": {
      "properties": {
        "pubKey": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getMempoolByHashResult.tx.value.signatures.pubKey"
          }
        },
        "signature": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "pubKey",
        "signature"
      ]
    },
    "getMempoolByHashResult.tx.value.signatures.pubKey": {
      "properties": {
        "type": {
          "type": "string",
          "description": ""
        },
        "value": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "type",
        "value"
      ]
    },
    "getTxResult": {
      "properties": {
        "tx": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getTxResult.tx"
        },
        "events": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxResult.events"
          }
        },
        "logs": {
          "type": "array",
          "description": "tx logs",
          "items": {
            "$ref": "#/definitions/getTxResult.logs"
          }
        },
        "height": {
          "type": "string",
          "description": ""
        },
        "txhash": {
          "type": "string",
          "description": ""
        },
        "raw_log": {
          "type": "string",
          "description": ""
        },
        "gas_used": {
          "type": "string",
          "description": ""
        },
        "timestamp": {
          "type": "string",
          "description": ""
        },
        "gas_wanted": {
          "type": "string",
          "description": ""
        },
        "chainId": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "tx",
        "events",
        "logs",
        "height",
        "txhash",
        "raw_log",
        "gas_used",
        "timestamp",
        "gas_wanted",
        "chainId"
      ]
    },
    "getTxResult.tx": {
      "properties": {
        "type": {
          "type": "string",
          "description": ""
        },
        "value": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getTxResult.tx.value"
        }
      },
      "required": [
        "type",
        "value"
      ]
    },
    "getTxResult.tx.value": {
      "properties": {
        "fee": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getTxResult.tx.value.fee"
        },
        "memo": {
          "type": "string",
          "description": ""
        },
        "msg": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxResult.tx.value.msg"
          }
        },
        "signatures": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxResult.tx.value.signatures"
          }
        }
      },
      "required": [
        "fee",
        "memo",
        "msg",
        "signatures"
      ]
    },
    "getTxResult.tx.value.fee": {
      "properties": {
        "amount": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxResult.tx.value.fee.amount"
          }
        },
        "gas": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "amount",
        "gas"
      ]
    },
    "getTxResult.tx.value.fee.amount": {
      "properties": {
        "denom": {
          "type": "string",
          "description": ""
        },
        "amount": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "denom",
        "amount"
      ]
    },
    "getTxResult.tx.value.msg": {
      "properties": {
        "type": {
          "type": "string",
          "description": ""
        },
        "value": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getTxResult.tx.value.msg.value"
        }
      },
      "required": [
        "type",
        "value"
      ]
    },
    "getTxResult.tx.value.msg.value": {
      "properties": {
        "amount": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxResult.tx.value.msg.value.amount"
          }
        }
      },
      "required": [
        "amount"
      ]
    },
    "getTxResult.tx.value.msg.value.amount": {
      "properties": {
        "denom": {
          "type": "string",
          "description": ""
        },
        "amount": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "denom",
        "amount"
      ]
    },
    "getTxResult.tx.value.signatures": {
      "properties": {
        "pubKey": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxResult.tx.value.signatures.pubKey"
          }
        },
        "signature": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "pubKey",
        "signature"
      ]
    },
    "getTxResult.tx.value.signatures.pubKey": {
      "properties": {
        "type": {
          "type": "string",
          "description": ""
        },
        "value": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "type",
        "value"
      ]
    },
    "getTxResult.events": {
      "properties": {
        "type": {
          "type": "string",
          "description": ""
        },
        "attributes": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxResult.events.attributes"
          }
        }
      },
      "required": [
        "type",
        "attributes"
      ]
    },
    "getTxResult.events.attributes": {
      "properties": {
        "key": {
          "type": "string",
          "description": ""
        },
        "value": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "key",
        "value"
      ]
    },
    "getTxResult.logs": {
      "properties": {
        "events": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxResult.logs.events"
          }
        },
        "log": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getTxResult.logs.log"
        },
        "msg_index": {
          "type": "number",
          "description": ""
        },
        "success": {
          "type": "boolean",
          "description": ""
        }
      },
      "required": [
        "events",
        "log",
        "msg_index",
        "success"
      ]
    },
    "getTxResult.logs.events": {
      "properties": {
        "attributes": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxResult.logs.events.attributes"
          }
        },
        "types": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "attributes",
        "types"
      ]
    },
    "getTxResult.logs.events.attributes": {
      "properties": {
        "key": {
          "type": "string",
          "description": ""
        },
        "value": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "key",
        "value"
      ]
    },
    "getTxResult.logs.log": {
      "properties": {
        "tax": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "tax"
      ]
    },
    "getTxListResult": {
      "properties": {
        "limit": {
          "type": "number",
          "description": "Size of page"
        },
        "next": {
          "type": "number",
          "description": "Offset of next page"
        },
        "txs": {
          "type": "array",
          "description": "tx list",
          "items": {
            "$ref": "#/definitions/getTxListResult.txs"
          }
        }
      },
      "required": [
        "limit",
        "next",
        "txs"
      ]
    },
    "getTxListResult.txs": {
      "properties": {
        "tx": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getTxListResult.txs.tx"
        },
        "events": {
          "type": "array",
          "description": "events of tx",
          "items": {
            "$ref": "#/definitions/getTxListResult.txs.events"
          }
        },
        "logs": {
          "type": "array",
          "description": "tx logs",
          "items": {
            "$ref": "#/definitions/getTxListResult.txs.logs"
          }
        },
        "height": {
          "type": "string",
          "description": "block height"
        },
        "txhash": {
          "type": "string",
          "description": "tx hash"
        },
        "raw_log": {
          "type": "string",
          "description": "tx raw log"
        },
        "gas_used": {
          "type": "string",
          "description": "total gas used in tx"
        },
        "timestamp": {
          "type": "string",
          "description": "timestamp tx in utc 0"
        },
        "gas_wanted": {
          "type": "string",
          "description": "gas wanted"
        }
      },
      "required": [
        "tx",
        "events",
        "logs",
        "height",
        "txhash",
        "raw_log",
        "gas_used",
        "timestamp",
        "gas_wanted"
      ]
    },
    "getTxListResult.txs.tx": {
      "properties": {
        "type": {
          "type": "string",
          "description": ""
        },
        "value": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getTxListResult.txs.tx.value"
        }
      },
      "required": [
        "type",
        "value"
      ]
    },
    "getTxListResult.txs.tx.value": {
      "properties": {
        "fee": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getTxListResult.txs.tx.value.fee"
        },
        "memo": {
          "type": "string",
          "description": ""
        },
        "msg": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxListResult.txs.tx.value.msg"
          }
        },
        "signatures": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxListResult.txs.tx.value.signatures"
          }
        }
      },
      "required": [
        "fee",
        "memo",
        "msg",
        "signatures"
      ]
    },
    "getTxListResult.txs.tx.value.fee": {
      "properties": {
        "gas": {
          "type": "string",
          "description": ""
        },
        "amount": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxListResult.txs.tx.value.fee.amount"
          }
        }
      },
      "required": [
        "gas",
        "amount"
      ]
    },
    "getTxListResult.txs.tx.value.fee.amount": {
      "properties": {
        "denom": {
          "type": "string",
          "description": ""
        },
        "amount": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "denom",
        "amount"
      ]
    },
    "getTxListResult.txs.tx.value.msg": {
      "properties": {
        "type": {
          "type": "string",
          "description": ""
        },
        "value": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getTxListResult.txs.tx.value.msg.value"
        }
      },
      "required": [
        "type",
        "value"
      ]
    },
    "getTxListResult.txs.tx.value.msg.value": {
      "properties": {
        "inputs": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxListResult.txs.tx.value.msg.value.inputs"
          }
        },
        "outputs": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxListResult.txs.tx.value.msg.value.outputs"
          }
        }
      },
      "required": [
        "inputs",
        "outputs"
      ]
    },
    "getTxListResult.txs.tx.value.msg.value.inputs": {
      "properties": {
        "address": {
          "type": "string",
          "description": ""
        },
        "coins": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxListResult.txs.tx.value.msg.value.inputs.coins"
          }
        }
      },
      "required": [
        "address",
        "coins"
      ]
    },
    "getTxListResult.txs.tx.value.msg.value.inputs.coins": {
      "properties": {
        "deonm": {
          "type": "string",
          "description": ""
        },
        "amount": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "deonm",
        "amount"
      ]
    },
    "getTxListResult.txs.tx.value.msg.value.outputs": {
      "properties": {
        "address": {
          "type": "string",
          "description": ""
        },
        "coins": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxListResult.txs.tx.value.msg.value.outputs.coins"
          }
        }
      },
      "required": [
        "address",
        "coins"
      ]
    },
    "getTxListResult.txs.tx.value.msg.value.outputs.coins": {
      "properties": {
        "deonm": {
          "type": "string",
          "description": ""
        },
        "amount": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "deonm",
        "amount"
      ]
    },
    "getTxListResult.txs.tx.value.signatures": {
      "properties": {
        "signature": {
          "type": "string",
          "description": ""
        },
        "pub_key": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getTxListResult.txs.tx.value.signatures.pub_key"
        }
      },
      "required": [
        "signature",
        "pub_key"
      ]
    },
    "getTxListResult.txs.tx.value.signatures.pub_key": {
      "properties": {
        "type": {
          "type": "string",
          "description": ""
        },
        "value": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "type",
        "value"
      ]
    },
    "getTxListResult.txs.events": {
      "properties": {
        "type": {
          "type": "string",
          "description": ""
        },
        "attributes": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxListResult.txs.events.attributes"
          }
        }
      },
      "required": [
        "type",
        "attributes"
      ]
    },
    "getTxListResult.txs.events.attributes": {
      "properties": {
        "key": {
          "type": "string",
          "description": ""
        },
        "value": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "key",
        "value"
      ]
    },
    "getTxListResult.txs.logs": {
      "properties": {
        "msg_index": {
          "type": "number",
          "description": ""
        },
        "success": {
          "type": "boolean",
          "description": ""
        },
        "log": {
          "type": "object",
          "description": "",
          "$ref": "#/definitions/getTxListResult.txs.logs.log"
        },
        "events": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxListResult.txs.logs.events"
          }
        }
      },
      "required": [
        "msg_index",
        "success",
        "log",
        "events"
      ]
    },
    "getTxListResult.txs.logs.log": {
      "properties": {
        "tax": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "tax"
      ]
    },
    "getTxListResult.txs.logs.events": {
      "properties": {
        "type": {
          "type": "string",
          "description": ""
        },
        "attributes": {
          "type": "array",
          "description": "",
          "items": {
            "$ref": "#/definitions/getTxListResult.txs.logs.events.attributes"
          }
        }
      },
      "required": [
        "type",
        "attributes"
      ]
    },
    "getTxListResult.txs.logs.events.attributes": {
      "properties": {
        "key": {
          "type": "string",
          "description": ""
        },
        "value": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "key",
        "value"
      ]
    },
    "postTxsBody": {
      "properties": {
        "tx": {
          "type": "object",
          "description": "request tx must be signed",
          "$ref": "#/definitions/postTxsBody.tx"
        },
        "mode": {
          "type": "string",
          "description": "broadcast mode"
        }
      },
      "required": [
        "tx",
        "mode"
      ]
    },
    "postTxsBody.tx": {
      "properties": {
        "msg": {
          "type": "array",
          "description": "tx message",
          "items": {
            "type": "string"
          }
        },
        "fee": {
          "type": "object",
          "description": "tx fee",
          "$ref": "#/definitions/postTxsBody.tx.fee"
        },
        "signature": {
          "type": "object",
          "description": "tx signature",
          "$ref": "#/definitions/postTxsBody.tx.signature"
        },
        "memo": {
          "type": "string",
          "description": "Information related to tx"
        }
      },
      "required": [
        "msg",
        "fee",
        "signature",
        "memo"
      ]
    },
    "postTxsBody.tx.fee": {
      "properties": {
        "gas": {
          "type": "string",
          "description": "tx gas"
        },
        "amount": {
          "type": "array",
          "description": "tx gas amount",
          "items": {
            "$ref": "#/definitions/postTxsBody.tx.fee.amount"
          }
        }
      },
      "required": [
        "gas",
        "amount"
      ]
    },
    "postTxsBody.tx.fee.amount": {
      "properties": {
        "denom": {
          "type": "string",
          "description": "tx gas amount"
        },
        "amount": {
          "type": "string",
          "description": "tx gas amount"
        }
      },
      "required": [
        "denom",
        "amount"
      ]
    },
    "postTxsBody.tx.signature": {
      "properties": {
        "signature": {
          "type": "string",
          "description": "tx signature"
        },
        "pub_key": {
          "type": "object",
          "description": "tx signature",
          "$ref": "#/definitions/postTxsBody.tx.signature.pub_key"
        },
        "account_number": {
          "type": "string",
          "description": "tx signature"
        },
        "sequence": {
          "type": "string",
          "description": "tx sequence of the account"
        }
      },
      "required": [
        "signature",
        "pub_key",
        "account_number",
        "sequence"
      ]
    },
    "postTxsBody.tx.signature.pub_key": {
      "properties": {
        "type": {
          "type": "string",
          "description": "Key type"
        },
        "value": {
          "type": "string",
          "description": "Key value"
        }
      },
      "required": [
        "type",
        "value"
      ]
    },
    "postTxsResult": {
      "properties": {
        "hash": {
          "type": "string",
          "description": "Tx hash"
        },
        "height": {
          "type": "number",
          "description": "Block height"
        },
        "check_tx": {
          "type": "object",
          "description": "tx info",
          "$ref": "#/definitions/postTxsResult.check_tx"
        },
        "deliver_tx": {
          "type": "object",
          "description": "tx info",
          "$ref": "#/definitions/postTxsResult.deliver_tx"
        }
      },
      "required": [
        "hash",
        "height",
        "check_tx",
        "deliver_tx"
      ]
    },
    "postTxsResult.check_tx": {
      "properties": {
        "code": {
          "type": "number",
          "description": ""
        },
        "data": {
          "type": "string",
          "description": ""
        },
        "log": {
          "type": "string",
          "description": ""
        },
        "gas_used": {
          "type": "number",
          "description": ""
        },
        "gas_wanted": {
          "type": "number",
          "description": ""
        },
        "info": {
          "type": "string",
          "description": ""
        },
        "tags": {
          "type": "array",
          "description": "",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "code",
        "data",
        "log",
        "gas_used",
        "gas_wanted",
        "info",
        "tags"
      ]
    },
    "postTxsResult.deliver_tx": {
      "properties": {
        "code": {
          "type": "number",
          "description": ""
        },
        "data": {
          "type": "string",
          "description": ""
        },
        "log": {
          "type": "string",
          "description": ""
        },
        "gas_used": {
          "type": "number",
          "description": ""
        },
        "gas_wanted": {
          "type": "number",
          "description": ""
        },
        "info": {
          "type": "string",
          "description": ""
        },
        "tags": {
          "type": "array",
          "description": "",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "code",
        "data",
        "log",
        "gas_used",
        "gas_wanted",
        "info",
        "tags"
      ]
    },
    "accounts": {
      "properties": {
        "account": {
          "type": "number",
          "description": ""
        },
        "amount": {
          "type": "string",
          "description": ""
        },
        "percentage": {
          "type": "string",
          "description": ""
        }
      },
      "required": [
        "account",
        "amount",
        "percentage"
      ]
    },
    "getTaxProceedsResult": {
      "properties": {
        "total": {
          "type": "number",
          "description": "Current tax proceeds"
        },
        "taxProceeds": {
          "type": "array",
          "description": "tax by denoms",
          "items": {
            "$ref": "#/definitions/getTaxProceedsResult.taxProceeds"
          }
        }
      },
      "required": [
        "total",
        "taxProceeds"
      ]
    },
    "getTaxProceedsResult.taxProceeds": {
      "properties": {
        "denom": {
          "type": "string",
          "description": "denom name"
        },
        "amount": {
          "type": "string",
          "description": "amount by denom"
        },
        "adjustedAmount": {
          "type": "string",
          "description": "amount by adjusted with luna"
        }
      },
      "required": [
        "denom",
        "amount",
        "adjustedAmount"
      ]
    }
  }
}